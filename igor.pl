#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Algorithm/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFF';
  package Algorithm::Diff;
  # Skip to first "=head" line for documentation.
  use strict;
  
  use integer;    # see below in _replaceNextLargerWith() for mod to make
                  # if you don't use this
  use vars qw( $VERSION @EXPORT_OK );
  $VERSION = 1.19_03;
  #          ^ ^^ ^^-- Incremented at will
  #          | \+----- Incremented for non-trivial changes to features
  #          \-------- Incremented for fundamental changes
  require Exporter;
  *import    = \&Exporter::import;
  @EXPORT_OK = qw(
      prepare LCS LCSidx LCS_length
      diff sdiff compact_diff
      traverse_sequences traverse_balanced
  );
  
  # McIlroy-Hunt diff algorithm
  # Adapted from the Smalltalk code of Mario I. Wolczko, <mario@wolczko.com>
  # by Ned Konz, perl@bike-nomad.com
  # Updates by Tye McQueen, http://perlmonks.org/?node=tye
  
  # Create a hash that maps each element of $aCollection to the set of
  # positions it occupies in $aCollection, restricted to the elements
  # within the range of indexes specified by $start and $end.
  # The fourth parameter is a subroutine reference that will be called to
  # generate a string to use as a key.
  # Additional parameters, if any, will be passed to this subroutine.
  #
  # my $hashRef = _withPositionsOfInInterval( \@array, $start, $end, $keyGen );
  
  sub _withPositionsOfInInterval
  {
      my $aCollection = shift;    # array ref
      my $start       = shift;
      my $end         = shift;
      my $keyGen      = shift;
      my %d;
      my $index;
      for ( $index = $start ; $index <= $end ; $index++ )
      {
          my $element = $aCollection->[$index];
          my $key = &$keyGen( $element, @_ );
          if ( exists( $d{$key} ) )
          {
              unshift ( @{ $d{$key} }, $index );
          }
          else
          {
              $d{$key} = [$index];
          }
      }
      return wantarray ? %d : \%d;
  }
  
  # Find the place at which aValue would normally be inserted into the
  # array. If that place is already occupied by aValue, do nothing, and
  # return undef. If the place does not exist (i.e., it is off the end of
  # the array), add it to the end, otherwise replace the element at that
  # point with aValue.  It is assumed that the array's values are numeric.
  # This is where the bulk (75%) of the time is spent in this module, so
  # try to make it fast!
  
  sub _replaceNextLargerWith
  {
      my ( $array, $aValue, $high ) = @_;
      $high ||= $#$array;
  
      # off the end?
      if ( $high == -1 || $aValue > $array->[-1] )
      {
          push ( @$array, $aValue );
          return $high + 1;
      }
  
      # binary search for insertion point...
      my $low = 0;
      my $index;
      my $found;
      while ( $low <= $high )
      {
          $index = ( $high + $low ) / 2;
  
          # $index = int(( $high + $low ) / 2);  # without 'use integer'
          $found = $array->[$index];
  
          if ( $aValue == $found )
          {
              return undef;
          }
          elsif ( $aValue > $found )
          {
              $low = $index + 1;
          }
          else
          {
              $high = $index - 1;
          }
      }
  
      # now insertion point is in $low.
      $array->[$low] = $aValue;    # overwrite next larger
      return $low;
  }
  
  # This method computes the longest common subsequence in $a and $b.
  
  # Result is array or ref, whose contents is such that
  #   $a->[ $i ] == $b->[ $result[ $i ] ]
  # foreach $i in ( 0 .. $#result ) if $result[ $i ] is defined.
  
  # An additional argument may be passed; this is a hash or key generating
  # function that should return a string that uniquely identifies the given
  # element.  It should be the case that if the key is the same, the elements
  # will compare the same. If this parameter is undef or missing, the key
  # will be the element as a string.
  
  # By default, comparisons will use "eq" and elements will be turned into keys
  # using the default stringizing operator '""'.
  
  # Additional parameters, if any, will be passed to the key generation
  # routine.
  
  sub _longestCommonSubsequence
  {
      my $a        = shift;    # array ref or hash ref
      my $b        = shift;    # array ref or hash ref
      my $counting = shift;    # scalar
      my $keyGen   = shift;    # code ref
      my $compare;             # code ref
  
      if ( ref($a) eq 'HASH' )
      {                        # prepared hash must be in $b
          my $tmp = $b;
          $b = $a;
          $a = $tmp;
      }
  
      # Check for bogus (non-ref) argument values
      if ( !ref($a) || !ref($b) )
      {
          my @callerInfo = caller(1);
          die 'error: must pass array or hash references to ' . $callerInfo[3];
      }
  
      # set up code refs
      # Note that these are optimized.
      if ( !defined($keyGen) )    # optimize for strings
      {
          $keyGen = sub { $_[0] };
          $compare = sub { my ( $a, $b ) = @_; $a eq $b };
      }
      else
      {
          $compare = sub {
              my $a = shift;
              my $b = shift;
              &$keyGen( $a, @_ ) eq &$keyGen( $b, @_ );
          };
      }
  
      my ( $aStart, $aFinish, $matchVector ) = ( 0, $#$a, [] );
      my ( $prunedCount, $bMatches ) = ( 0, {} );
  
      if ( ref($b) eq 'HASH' )    # was $bMatches prepared for us?
      {
          $bMatches = $b;
      }
      else
      {
          my ( $bStart, $bFinish ) = ( 0, $#$b );
  
          # First we prune off any common elements at the beginning
          while ( $aStart <= $aFinish
              and $bStart <= $bFinish
              and &$compare( $a->[$aStart], $b->[$bStart], @_ ) )
          {
              $matchVector->[ $aStart++ ] = $bStart++;
              $prunedCount++;
          }
  
          # now the end
          while ( $aStart <= $aFinish
              and $bStart <= $bFinish
              and &$compare( $a->[$aFinish], $b->[$bFinish], @_ ) )
          {
              $matchVector->[ $aFinish-- ] = $bFinish--;
              $prunedCount++;
          }
  
          # Now compute the equivalence classes of positions of elements
          $bMatches =
            _withPositionsOfInInterval( $b, $bStart, $bFinish, $keyGen, @_ );
      }
      my $thresh = [];
      my $links  = [];
  
      my ( $i, $ai, $j, $k );
      for ( $i = $aStart ; $i <= $aFinish ; $i++ )
      {
          $ai = &$keyGen( $a->[$i], @_ );
          if ( exists( $bMatches->{$ai} ) )
          {
              $k = 0;
              for $j ( @{ $bMatches->{$ai} } )
              {
  
                  # optimization: most of the time this will be true
                  if ( $k and $thresh->[$k] > $j and $thresh->[ $k - 1 ] < $j )
                  {
                      $thresh->[$k] = $j;
                  }
                  else
                  {
                      $k = _replaceNextLargerWith( $thresh, $j, $k );
                  }
  
                  # oddly, it's faster to always test this (CPU cache?).
                  if ( defined($k) )
                  {
                      $links->[$k] =
                        [ ( $k ? $links->[ $k - 1 ] : undef ), $i, $j ];
                  }
              }
          }
      }
  
      if (@$thresh)
      {
          return $prunedCount + @$thresh if $counting;
          for ( my $link = $links->[$#$thresh] ; $link ; $link = $link->[0] )
          {
              $matchVector->[ $link->[1] ] = $link->[2];
          }
      }
      elsif ($counting)
      {
          return $prunedCount;
      }
  
      return wantarray ? @$matchVector : $matchVector;
  }
  
  sub traverse_sequences
  {
      my $a                 = shift;          # array ref
      my $b                 = shift;          # array ref
      my $callbacks         = shift || {};
      my $keyGen            = shift;
      my $matchCallback     = $callbacks->{'MATCH'} || sub { };
      my $discardACallback  = $callbacks->{'DISCARD_A'} || sub { };
      my $finishedACallback = $callbacks->{'A_FINISHED'};
      my $discardBCallback  = $callbacks->{'DISCARD_B'} || sub { };
      my $finishedBCallback = $callbacks->{'B_FINISHED'};
      my $matchVector = _longestCommonSubsequence( $a, $b, 0, $keyGen, @_ );
  
      # Process all the lines in @$matchVector
      my $lastA = $#$a;
      my $lastB = $#$b;
      my $bi    = 0;
      my $ai;
  
      for ( $ai = 0 ; $ai <= $#$matchVector ; $ai++ )
      {
          my $bLine = $matchVector->[$ai];
          if ( defined($bLine) )    # matched
          {
              &$discardBCallback( $ai, $bi++, @_ ) while $bi < $bLine;
              &$matchCallback( $ai,    $bi++, @_ );
          }
          else
          {
              &$discardACallback( $ai, $bi, @_ );
          }
      }
  
      # The last entry (if any) processed was a match.
      # $ai and $bi point just past the last matching lines in their sequences.
  
      while ( $ai <= $lastA or $bi <= $lastB )
      {
  
          # last A?
          if ( $ai == $lastA + 1 and $bi <= $lastB )
          {
              if ( defined($finishedACallback) )
              {
                  &$finishedACallback( $lastA, @_ );
                  $finishedACallback = undef;
              }
              else
              {
                  &$discardBCallback( $ai, $bi++, @_ ) while $bi <= $lastB;
              }
          }
  
          # last B?
          if ( $bi == $lastB + 1 and $ai <= $lastA )
          {
              if ( defined($finishedBCallback) )
              {
                  &$finishedBCallback( $lastB, @_ );
                  $finishedBCallback = undef;
              }
              else
              {
                  &$discardACallback( $ai++, $bi, @_ ) while $ai <= $lastA;
              }
          }
  
          &$discardACallback( $ai++, $bi, @_ ) if $ai <= $lastA;
          &$discardBCallback( $ai, $bi++, @_ ) if $bi <= $lastB;
      }
  
      return 1;
  }
  
  sub traverse_balanced
  {
      my $a                 = shift;              # array ref
      my $b                 = shift;              # array ref
      my $callbacks         = shift || {};
      my $keyGen            = shift;
      my $matchCallback     = $callbacks->{'MATCH'} || sub { };
      my $discardACallback  = $callbacks->{'DISCARD_A'} || sub { };
      my $discardBCallback  = $callbacks->{'DISCARD_B'} || sub { };
      my $changeCallback    = $callbacks->{'CHANGE'};
      my $matchVector = _longestCommonSubsequence( $a, $b, 0, $keyGen, @_ );
  
      # Process all the lines in match vector
      my $lastA = $#$a;
      my $lastB = $#$b;
      my $bi    = 0;
      my $ai    = 0;
      my $ma    = -1;
      my $mb;
  
      while (1)
      {
  
          # Find next match indices $ma and $mb
          do {
              $ma++;
          } while(
                  $ma <= $#$matchVector
              &&  !defined $matchVector->[$ma]
          );
  
          last if $ma > $#$matchVector;    # end of matchVector?
          $mb = $matchVector->[$ma];
  
          # Proceed with discard a/b or change events until
          # next match
          while ( $ai < $ma || $bi < $mb )
          {
  
              if ( $ai < $ma && $bi < $mb )
              {
  
                  # Change
                  if ( defined $changeCallback )
                  {
                      &$changeCallback( $ai++, $bi++, @_ );
                  }
                  else
                  {
                      &$discardACallback( $ai++, $bi, @_ );
                      &$discardBCallback( $ai, $bi++, @_ );
                  }
              }
              elsif ( $ai < $ma )
              {
                  &$discardACallback( $ai++, $bi, @_ );
              }
              else
              {
  
                  # $bi < $mb
                  &$discardBCallback( $ai, $bi++, @_ );
              }
          }
  
          # Match
          &$matchCallback( $ai++, $bi++, @_ );
      }
  
      while ( $ai <= $lastA || $bi <= $lastB )
      {
          if ( $ai <= $lastA && $bi <= $lastB )
          {
  
              # Change
              if ( defined $changeCallback )
              {
                  &$changeCallback( $ai++, $bi++, @_ );
              }
              else
              {
                  &$discardACallback( $ai++, $bi, @_ );
                  &$discardBCallback( $ai, $bi++, @_ );
              }
          }
          elsif ( $ai <= $lastA )
          {
              &$discardACallback( $ai++, $bi, @_ );
          }
          else
          {
  
              # $bi <= $lastB
              &$discardBCallback( $ai, $bi++, @_ );
          }
      }
  
      return 1;
  }
  
  sub prepare
  {
      my $a       = shift;    # array ref
      my $keyGen  = shift;    # code ref
  
      # set up code ref
      $keyGen = sub { $_[0] } unless defined($keyGen);
  
      return scalar _withPositionsOfInInterval( $a, 0, $#$a, $keyGen, @_ );
  }
  
  sub LCS
  {
      my $a = shift;                  # array ref
      my $b = shift;                  # array ref or hash ref
      my $matchVector = _longestCommonSubsequence( $a, $b, 0, @_ );
      my @retval;
      my $i;
      for ( $i = 0 ; $i <= $#$matchVector ; $i++ )
      {
          if ( defined( $matchVector->[$i] ) )
          {
              push ( @retval, $a->[$i] );
          }
      }
      return wantarray ? @retval : \@retval;
  }
  
  sub LCS_length
  {
      my $a = shift;                          # array ref
      my $b = shift;                          # array ref or hash ref
      return _longestCommonSubsequence( $a, $b, 1, @_ );
  }
  
  sub LCSidx
  {
      my $a= shift @_;
      my $b= shift @_;
      my $match= _longestCommonSubsequence( $a, $b, 0, @_ );
      my @am= grep defined $match->[$_], 0..$#$match;
      my @bm= @{$match}[@am];
      return \@am, \@bm;
  }
  
  sub compact_diff
  {
      my $a= shift @_;
      my $b= shift @_;
      my( $am, $bm )= LCSidx( $a, $b, @_ );
      my @cdiff;
      my( $ai, $bi )= ( 0, 0 );
      push @cdiff, $ai, $bi;
      while( 1 ) {
          while(  @$am  &&  $ai == $am->[0]  &&  $bi == $bm->[0]  ) {
              shift @$am;
              shift @$bm;
              ++$ai, ++$bi;
          }
          push @cdiff, $ai, $bi;
          last   if  ! @$am;
          $ai = $am->[0];
          $bi = $bm->[0];
          push @cdiff, $ai, $bi;
      }
      push @cdiff, 0+@$a, 0+@$b
          if  $ai < @$a || $bi < @$b;
      return wantarray ? @cdiff : \@cdiff;
  }
  
  sub diff
  {
      my $a      = shift;    # array ref
      my $b      = shift;    # array ref
      my $retval = [];
      my $hunk   = [];
      my $discard = sub {
          push @$hunk, [ '-', $_[0], $a->[ $_[0] ] ];
      };
      my $add = sub {
          push @$hunk, [ '+', $_[1], $b->[ $_[1] ] ];
      };
      my $match = sub {
          push @$retval, $hunk
              if 0 < @$hunk;
          $hunk = []
      };
      traverse_sequences( $a, $b,
          { MATCH => $match, DISCARD_A => $discard, DISCARD_B => $add }, @_ );
      &$match();
      return wantarray ? @$retval : $retval;
  }
  
  sub sdiff
  {
      my $a      = shift;    # array ref
      my $b      = shift;    # array ref
      my $retval = [];
      my $discard = sub { push ( @$retval, [ '-', $a->[ $_[0] ], "" ] ) };
      my $add = sub { push ( @$retval, [ '+', "", $b->[ $_[1] ] ] ) };
      my $change = sub {
          push ( @$retval, [ 'c', $a->[ $_[0] ], $b->[ $_[1] ] ] );
      };
      my $match = sub {
          push ( @$retval, [ 'u', $a->[ $_[0] ], $b->[ $_[1] ] ] );
      };
      traverse_balanced(
          $a,
          $b,
          {
              MATCH     => $match,
              DISCARD_A => $discard,
              DISCARD_B => $add,
              CHANGE    => $change,
          },
          @_
      );
      return wantarray ? @$retval : $retval;
  }
  
  ########################################
  my $Root= __PACKAGE__;
  package Algorithm::Diff::_impl;
  use strict;
  
  sub _Idx()  { 0 } # $me->[_Idx]: Ref to array of hunk indices
              # 1   # $me->[1]: Ref to first sequence
              # 2   # $me->[2]: Ref to second sequence
  sub _End()  { 3 } # $me->[_End]: Diff between forward and reverse pos
  sub _Same() { 4 } # $me->[_Same]: 1 if pos 1 contains unchanged items
  sub _Base() { 5 } # $me->[_Base]: Added to range's min and max
  sub _Pos()  { 6 } # $me->[_Pos]: Which hunk is currently selected
  sub _Off()  { 7 } # $me->[_Off]: Offset into _Idx for current position
  sub _Min() { -2 } # Added to _Off to get min instead of max+1
  
  sub Die
  {
      require Carp;
      Carp::confess( @_ );
  }
  
  sub _ChkPos
  {
      my( $me )= @_;
      return   if  $me->[_Pos];
      my $meth= ( caller(1) )[3];
      Die( "Called $meth on 'reset' object" );
  }
  
  sub _ChkSeq
  {
      my( $me, $seq )= @_;
      return $seq + $me->[_Off]
          if  1 == $seq  ||  2 == $seq;
      my $meth= ( caller(1) )[3];
      Die( "$meth: Invalid sequence number ($seq); must be 1 or 2" );
  }
  
  sub getObjPkg
  {
      my( $us )= @_;
      return ref $us   if  ref $us;
      return $us . "::_obj";
  }
  
  sub new
  {
      my( $us, $seq1, $seq2, $opts ) = @_;
      my @args;
      for( $opts->{keyGen} ) {
          push @args, $_   if  $_;
      }
      for( $opts->{keyGenArgs} ) {
          push @args, @$_   if  $_;
      }
      my $cdif= Algorithm::Diff::compact_diff( $seq1, $seq2, @args );
      my $same= 1;
      if(  0 == $cdif->[2]  &&  0 == $cdif->[3]  ) {
          $same= 0;
          splice @$cdif, 0, 2;
      }
      my @obj= ( $cdif, $seq1, $seq2 );
      $obj[_End] = (1+@$cdif)/2;
      $obj[_Same] = $same;
      $obj[_Base] = 0;
      my $me = bless \@obj, $us->getObjPkg();
      $me->Reset( 0 );
      return $me;
  }
  
  sub Reset
  {
      my( $me, $pos )= @_;
      $pos= int( $pos || 0 );
      $pos += $me->[_End]
          if  $pos < 0;
      $pos= 0
          if  $pos < 0  ||  $me->[_End] <= $pos;
      $me->[_Pos]= $pos || !1;
      $me->[_Off]= 2*$pos - 1;
      return $me;
  }
  
  sub Base
  {
      my( $me, $base )= @_;
      my $oldBase= $me->[_Base];
      $me->[_Base]= 0+$base   if  defined $base;
      return $oldBase;
  }
  
  sub Copy
  {
      my( $me, $pos, $base )= @_;
      my @obj= @$me;
      my $you= bless \@obj, ref($me);
      $you->Reset( $pos )   if  defined $pos;
      $you->Base( $base );
      return $you;
  }
  
  sub Next {
      my( $me, $steps )= @_;
      $steps= 1   if  ! defined $steps;
      if( $steps ) {
          my $pos= $me->[_Pos];
          my $new= $pos + $steps;
          $new= 0   if  $pos  &&  $new < 0;
          $me->Reset( $new )
      }
      return $me->[_Pos];
  }
  
  sub Prev {
      my( $me, $steps )= @_;
      $steps= 1   if  ! defined $steps;
      my $pos= $me->Next(-$steps);
      $pos -= $me->[_End]   if  $pos;
      return $pos;
  }
  
  sub Diff {
      my( $me )= @_;
      $me->_ChkPos();
      return 0   if  $me->[_Same] == ( 1 & $me->[_Pos] );
      my $ret= 0;
      my $off= $me->[_Off];
      for my $seq ( 1, 2 ) {
          $ret |= $seq
              if  $me->[_Idx][ $off + $seq + _Min ]
              <   $me->[_Idx][ $off + $seq ];
      }
      return $ret;
  }
  
  sub Min {
      my( $me, $seq, $base )= @_;
      $me->_ChkPos();
      my $off= $me->_ChkSeq($seq);
      $base= $me->[_Base] if !defined $base;
      return $base + $me->[_Idx][ $off + _Min ];
  }
  
  sub Max {
      my( $me, $seq, $base )= @_;
      $me->_ChkPos();
      my $off= $me->_ChkSeq($seq);
      $base= $me->[_Base] if !defined $base;
      return $base + $me->[_Idx][ $off ] -1;
  }
  
  sub Range {
      my( $me, $seq, $base )= @_;
      $me->_ChkPos();
      my $off = $me->_ChkSeq($seq);
      if( !wantarray ) {
          return  $me->[_Idx][ $off ]
              -   $me->[_Idx][ $off + _Min ];
      }
      $base= $me->[_Base] if !defined $base;
      return  ( $base + $me->[_Idx][ $off + _Min ] )
          ..  ( $base + $me->[_Idx][ $off ] - 1 );
  }
  
  sub Items {
      my( $me, $seq )= @_;
      $me->_ChkPos();
      my $off = $me->_ChkSeq($seq);
      if( !wantarray ) {
          return  $me->[_Idx][ $off ]
              -   $me->[_Idx][ $off + _Min ];
      }
      return
          @{$me->[$seq]}[
                  $me->[_Idx][ $off + _Min ]
              ..  ( $me->[_Idx][ $off ] - 1 )
          ];
  }
  
  sub Same {
      my( $me )= @_;
      $me->_ChkPos();
      return wantarray ? () : 0
          if  $me->[_Same] != ( 1 & $me->[_Pos] );
      return $me->Items(1);
  }
  
  my %getName;
  BEGIN {
      %getName= (
          same => \&Same,
          diff => \&Diff,
          base => \&Base,
          min  => \&Min,
          max  => \&Max,
          range=> \&Range,
          items=> \&Items, # same thing
      );
  }
  
  sub Get
  {
      my $me= shift @_;
      $me->_ChkPos();
      my @value;
      for my $arg (  @_  ) {
          for my $word (  split ' ', $arg  ) {
              my $meth;
              if(     $word !~ /^(-?\d+)?([a-zA-Z]+)([12])?$/
                  ||  not  $meth= $getName{ lc $2 }
              ) {
                  Die( $Root, ", Get: Invalid request ($word)" );
              }
              my( $base, $name, $seq )= ( $1, $2, $3 );
              push @value, scalar(
                  4 == length($name)
                      ? $meth->( $me )
                      : $meth->( $me, $seq, $base )
              );
          }
      }
      if(  wantarray  ) {
          return @value;
      } elsif(  1 == @value  ) {
          return $value[0];
      }
      Die( 0+@value, " values requested from ",
          $Root, "'s Get in scalar context" );
  }
  
  
  my $Obj= getObjPkg($Root);
  no strict 'refs';
  
  for my $meth (  qw( new getObjPkg )  ) {
      *{$Root."::".$meth} = \&{$meth};
      *{$Obj ."::".$meth} = \&{$meth};
  }
  for my $meth (  qw(
      Next Prev Reset Copy Base Diff
      Same Items Range Min Max Get
      _ChkPos _ChkSeq
  )  ) {
      *{$Obj."::".$meth} = \&{$meth};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Algorithm::Diff - Compute `intelligent' differences between two files / lists
  
  =head1 SYNOPSIS
  
      require Algorithm::Diff;
  
      # This example produces traditional 'diff' output:
  
      my $diff = Algorithm::Diff->new( \@seq1, \@seq2 );
  
      $diff->Base( 1 );   # Return line numbers, not indices
      while(  $diff->Next()  ) {
          next   if  $diff->Same();
          my $sep = '';
          if(  ! $diff->Items(2)  ) {
              printf "%d,%dd%d\n",
                  $diff->Get(qw( Min1 Max1 Max2 ));
          } elsif(  ! $diff->Items(1)  ) {
              printf "%da%d,%d\n",
                  $diff->Get(qw( Max1 Min2 Max2 ));
          } else {
              $sep = "---\n";
              printf "%d,%dc%d,%d\n",
                  $diff->Get(qw( Min1 Max1 Min2 Max2 ));
          }
          print "< $_"   for  $diff->Items(1);
          print $sep;
          print "> $_"   for  $diff->Items(2);
      }
  
  
      # Alternate interfaces:
  
      use Algorithm::Diff qw(
          LCS LCS_length LCSidx
          diff sdiff compact_diff
          traverse_sequences traverse_balanced );
  
      @lcs    = LCS( \@seq1, \@seq2 );
      $lcsref = LCS( \@seq1, \@seq2 );
      $count  = LCS_length( \@seq1, \@seq2 );
  
      ( $seq1idxref, $seq2idxref ) = LCSidx( \@seq1, \@seq2 );
  
  
      # Complicated interfaces:
  
      @diffs  = diff( \@seq1, \@seq2 );
  
      @sdiffs = sdiff( \@seq1, \@seq2 );
  
      @cdiffs = compact_diff( \@seq1, \@seq2 );
  
      traverse_sequences(
          \@seq1,
          \@seq2,
          {   MATCH     => \&callback1,
              DISCARD_A => \&callback2,
              DISCARD_B => \&callback3,
          },
          \&key_generator,
          @extra_args,
      );
  
      traverse_balanced(
          \@seq1,
          \@seq2,
          {   MATCH     => \&callback1,
              DISCARD_A => \&callback2,
              DISCARD_B => \&callback3,
              CHANGE    => \&callback4,
          },
          \&key_generator,
          @extra_args,
      );
  
  
  =head1 INTRODUCTION
  
  (by Mark-Jason Dominus)
  
  I once read an article written by the authors of C<diff>; they said
  that they worked very hard on the algorithm until they found the
  right one.
  
  I think what they ended up using (and I hope someone will correct me,
  because I am not very confident about this) was the `longest common
  subsequence' method.  In the LCS problem, you have two sequences of
  items:
  
      a b c d f g h j q z
  
      a b c d e f g i j k r x y z
  
  and you want to find the longest sequence of items that is present in
  both original sequences in the same order.  That is, you want to find
  a new sequence I<S> which can be obtained from the first sequence by
  deleting some items, and from the second sequence by deleting other
  items.  You also want I<S> to be as long as possible.  In this case I<S>
  is
  
      a b c d f g j z
  
  From there it's only a small step to get diff-like output:
  
      e   h i   k   q r x y
      +   - +   +   - + + +
  
  This module solves the LCS problem.  It also includes a canned function
  to generate C<diff>-like output.
  
  It might seem from the example above that the LCS of two sequences is
  always pretty obvious, but that's not always the case, especially when
  the two sequences have many repeated elements.  For example, consider
  
      a x b y c z p d q
      a b c a x b y c z
  
  A naive approach might start by matching up the C<a> and C<b> that
  appear at the beginning of each sequence, like this:
  
      a x b y c         z p d q
      a   b   c a b y c z
  
  This finds the common subsequence C<a b c z>.  But actually, the LCS
  is C<a x b y c z>:
  
            a x b y c z p d q
      a b c a x b y c z
  
  or
  
      a       x b y c z p d q
      a b c a x b y c z
  
  =head1 USAGE
  
  (See also the README file and several example
  scripts include with this module.)
  
  This module now provides an object-oriented interface that uses less
  memory and is easier to use than most of the previous procedural
  interfaces.  It also still provides several exportable functions.  We'll
  deal with these in ascending order of difficulty:  C<LCS>,
  C<LCS_length>, C<LCSidx>, OO interface, C<prepare>, C<diff>, C<sdiff>,
  C<traverse_sequences>, and C<traverse_balanced>.
  
  =head2 C<LCS>
  
  Given references to two lists of items, LCS returns an array containing
  their longest common subsequence.  In scalar context, it returns a
  reference to such a list.
  
      @lcs    = LCS( \@seq1, \@seq2 );
      $lcsref = LCS( \@seq1, \@seq2 );
  
  C<LCS> may be passed an optional third parameter; this is a CODE
  reference to a key generation function.  See L</KEY GENERATION
  FUNCTIONS>.
  
      @lcs    = LCS( \@seq1, \@seq2, \&keyGen, @args );
      $lcsref = LCS( \@seq1, \@seq2, \&keyGen, @args );
  
  Additional parameters, if any, will be passed to the key generation
  routine.
  
  =head2 C<LCS_length>
  
  This is just like C<LCS> except it only returns the length of the
  longest common subsequence.  This provides a performance gain of about
  9% compared to C<LCS>.
  
  =head2 C<LCSidx>
  
  Like C<LCS> except it returns references to two arrays.  The first array
  contains the indices into @seq1 where the LCS items are located.  The
  second array contains the indices into @seq2 where the LCS items are located.
  
  Therefore, the following three lists will contain the same values:
  
      my( $idx1, $idx2 ) = LCSidx( \@seq1, \@seq2 );
      my @list1 = @seq1[ @$idx1 ];
      my @list2 = @seq2[ @$idx2 ];
      my @list3 = LCS( \@seq1, \@seq2 );
  
  =head2 C<new>
  
      $diff = Algorithm::Diffs->new( \@seq1, \@seq2 );
      $diff = Algorithm::Diffs->new( \@seq1, \@seq2, \%opts );
  
  C<new> computes the smallest set of additions and deletions necessary
  to turn the first sequence into the second and compactly records them
  in the object.
  
  You use the object to iterate over I<hunks>, where each hunk represents
  a contiguous section of items which should be added, deleted, replaced,
  or left unchanged.
  
  =over 4
  
  The following summary of all of the methods looks a lot like Perl code
  but some of the symbols have different meanings:
  
      [ ]     Encloses optional arguments
      :       Is followed by the default value for an optional argument
      |       Separates alternate return results
  
  Method summary:
  
      $obj        = Algorithm::Diff->new( \@seq1, \@seq2, [ \%opts ] );
      $pos        = $obj->Next(  [ $count : 1 ] );
      $revPos     = $obj->Prev(  [ $count : 1 ] );
      $obj        = $obj->Reset( [ $pos : 0 ] );
      $copy       = $obj->Copy(  [ $pos, [ $newBase ] ] );
      $oldBase    = $obj->Base(  [ $newBase ] );
  
  Note that all of the following methods C<die> if used on an object that
  is "reset" (not currently pointing at any hunk).
  
      $bits       = $obj->Diff(  );
      @items|$cnt = $obj->Same(  );
      @items|$cnt = $obj->Items( $seqNum );
      @idxs |$cnt = $obj->Range( $seqNum, [ $base ] );
      $minIdx     = $obj->Min(   $seqNum, [ $base ] );
      $maxIdx     = $obj->Max(   $seqNum, [ $base ] );
      @values     = $obj->Get(   @names );
  
  Passing in C<undef> for an optional argument is always treated the same
  as if no argument were passed in.
  
  =item C<Next>
  
      $pos = $diff->Next();    # Move forward 1 hunk
      $pos = $diff->Next( 2 ); # Move forward 2 hunks
      $pos = $diff->Next(-5);  # Move backward 5 hunks
  
  C<Next> moves the object to point at the next hunk.  The object starts
  out "reset", which means it isn't pointing at any hunk.  If the object
  is reset, then C<Next()> moves to the first hunk.
  
  C<Next> returns a true value iff the move didn't go past the last hunk.
  So C<Next(0)> will return true iff the object is not reset.
  
  Actually, C<Next> returns the object's new position, which is a number
  between 1 and the number of hunks (inclusive), or returns a false value.
  
  =item C<Prev>
  
  C<Prev($N)> is almost identical to C<Next(-$N)>; it moves to the $Nth
  previous hunk.  On a 'reset' object, C<Prev()> [and C<Next(-1)>] move
  to the last hunk.
  
  The position returned by C<Prev> is relative to the I<end> of the
  hunks; -1 for the last hunk, -2 for the second-to-last, etc.
  
  =item C<Reset>
  
      $diff->Reset();     # Reset the object's position
      $diff->Reset($pos); # Move to the specified hunk
      $diff->Reset(1);    # Move to the first hunk
      $diff->Reset(-1);   # Move to the last hunk
  
  C<Reset> returns the object, so, for example, you could use
  C<< $diff->Reset()->Next(-1) >> to get the number of hunks.
  
  =item C<Copy>
  
      $copy = $diff->Copy( $newPos, $newBase );
  
  C<Copy> returns a copy of the object.  The copy and the original object
  share most of their data, so making copies takes very little memory.
  The copy maintains its own position (separate from the original), which
  is the main purpose of copies.  It also maintains its own base.
  
  By default, the copy's position starts out the same as the original
  object's position.  But C<Copy> takes an optional first argument to set the
  new position, so the following three snippets are equivalent:
  
      $copy = $diff->Copy($pos);
  
      $copy = $diff->Copy();
      $copy->Reset($pos);
  
      $copy = $diff->Copy()->Reset($pos);
  
  C<Copy> takes an optional second argument to set the base for
  the copy.  If you wish to change the base of the copy but leave
  the position the same as in the original, here are two
  equivalent ways:
  
      $copy = $diff->Copy();
      $copy->Base( 0 );
  
      $copy = $diff->Copy(undef,0);
  
  Here are two equivalent way to get a "reset" copy:
  
      $copy = $diff->Copy(0);
  
      $copy = $diff->Copy()->Reset();
  
  =item C<Diff>
  
      $bits = $obj->Diff();
  
  C<Diff> returns a true value iff the current hunk contains items that are
  different between the two sequences.  It actually returns one of the
  follow 4 values:
  
  =over 4
  
  =item 3
  
  C<3==(1|2)>.  This hunk contains items from @seq1 and the items
  from @seq2 that should replace them.  Both sequence 1 and 2
  contain changed items so both the 1 and 2 bits are set.
  
  =item 2
  
  This hunk only contains items from @seq2 that should be inserted (not
  items from @seq1).  Only sequence 2 contains changed items so only the 2
  bit is set.
  
  =item 1
  
  This hunk only contains items from @seq1 that should be deleted (not
  items from @seq2).  Only sequence 1 contains changed items so only the 1
  bit is set.
  
  =item 0
  
  This means that the items in this hunk are the same in both sequences.
  Neither sequence 1 nor 2 contain changed items so neither the 1 nor the
  2 bits are set.
  
  =back
  
  =item C<Same>
  
  C<Same> returns a true value iff the current hunk contains items that
  are the same in both sequences.  It actually returns the list of items
  if they are the same or an empty list if they aren't.  In a scalar
  context, it returns the size of the list.
  
  =item C<Items>
  
      $count = $diff->Items(2);
      @items = $diff->Items($seqNum);
  
  C<Items> returns the (number of) items from the specified sequence that
  are part of the current hunk.
  
  If the current hunk contains only insertions, then
  C<< $diff->Items(1) >> will return an empty list (0 in a scalar context).
  If the current hunk contains only deletions, then C<< $diff->Items(2) >>
  will return an empty list (0 in a scalar context).
  
  If the hunk contains replacements, then both C<< $diff->Items(1) >> and
  C<< $diff->Items(2) >> will return different, non-empty lists.
  
  Otherwise, the hunk contains identical items and all of the following
  will return the same lists:
  
      @items = $diff->Items(1);
      @items = $diff->Items(2);
      @items = $diff->Same();
  
  =item C<Range>
  
      $count = $diff->Range( $seqNum );
      @indices = $diff->Range( $seqNum );
      @indices = $diff->Range( $seqNum, $base );
  
  C<Range> is like C<Items> except that it returns a list of I<indices> to
  the items rather than the items themselves.  By default, the index of
  the first item (in each sequence) is 0 but this can be changed by
  calling the C<Base> method.  So, by default, the following two snippets
  return the same lists:
  
      @list = $diff->Items(2);
      @list = @seq2[ $diff->Range(2) ];
  
  You can also specify the base to use as the second argument.  So the
  following two snippets I<always> return the same lists:
  
      @list = $diff->Items(1);
      @list = @seq1[ $diff->Range(1,0) ];
  
  =item C<Base>
  
      $curBase = $diff->Base();
      $oldBase = $diff->Base($newBase);
  
  C<Base> sets and/or returns the current base (usually 0 or 1) that is
  used when you request range information.  The base defaults to 0 so
  that range information is returned as array indices.  You can set the
  base to 1 if you want to report traditional line numbers instead.
  
  =item C<Min>
  
      $min1 = $diff->Min(1);
      $min = $diff->Min( $seqNum, $base );
  
  C<Min> returns the first value that C<Range> would return (given the
  same arguments) or returns C<undef> if C<Range> would return an empty
  list.
  
  =item C<Max>
  
  C<Max> returns the last value that C<Range> would return or C<undef>.
  
  =item C<Get>
  
      ( $n, $x, $r ) = $diff->Get(qw( min1 max1 range1 ));
      @values = $diff->Get(qw( 0min2 1max2 range2 same base ));
  
  C<Get> returns one or more scalar values.  You pass in a list of the
  names of the values you want returned.  Each name must match one of the
  following regexes:
  
      /^(-?\d+)?(min|max)[12]$/i
      /^(range[12]|same|diff|base)$/i
  
  The 1 or 2 after a name says which sequence you want the information
  for (and where allowed, it is required).  The optional number before
  "min" or "max" is the base to use.  So the following equalities hold:
  
      $diff->Get('min1') == $diff->Min(1)
      $diff->Get('0min2') == $diff->Min(2,0)
  
  Using C<Get> in a scalar context when you've passed in more than one
  name is a fatal error (C<die> is called).
  
  =back
  
  =head2 C<prepare>
  
  Given a reference to a list of items, C<prepare> returns a reference
  to a hash which can be used when comparing this sequence to other
  sequences with C<LCS> or C<LCS_length>.
  
      $prep = prepare( \@seq1 );
      for $i ( 0 .. 10_000 )
      {
          @lcs = LCS( $prep, $seq[$i] );
          # do something useful with @lcs
      }
  
  C<prepare> may be passed an optional third parameter; this is a CODE
  reference to a key generation function.  See L</KEY GENERATION
  FUNCTIONS>.
  
      $prep = prepare( \@seq1, \&keyGen );
      for $i ( 0 .. 10_000 )
      {
          @lcs = LCS( $seq[$i], $prep, \&keyGen );
          # do something useful with @lcs
      }
  
  Using C<prepare> provides a performance gain of about 50% when calling LCS
  many times compared with not preparing.
  
  =head2 C<diff>
  
      @diffs     = diff( \@seq1, \@seq2 );
      $diffs_ref = diff( \@seq1, \@seq2 );
  
  C<diff> computes the smallest set of additions and deletions necessary
  to turn the first sequence into the second, and returns a description
  of these changes.  The description is a list of I<hunks>; each hunk
  represents a contiguous section of items which should be added,
  deleted, or replaced.  (Hunks containing unchanged items are not
  included.)
  
  The return value of C<diff> is a list of hunks, or, in scalar context, a
  reference to such a list.  If there are no differences, the list will be
  empty.
  
  Here is an example.  Calling C<diff> for the following two sequences:
  
      a b c e h j l m n p
      b c d e f j k l m r s t
  
  would produce the following list:
  
      (
        [ [ '-', 0, 'a' ] ],
  
        [ [ '+', 2, 'd' ] ],
  
        [ [ '-', 4, 'h' ],
          [ '+', 4, 'f' ] ],
  
        [ [ '+', 6, 'k' ] ],
  
        [ [ '-',  8, 'n' ],
          [ '-',  9, 'p' ],
          [ '+',  9, 'r' ],
          [ '+', 10, 's' ],
          [ '+', 11, 't' ] ],
      )
  
  There are five hunks here.  The first hunk says that the C<a> at
  position 0 of the first sequence should be deleted (C<->).  The second
  hunk says that the C<d> at position 2 of the second sequence should
  be inserted (C<+>).  The third hunk says that the C<h> at position 4
  of the first sequence should be removed and replaced with the C<f>
  from position 4 of the second sequence.  And so on.
  
  C<diff> may be passed an optional third parameter; this is a CODE
  reference to a key generation function.  See L</KEY GENERATION
  FUNCTIONS>.
  
  Additional parameters, if any, will be passed to the key generation
  routine.
  
  =head2 C<sdiff>
  
      @sdiffs     = sdiff( \@seq1, \@seq2 );
      $sdiffs_ref = sdiff( \@seq1, \@seq2 );
  
  C<sdiff> computes all necessary components to show two sequences
  and their minimized differences side by side, just like the
  Unix-utility I<sdiff> does:
  
      same             same
      before     |     after
      old        <     -
      -          >     new
  
  It returns a list of array refs, each pointing to an array of
  display instructions. In scalar context it returns a reference
  to such a list. If there are no differences, the list will have one
  entry per item, each indicating that the item was unchanged.
  
  Display instructions consist of three elements: A modifier indicator
  (C<+>: Element added, C<->: Element removed, C<u>: Element unmodified,
  C<c>: Element changed) and the value of the old and new elements, to
  be displayed side-by-side.
  
  An C<sdiff> of the following two sequences:
  
      a b c e h j l m n p
      b c d e f j k l m r s t
  
  results in
  
      ( [ '-', 'a', ''  ],
        [ 'u', 'b', 'b' ],
        [ 'u', 'c', 'c' ],
        [ '+', '',  'd' ],
        [ 'u', 'e', 'e' ],
        [ 'c', 'h', 'f' ],
        [ 'u', 'j', 'j' ],
        [ '+', '',  'k' ],
        [ 'u', 'l', 'l' ],
        [ 'u', 'm', 'm' ],
        [ 'c', 'n', 'r' ],
        [ 'c', 'p', 's' ],
        [ '+', '',  't' ],
      )
  
  C<sdiff> may be passed an optional third parameter; this is a CODE
  reference to a key generation function.  See L</KEY GENERATION
  FUNCTIONS>.
  
  Additional parameters, if any, will be passed to the key generation
  routine.
  
  =head2 C<compact_diff>
  
  C<compact_diff> is much like C<sdiff> except it returns a much more
  compact description consisting of just one flat list of indices.  An
  example helps explain the format:
  
      my @a = qw( a b c   e  h j   l m n p      );
      my @b = qw(   b c d e f  j k l m    r s t );
      @cdiff = compact_diff( \@a, \@b );
      # Returns:
      #   @a      @b       @a       @b
      #  start   start   values   values
      (    0,      0,   #       =
           0,      0,   #    a  !
           1,      0,   #  b c  =  b c
           3,      2,   #       !  d
           3,      3,   #    e  =  e
           4,      4,   #    f  !  h
           5,      5,   #    j  =  j
           6,      6,   #       !  k
           6,      7,   #  l m  =  l m
           8,      9,   #  n p  !  r s t
          10,     12,   #
      );
  
  The 0th, 2nd, 4th, etc. entries are all indices into @seq1 (@a in the
  above example) indicating where a hunk begins.  The 1st, 3rd, 5th, etc.
  entries are all indices into @seq2 (@b in the above example) indicating
  where the same hunk begins.
  
  So each pair of indices (except the last pair) describes where a hunk
  begins (in each sequence).  Since each hunk must end at the item just
  before the item that starts the next hunk, the next pair of indices can
  be used to determine where the hunk ends.
  
  So, the first 4 entries (0..3) describe the first hunk.  Entries 0 and 1
  describe where the first hunk begins (and so are always both 0).
  Entries 2 and 3 describe where the next hunk begins, so subtracting 1
  from each tells us where the first hunk ends.  That is, the first hunk
  contains items C<$diff[0]> through C<$diff[2] - 1> of the first sequence
  and contains items C<$diff[1]> through C<$diff[3] - 1> of the second
  sequence.
  
  In other words, the first hunk consists of the following two lists of items:
  
                 #  1st pair     2nd pair
                 # of indices   of indices
      @list1 = @a[ $cdiff[0] .. $cdiff[2]-1 ];
      @list2 = @b[ $cdiff[1] .. $cdiff[3]-1 ];
                 # Hunk start   Hunk end
  
  Note that the hunks will always alternate between those that are part of
  the LCS (those that contain unchanged items) and those that contain
  changes.  This means that all we need to be told is whether the first
  hunk is a 'same' or 'diff' hunk and we can determine which of the other
  hunks contain 'same' items or 'diff' items.
  
  By convention, we always make the first hunk contain unchanged items.
  So the 1st, 3rd, 5th, etc. hunks (all odd-numbered hunks if you start
  counting from 1) all contain unchanged items.  And the 2nd, 4th, 6th,
  etc. hunks (all even-numbered hunks if you start counting from 1) all
  contain changed items.
  
  Since @a and @b don't begin with the same value, the first hunk in our
  example is empty (otherwise we'd violate the above convention).  Note
  that the first 4 index values in our example are all zero.  Plug these
  values into our previous code block and we get:
  
      @hunk1a = @a[ 0 .. 0-1 ];
      @hunk1b = @b[ 0 .. 0-1 ];
  
  And C<0..-1> returns the empty list.
  
  Move down one pair of indices (2..5) and we get the offset ranges for
  the second hunk, which contains changed items.
  
  Since C<@diff[2..5]> contains (0,0,1,0) in our example, the second hunk
  consists of these two lists of items:
  
          @hunk2a = @a[ $cdiff[2] .. $cdiff[4]-1 ];
          @hunk2b = @b[ $cdiff[3] .. $cdiff[5]-1 ];
      # or
          @hunk2a = @a[ 0 .. 1-1 ];
          @hunk2b = @b[ 0 .. 0-1 ];
      # or
          @hunk2a = @a[ 0 .. 0 ];
          @hunk2b = @b[ 0 .. -1 ];
      # or
          @hunk2a = ( 'a' );
          @hunk2b = ( );
  
  That is, we would delete item 0 ('a') from @a.
  
  Since C<@diff[4..7]> contains (1,0,3,2) in our example, the third hunk
  consists of these two lists of items:
  
          @hunk3a = @a[ $cdiff[4] .. $cdiff[6]-1 ];
          @hunk3a = @b[ $cdiff[5] .. $cdiff[7]-1 ];
      # or
          @hunk3a = @a[ 1 .. 3-1 ];
          @hunk3a = @b[ 0 .. 2-1 ];
      # or
          @hunk3a = @a[ 1 .. 2 ];
          @hunk3a = @b[ 0 .. 1 ];
      # or
          @hunk3a = qw( b c );
          @hunk3a = qw( b c );
  
  Note that this third hunk contains unchanged items as our convention demands.
  
  You can continue this process until you reach the last two indices,
  which will always be the number of items in each sequence.  This is
  required so that subtracting one from each will give you the indices to
  the last items in each sequence.
  
  =head2 C<traverse_sequences>
  
  C<traverse_sequences> used to be the most general facility provided by
  this module (the new OO interface is more powerful and much easier to
  use).
  
  Imagine that there are two arrows.  Arrow A points to an element of
  sequence A, and arrow B points to an element of the sequence B. 
  Initially, the arrows point to the first elements of the respective
  sequences.  C<traverse_sequences> will advance the arrows through the
  sequences one element at a time, calling an appropriate user-specified
  callback function before each advance.  It will advance the arrows in
  such a way that if there are equal elements C<$A[$i]> and C<$B[$j]>
  which are equal and which are part of the LCS, there will be some moment
  during the execution of C<traverse_sequences> when arrow A is pointing
  to C<$A[$i]> and arrow B is pointing to C<$B[$j]>.  When this happens,
  C<traverse_sequences> will call the C<MATCH> callback function and then
  it will advance both arrows.
  
  Otherwise, one of the arrows is pointing to an element of its sequence
  that is not part of the LCS.  C<traverse_sequences> will advance that
  arrow and will call the C<DISCARD_A> or the C<DISCARD_B> callback,
  depending on which arrow it advanced.  If both arrows point to elements
  that are not part of the LCS, then C<traverse_sequences> will advance
  one of them and call the appropriate callback, but it is not specified
  which it will call.
  
  The arguments to C<traverse_sequences> are the two sequences to
  traverse, and a hash which specifies the callback functions, like this:
  
      traverse_sequences(
          \@seq1, \@seq2,
          {   MATCH => $callback_1,
              DISCARD_A => $callback_2,
              DISCARD_B => $callback_3,
          }
      );
  
  Callbacks for MATCH, DISCARD_A, and DISCARD_B are invoked with at least
  the indices of the two arrows as their arguments.  They are not expected
  to return any values.  If a callback is omitted from the table, it is
  not called.
  
  Callbacks for A_FINISHED and B_FINISHED are invoked with at least the
  corresponding index in A or B.
  
  If arrow A reaches the end of its sequence, before arrow B does,
  C<traverse_sequences> will call the C<A_FINISHED> callback when it
  advances arrow B, if there is such a function; if not it will call
  C<DISCARD_B> instead.  Similarly if arrow B finishes first. 
  C<traverse_sequences> returns when both arrows are at the ends of their
  respective sequences.  It returns true on success and false on failure. 
  At present there is no way to fail.
  
  C<traverse_sequences> may be passed an optional fourth parameter; this
  is a CODE reference to a key generation function.  See L</KEY GENERATION
  FUNCTIONS>.
  
  Additional parameters, if any, will be passed to the key generation function.
  
  If you want to pass additional parameters to your callbacks, but don't
  need a custom key generation function, you can get the default by
  passing undef:
  
      traverse_sequences(
          \@seq1, \@seq2,
          {   MATCH => $callback_1,
              DISCARD_A => $callback_2,
              DISCARD_B => $callback_3,
          },
          undef,     # default key-gen
          $myArgument1,
          $myArgument2,
          $myArgument3,
      );
  
  C<traverse_sequences> does not have a useful return value; you are
  expected to plug in the appropriate behavior with the callback
  functions.
  
  =head2 C<traverse_balanced>
  
  C<traverse_balanced> is an alternative to C<traverse_sequences>. It
  uses a different algorithm to iterate through the entries in the
  computed LCS. Instead of sticking to one side and showing element changes
  as insertions and deletions only, it will jump back and forth between
  the two sequences and report I<changes> occurring as deletions on one
  side followed immediately by an insertion on the other side.
  
  In addition to the C<DISCARD_A>, C<DISCARD_B>, and C<MATCH> callbacks
  supported by C<traverse_sequences>, C<traverse_balanced> supports
  a C<CHANGE> callback indicating that one element got C<replaced> by another:
  
      traverse_balanced(
          \@seq1, \@seq2,
          {   MATCH => $callback_1,
              DISCARD_A => $callback_2,
              DISCARD_B => $callback_3,
              CHANGE    => $callback_4,
          }
      );
  
  If no C<CHANGE> callback is specified, C<traverse_balanced>
  will map C<CHANGE> events to C<DISCARD_A> and C<DISCARD_B> actions,
  therefore resulting in a similar behaviour as C<traverse_sequences>
  with different order of events.
  
  C<traverse_balanced> might be a bit slower than C<traverse_sequences>,
  noticeable only while processing huge amounts of data.
  
  The C<sdiff> function of this module 
  is implemented as call to C<traverse_balanced>.
  
  C<traverse_balanced> does not have a useful return value; you are expected to
  plug in the appropriate behavior with the callback functions.
  
  =head1 KEY GENERATION FUNCTIONS
  
  Most of the functions accept an optional extra parameter.  This is a
  CODE reference to a key generating (hashing) function that should return
  a string that uniquely identifies a given element.  It should be the
  case that if two elements are to be considered equal, their keys should
  be the same (and the other way around).  If no key generation function
  is provided, the key will be the element as a string.
  
  By default, comparisons will use "eq" and elements will be turned into keys
  using the default stringizing operator '""'.
  
  Where this is important is when you're comparing something other than
  strings.  If it is the case that you have multiple different objects
  that should be considered to be equal, you should supply a key
  generation function. Otherwise, you have to make sure that your arrays
  contain unique references.
  
  For instance, consider this example:
  
      package Person;
  
      sub new
      {
          my $package = shift;
          return bless { name => '', ssn => '', @_ }, $package;
      }
  
      sub clone
      {
          my $old = shift;
          my $new = bless { %$old }, ref($old);
      }
  
      sub hash
      {
          return shift()->{'ssn'};
      }
  
      my $person1 = Person->new( name => 'Joe', ssn => '123-45-6789' );
      my $person2 = Person->new( name => 'Mary', ssn => '123-47-0000' );
      my $person3 = Person->new( name => 'Pete', ssn => '999-45-2222' );
      my $person4 = Person->new( name => 'Peggy', ssn => '123-45-9999' );
      my $person5 = Person->new( name => 'Frank', ssn => '000-45-9999' );
  
  If you did this:
  
      my $array1 = [ $person1, $person2, $person4 ];
      my $array2 = [ $person1, $person3, $person4, $person5 ];
      Algorithm::Diff::diff( $array1, $array2 );
  
  everything would work out OK (each of the objects would be converted
  into a string like "Person=HASH(0x82425b0)" for comparison).
  
  But if you did this:
  
      my $array1 = [ $person1, $person2, $person4 ];
      my $array2 = [ $person1, $person3, $person4->clone(), $person5 ];
      Algorithm::Diff::diff( $array1, $array2 );
  
  $person4 and $person4->clone() (which have the same name and SSN)
  would be seen as different objects. If you wanted them to be considered
  equivalent, you would have to pass in a key generation function:
  
      my $array1 = [ $person1, $person2, $person4 ];
      my $array2 = [ $person1, $person3, $person4->clone(), $person5 ];
      Algorithm::Diff::diff( $array1, $array2, \&Person::hash );
  
  This would use the 'ssn' field in each Person as a comparison key, and
  so would consider $person4 and $person4->clone() as equal.
  
  You may also pass additional parameters to the key generation function
  if you wish.
  
  =head1 ERROR CHECKING
  
  If you pass these routines a non-reference and they expect a reference,
  they will die with a message.
  
  =head1 AUTHOR
  
  This version released by Tye McQueen (http://perlmonks.org/?node=tye).
  
  =head1 LICENSE
  
  Parts Copyright (c) 2000-2004 Ned Konz.  All rights reserved.
  Parts by Tye McQueen.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl.
  
  =head1 MAILING LIST
  
  Mark-Jason still maintains a mailing list.  To join a low-volume mailing
  list for announcements related to diff and Algorithm::Diff, send an
  empty mail message to mjd-perl-diff-request@plover.com.
  
  =head1 CREDITS
  
  Versions through 0.59 (and much of this documentation) were written by:
  
  Mark-Jason Dominus, mjd-perl-diff@plover.com
  
  This version borrows some documentation and routine names from
  Mark-Jason's, but Diff.pm's code was completely replaced.
  
  This code was adapted from the Smalltalk code of Mario Wolczko
  <mario@wolczko.com>, which is available at
  ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st
  
  C<sdiff> and C<traverse_balanced> were written by Mike Schilli
  <m@perlmeister.com>.
  
  The algorithm is that described in
  I<A Fast Algorithm for Computing Longest Common Subsequences>,
  CACM, vol.20, no.5, pp.350-353, May 1977, with a few
  minor improvements to improve the speed.
  
  Much work was done by Ned Konz (perl@bike-nomad.com).
  
  The OO interface and some other changes are by Tye McQueen.
  
  =cut
ALGORITHM_DIFF

$fatpacked{"Algorithm/DiffOld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFFOLD';
  # This is a version of Algorithm::Diff that uses only a comparison function,
  # like versions <= 0.59 used to.
  # $Revision: 1.3 $
  
  package # don't index
      Algorithm::DiffOld;
  use strict;
  use vars qw($VERSION @EXPORT_OK @ISA @EXPORT);
  use integer;		# see below in _replaceNextLargerWith() for mod to make
  					# if you don't use this
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw();
  @EXPORT_OK = qw(LCS diff traverse_sequences);
  $VERSION = 1.10;	# manually tracking Algorithm::Diff
  
  # McIlroy-Hunt diff algorithm
  # Adapted from the Smalltalk code of Mario I. Wolczko, <mario@wolczko.com>
  # by Ned Konz, perl@bike-nomad.com
  
  =head1 NAME
  
  Algorithm::DiffOld - Compute `intelligent' differences between two files / lists
  but use the old (<=0.59) interface.
  
  =head1 NOTE
  
  This has been provided as part of the Algorithm::Diff package by Ned Konz.
  This particular module is B<ONLY> for people who B<HAVE> to have the old
  interface, which uses a comparison function rather than a key generating
  function.
  
  Because each of the lines in one array have to be compared with each 
  of the lines in the other array, this does M*N comparisons. This can
  be very slow. I clocked it at taking 18 times as long as the stock
  version of Algorithm::Diff for a 4000-line file. It will get worse
  quadratically as array sizes increase.
  
  =head1 SYNOPSIS
  
    use Algorithm::DiffOld qw(diff LCS traverse_sequences);
  
    @lcs    = LCS( \@seq1, \@seq2, $comparison_function );
  
    $lcsref = LCS( \@seq1, \@seq2, $comparison_function );
  
    @diffs = diff( \@seq1, \@seq2, $comparison_function );
    
    traverse_sequences( \@seq1, \@seq2,
                       { MATCH => $callback,
                         DISCARD_A => $callback,
                         DISCARD_B => $callback,
                       },
                       $comparison_function );
  
  =head1 COMPARISON FUNCTIONS
  
  Each of the main routines should be passed a comparison function. If you
  aren't passing one in, B<use Algorithm::Diff instead>.
  
  These functions should return a true value when two items should compare
  as equal.
  
  For instance,
  
    @lcs    = LCS( \@seq1, \@seq2, sub { my ($a, $b) = @_; $a eq $b } );
  
  but if that is all you're doing with your comparison function, just use
  Algorithm::Diff and let it do this (this is its default).
  
  Or:
  
    sub someFunkyComparisonFunction
    {
    	my ($a, $b) = @_;
  	$a =~ m{$b};
    }
  
    @diffs = diff( \@lines, \@patterns, \&someFunkyComparisonFunction );
  
  which would allow you to diff an array @lines which consists of text
  lines with an array @patterns which consists of regular expressions.
  
  This is actually the reason I wrote this version -- there is no way
  to do this with a key generation function as in the stock Algorithm::Diff.
  
  =cut
  
  # Find the place at which aValue would normally be inserted into the array. If
  # that place is already occupied by aValue, do nothing, and return undef. If
  # the place does not exist (i.e., it is off the end of the array), add it to
  # the end, otherwise replace the element at that point with aValue.
  # It is assumed that the array's values are numeric.
  # This is where the bulk (75%) of the time is spent in this module, so try to
  # make it fast!
  
  sub _replaceNextLargerWith
  {
  	my ( $array, $aValue, $high ) = @_;
  	$high ||= $#$array;
  
  	# off the end?
  	if ( $high == -1  || $aValue > $array->[ -1 ] )
  	{
  		push( @$array, $aValue );
  		return $high + 1;
  	}
  
  	# binary search for insertion point...
  	my $low = 0;
  	my $index;
  	my $found;
  	while ( $low <= $high )
  	{
  		$index = ( $high + $low ) / 2;
  #		$index = int(( $high + $low ) / 2);		# without 'use integer'
  		$found = $array->[ $index ];
  
  		if ( $aValue == $found )
  		{
  			return undef;
  		}
  		elsif ( $aValue > $found )
  		{
  			$low = $index + 1;
  		}
  		else
  		{
  			$high = $index - 1;
  		}
  	}
  
  	# now insertion point is in $low.
  	$array->[ $low ] = $aValue;		# overwrite next larger
  	return $low;
  }
  
  # This method computes the longest common subsequence in $a and $b.
  
  # Result is array or ref, whose contents is such that
  # 	$a->[ $i ] == $b->[ $result[ $i ] ]
  # foreach $i in ( 0 .. $#result ) if $result[ $i ] is defined.
  
  # An additional argument may be passed; this is a CODE ref to a comparison
  # routine. By default, comparisons will use "eq" .
  # Note that this routine will be called as many as M*N times, so make it fast!
  
  # Additional parameters, if any, will be passed to the key generation routine.
  
  sub _longestCommonSubsequence
  {
  	my $a = shift;	# array ref
  	my $b = shift;	# array ref
  	my $compare = shift || sub { my $a = shift; my $b = shift; $a eq $b };
  
  	my $aStart = 0;
  	my $aFinish = $#$a;
  	my $bStart = 0;
  	my $bFinish = $#$b;
  	my $matchVector = [];
  
  	# First we prune off any common elements at the beginning
  	while ( $aStart <= $aFinish
  		and $bStart <= $bFinish
  		and &$compare( $a->[ $aStart ], $b->[ $bStart ], @_ ) )
  	{
  		$matchVector->[ $aStart++ ] = $bStart++;
  	}
  
  	# now the end
  	while ( $aStart <= $aFinish
  		and $bStart <= $bFinish
  		and &$compare( $a->[ $aFinish ], $b->[ $bFinish ], @_ ) )
  	{
  		$matchVector->[ $aFinish-- ] = $bFinish--;
  	}
  
  	my $thresh = [];
  	my $links = [];
  
  	my ( $i, $ai, $j, $k );
  	for ( $i = $aStart; $i <= $aFinish; $i++ )
  	{
  		$k = 0;
  		# look for each element of @b between $bStart and $bFinish
  		# that matches $a->[ $i ], in reverse order
  		for ($j = $bFinish; $j >= $bStart; $j--)
  		{
  			next if ! &$compare( $a->[$i], $b->[$j], @_ );
  			# optimization: most of the time this will be true
  			if ( $k
  				and $thresh->[ $k ] > $j
  				and $thresh->[ $k - 1 ] < $j )
  			{
  				$thresh->[ $k ] = $j;
  			}
  			else
  			{
  				$k = _replaceNextLargerWith( $thresh, $j, $k );
  			}
  
  			# oddly, it's faster to always test this (CPU cache?).
  			if ( defined( $k ) )
  			{
  				$links->[ $k ] = 
  					[ ( $k ? $links->[ $k - 1 ] : undef ), $i, $j ];
  			}
  		}
  	}
  
  	if ( @$thresh )
  	{
  		for ( my $link = $links->[ $#$thresh ]; $link; $link = $link->[ 0 ] )
  		{
  			$matchVector->[ $link->[ 1 ] ] = $link->[ 2 ];
  		}
  	}
  
  	return wantarray ? @$matchVector : $matchVector;
  }
  
  sub traverse_sequences
  {
  	my $a = shift;	# array ref
  	my $b = shift;	# array ref
  	my $callbacks = shift || { };
  	my $compare = shift;
  	my $matchCallback = $callbacks->{'MATCH'} || sub { };
  	my $discardACallback = $callbacks->{'DISCARD_A'} || sub { };
  	my $finishedACallback = $callbacks->{'A_FINISHED'};
  	my $discardBCallback = $callbacks->{'DISCARD_B'} || sub { };
  	my $finishedBCallback = $callbacks->{'B_FINISHED'};
  	my $matchVector = _longestCommonSubsequence( $a, $b, $compare, @_ );
  	# Process all the lines in match vector
  	my $lastA = $#$a;
  	my $lastB = $#$b;
  	my $bi = 0;
  	my $ai;
  	for ( $ai = 0; $ai <= $#$matchVector; $ai++ )
  	{
  		my $bLine = $matchVector->[ $ai ];
  		if ( defined( $bLine ) )	# matched
  		{
  			&$discardBCallback( $ai, $bi++, @_ ) while $bi < $bLine;
  			&$matchCallback( $ai, $bi++, @_ );
  		}
  		else
  		{
  			&$discardACallback( $ai, $bi, @_ );
  		}
  	}
  	# the last entry (if any) processed was a match.
  
  	if ( defined( $finishedBCallback ) && $ai <= $lastA )
  	{
  		&$finishedBCallback( $bi, @_ );
  	}
  	else
  	{
  		&$discardACallback( $ai++, $bi, @_ ) while ( $ai <= $lastA );
  	}
  
  	if ( defined( $finishedACallback ) && $bi <= $lastB )
  	{
  		&$finishedACallback( $ai, @_ );
  	}
  	else
  	{
  		&$discardBCallback( $ai, $bi++, @_ ) while ( $bi <= $lastB );
  	}
  	return 1;
  }
  
  sub LCS
  {
  	my $a = shift;	# array ref
  	my $matchVector = _longestCommonSubsequence( $a, @_ );
  	my @retval;
  	my $i;
  	for ( $i = 0; $i <= $#$matchVector; $i++ )
  	{
  		if ( defined( $matchVector->[ $i ] ) )
  		{
  			push( @retval, $a->[ $i ] );
  		}
  	}
  	return wantarray ? @retval : \@retval;
  }
  
  sub diff
  {
  	my $a = shift;	# array ref
  	my $b = shift;	# array ref
  	my $retval = [];
  	my $hunk = [];
  	my $discard = sub { push( @$hunk, [ '-', $_[ 0 ], $a->[ $_[ 0 ] ] ] ) };
  	my $add = sub { push( @$hunk, [ '+', $_[ 1 ], $b->[ $_[ 1 ] ] ] ) };
  	my $match = sub { push( @$retval, $hunk ) if scalar(@$hunk); $hunk = [] };
  	traverse_sequences( $a, $b,
  		{ MATCH => $match, DISCARD_A => $discard, DISCARD_B => $add },
  		@_ );
  	&$match();
  	return wantarray ? @$retval : $retval;
  }
  
  1;
ALGORITHM_DIFFOLD

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;
  use strict;
  no strict 'refs';
  use warnings;
  
  package Class::Tiny;
  # ABSTRACT: Minimalist class construction
  
  our $VERSION = '1.006';
  
  use Carp ();
  
  # load as .pm to hide from min version scanners
  require( $] >= 5.010 ? "mro.pm" : "MRO/Compat.pm" ); ## no critic:
  
  my %CLASS_ATTRIBUTES;
  
  sub import {
      my $class = shift;
      my $pkg   = caller;
      $class->prepare_class($pkg);
      $class->create_attributes( $pkg, @_ ) if @_;
  }
  
  sub prepare_class {
      my ( $class, $pkg ) = @_;
      @{"${pkg}::ISA"} = "Class::Tiny::Object" unless @{"${pkg}::ISA"};
  }
  
  # adapted from Object::Tiny and Object::Tiny::RW
  sub create_attributes {
      my ( $class, $pkg, @spec ) = @_;
      my %defaults = map { ref $_ eq 'HASH' ? %$_ : ( $_ => undef ) } @spec;
      my @attr = grep {
          defined and !ref and /^[^\W\d]\w*$/s
            or Carp::croak "Invalid accessor name '$_'"
      } keys %defaults;
      $CLASS_ATTRIBUTES{$pkg}{$_} = $defaults{$_} for @attr;
      $class->_gen_accessor( $pkg, $_ ) for grep { !*{"$pkg\::$_"}{CODE} } @attr;
      Carp::croak("Failed to generate attributes for $pkg: $@\n") if $@;
  }
  
  sub _gen_accessor {
      my ( $class, $pkg, $name ) = @_;
      my $outer_default = $CLASS_ATTRIBUTES{$pkg}{$name};
  
      my $sub =
        $class->__gen_sub_body( $name, defined($outer_default), ref($outer_default) );
  
      # default = outer_default avoids "won't stay shared" bug
      eval "package $pkg; my \$default=\$outer_default; $sub"; ## no critic
      Carp::croak("Failed to generate attributes for $pkg: $@\n") if $@;
  }
  
  # NOTE: overriding __gen_sub_body in a subclass of Class::Tiny is risky and
  # could break if the internals of Class::Tiny need to change for any
  # reason.  That said, I currently see no reason why this would be likely to
  # change.
  #
  # The generated sub body should assume that a '$default' variable will be
  # in scope (i.e. when the sub is evaluated) with any default value/coderef
  sub __gen_sub_body {
      my ( $self, $name, $has_default, $default_type ) = @_;
  
      if ( $has_default && $default_type eq 'CODE' ) {
          return << "HERE";
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
      }
      elsif ($has_default) {
          return << "HERE";
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
      }
      else {
          return << "HERE";
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
      }
  }
  
  sub get_all_attributes_for {
      my ( $class, $pkg ) = @_;
      my %attr =
        map { $_ => undef }
        map { keys %{ $CLASS_ATTRIBUTES{$_} || {} } } @{ mro::get_linear_isa($pkg) };
      return keys %attr;
  }
  
  sub get_all_attribute_defaults_for {
      my ( $class, $pkg ) = @_;
      my $defaults = {};
      for my $p ( reverse @{ mro::get_linear_isa($pkg) } ) {
          while ( my ( $k, $v ) = each %{ $CLASS_ATTRIBUTES{$p} || {} } ) {
              $defaults->{$k} = $v;
          }
      }
      return $defaults;
  }
  
  package Class::Tiny::Object;
  # ABSTRACT: Base class for classes built with Class::Tiny
  
  our $VERSION = '1.006';
  
  my ( %HAS_BUILDARGS, %BUILD_CACHE, %DEMOLISH_CACHE, %ATTR_CACHE );
  
  my $_PRECACHE = sub {
      no warnings 'once'; # needed to avoid downstream warnings
      my ($class) = @_;
      my $linear_isa =
        @{"$class\::ISA"} == 1 && ${"$class\::ISA"}[0] eq "Class::Tiny::Object"
        ? [$class]
        : mro::get_linear_isa($class);
      $DEMOLISH_CACHE{$class} = [
          map { ( *{$_}{CODE} ) ? ( *{$_}{CODE} ) : () }
          map { "$_\::DEMOLISH" } @$linear_isa
      ];
      $BUILD_CACHE{$class} = [
          map { ( *{$_}{CODE} ) ? ( *{$_}{CODE} ) : () }
          map { "$_\::BUILD" } reverse @$linear_isa
      ];
      $HAS_BUILDARGS{$class} = $class->can("BUILDARGS");
      return $ATTR_CACHE{$class} =
        { map { $_ => 1 } Class::Tiny->get_all_attributes_for($class) };
  };
  
  sub new {
      my $class = shift;
      my $valid_attrs = $ATTR_CACHE{$class} || $_PRECACHE->($class);
  
      # handle hash ref or key/value arguments
      my $args;
      if ( $HAS_BUILDARGS{$class} ) {
          $args = $class->BUILDARGS(@_);
      }
      else {
          if ( @_ == 1 && ref $_[0] ) {
              my %copy = eval { %{ $_[0] } }; # try shallow copy
              Carp::croak("Argument to $class->new() could not be dereferenced as a hash") if $@;
              $args = \%copy;
          }
          elsif ( @_ % 2 == 0 ) {
              $args = {@_};
          }
          else {
              Carp::croak("$class->new() got an odd number of elements");
          }
      }
  
      # create object and invoke BUILD (unless we were given __no_BUILD__)
      my $self =
        bless { map { $_ => $args->{$_} } grep { exists $valid_attrs->{$_} } keys %$args },
        $class;
      $self->BUILDALL($args) if !delete $args->{__no_BUILD__} && @{ $BUILD_CACHE{$class} };
  
      return $self;
  }
  
  sub BUILDALL { $_->(@_) for @{ $BUILD_CACHE{ ref $_[0] } } }
  
  # Adapted from Moo and its dependencies
  require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};
  
  sub DESTROY {
      my $self  = shift;
      my $class = ref $self;
      my $in_global_destruction =
        defined ${^GLOBAL_PHASE}
        ? ${^GLOBAL_PHASE} eq 'DESTRUCT'
        : Devel::GlobalDestruction::in_global_destruction();
      for my $demolisher ( @{ $DEMOLISH_CACHE{$class} } ) {
          my $e = do {
              local ( $?, $@ );
              eval { $demolisher->( $self, $in_global_destruction ) };
              $@;
          };
          no warnings 'misc'; # avoid (in cleanup) warnings
          die $e if $e;       # rethrow
      }
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Class::Tiny - Minimalist class construction
  
  =head1 VERSION
  
  version 1.006
  
  =head1 SYNOPSIS
  
  In F<Person.pm>:
  
    package Person;
  
    use Class::Tiny qw( name );
  
    1;
  
  In F<Employee.pm>:
  
    package Employee;
    use parent 'Person';
  
    use Class::Tiny qw( ssn ), {
      timestamp => sub { time }   # attribute with default
    };
  
    1;
  
  In F<example.pl>:
  
    use Employee;
  
    my $obj = Employee->new( name => "Larry", ssn => "111-22-3333" );
  
    # unknown attributes are ignored
    my $obj = Employee->new( name => "Larry", OS => "Linux" );
    # $obj->{OS} does not exist
  
  =head1 DESCRIPTION
  
  This module offers a minimalist class construction kit in around 120 lines of
  code.  Here is a list of features:
  
  =over 4
  
  =item *
  
  defines attributes via import arguments
  
  =item *
  
  generates read-write accessors
  
  =item *
  
  supports lazy attribute defaults
  
  =item *
  
  supports custom accessors
  
  =item *
  
  superclass provides a standard C<new> constructor
  
  =item *
  
  C<new> takes a hash reference or list of key/value pairs
  
  =item *
  
  C<new> supports providing C<BUILDARGS> to customize constructor options
  
  =item *
  
  C<new> calls C<BUILD> for each class from parent to child
  
  =item *
  
  superclass provides a C<DESTROY> method
  
  =item *
  
  C<DESTROY> calls C<DEMOLISH> for each class from child to parent
  
  =back
  
  Multiple-inheritance is possible, with superclass order determined via
  L<mro::get_linear_isa|mro/Functions>.
  
  It uses no non-core modules for any recent Perl. On Perls older than v5.10 it
  requires L<MRO::Compat>. On Perls older than v5.14, it requires
  L<Devel::GlobalDestruction>.
  
  =head1 USAGE
  
  =head2 Defining attributes
  
  Define attributes as a list of import arguments:
  
      package Foo::Bar;
  
      use Class::Tiny qw(
          name
          id
          height
          weight
      );
  
  For each attribute, a read-write accessor is created unless a subroutine of that
  name already exists:
  
      $obj->name;               # getter
      $obj->name( "John Doe" ); # setter
  
  Attribute names must be valid subroutine identifiers or an exception will
  be thrown.
  
  You can specify lazy defaults by defining attributes with a hash reference.
  Keys define attribute names and values are constants or code references that
  will be evaluated when the attribute is first accessed if no value has been
  set.  The object is passed as an argument to a code reference.
  
      package Foo::WithDefaults;
  
      use Class::Tiny qw/name id/, {
          title     => 'Peon',
          skills    => sub { [] },
          hire_date => sub { $_[0]->_build_hire_date },
      };
  
  When subclassing, if multiple accessors of the same name exist in different
  classes, any default (or lack of default) is determined by standard
  method resolution order.
  
  To make your own custom accessors, just pre-declare the method name before
  loading Class::Tiny:
  
      package Foo::Bar;
  
      use subs 'id';
  
      use Class::Tiny qw( name id );
  
      sub id { ... }
  
  Even if you pre-declare a method name, you must include it in the attribute
  list for Class::Tiny to register it as a valid attribute.
  
  If you set a default for a custom accessor, your accessor will need to retrieve
  the default and do something with it:
  
      package Foo::Bar;
  
      use subs 'id';
  
      use Class::Tiny qw( name ), { id => sub { int(rand(2*31)) } };
  
      sub id {
          my $self = shift;
          if (@_) {
              return $self->{id} = shift;
          }
          elsif ( exists $self->{id} ) {
              return $self->{id};
          }
          else {
              my $defaults =
                  Class::Tiny->get_all_attribute_defaults_for( ref $self );
              return $self->{id} = $defaults->{id}->();
          }
      }
  
  =head2 Class::Tiny::Object is your base class
  
  If your class B<does not> already inherit from some class, then
  Class::Tiny::Object will be added to your C<@ISA> to provide C<new> and
  C<DESTROY>.
  
  If your class B<does> inherit from something, then no additional inheritance is
  set up.  If the parent subclasses Class::Tiny::Object, then all is well.  If
  not, then you'll get accessors set up but no constructor or destructor. Don't
  do that unless you really have a special need for it.
  
  Define subclasses as normal.  It's best to define them with L<base>, L<parent>
  or L<superclass> before defining attributes with Class::Tiny so the C<@ISA>
  array is already populated at compile-time:
  
      package Foo::Bar::More;
  
      use parent 'Foo::Bar';
  
      use Class::Tiny qw( shoe_size );
  
  =head2 Object construction
  
  If your class inherits from Class::Tiny::Object (as it should if you followed
  the advice above), it provides the C<new> constructor for you.
  
  Objects can be created with attributes given as a hash reference or as a list
  of key/value pairs:
  
      $obj = Foo::Bar->new( name => "David" );
  
      $obj = Foo::Bar->new( { name => "David" } );
  
  If a reference is passed as a single argument, it must be able to be
  dereferenced as a hash or an exception is thrown.
  
  Unknown attributes in the constructor arguments will be ignored.  Prior to
  version 1.000, unknown attributes were an error, but this made it harder for
  people to cleanly subclass Class::Tiny classes so this feature was removed.
  
  You can define a C<BUILDARGS> method to change how arguments to new are
  handled.  It will receive the constructor arguments as they were provided and
  must return a hash reference of key/value pairs (or else throw an
  exception).
  
      sub BUILDARGS {
         my $class = shift;
         my $name = shift || "John Doe";
         return { name => $name };
       };
  
       Foo::Bar->new( "David" );
       Foo::Bar->new(); # "John Doe"
  
  Unknown attributes returned from C<BUILDARGS> will be ignored.
  
  =head2 BUILD
  
  If your class or any superclass defines a C<BUILD> method, it will be called
  by the constructor from the furthest parent class down to the child class after
  the object has been created.
  
  It is passed the constructor arguments as a hash reference.  The return value
  is ignored.  Use C<BUILD> for validation, checking required attributes or
  setting default values that depend on other attributes.
  
      sub BUILD {
          my ($self, $args) = @_;
  
          for my $req ( qw/name age/ ) {
              croak "$req attribute required" unless defined $self->$req;
          }
  
          croak "Age must be non-negative" if $self->age < 0;
  
          $self->msg( "Hello " . $self->name );
      }
  
  The argument reference is a copy, so deleting elements won't affect data in the
  original (but changes will be passed to other BUILD methods in C<@ISA>).
  
  =head2 DEMOLISH
  
  Class::Tiny provides a C<DESTROY> method.  If your class or any superclass
  defines a C<DEMOLISH> method, they will be called from the child class to the
  furthest parent class during object destruction.  It is provided a single
  boolean argument indicating whether Perl is in global destruction.  Return
  values and errors are ignored.
  
      sub DEMOLISH {
          my ($self, $global_destruct) = @_;
          $self->cleanup();
      }
  
  =head2 Introspection and internals
  
  You can retrieve an unsorted list of valid attributes known to Class::Tiny
  for a class and its superclasses with the C<get_all_attributes_for> class
  method.
  
      my @attrs = Class::Tiny->get_all_attributes_for("Employee");
      # returns qw/name ssn timestamp/
  
  Likewise, a hash reference of all valid attributes and default values (or code
  references) may be retrieved with the C<get_all_attribute_defaults_for> class
  method.  Any attributes without a default will be C<undef>.
  
      my $def = Class::Tiny->get_all_attribute_defaults_for("Employee");
      # returns {
      #   name => undef,
      #   ssn => undef
      #   timestamp => $coderef
      # }
  
  The C<import> method uses two class methods, C<prepare_class> and
  C<create_attributes> to set up the C<@ISA> array and attributes.  Anyone
  attempting to extend Class::Tiny itself should use these instead of mocking up
  a call to C<import>.
  
  When the first object is created, linearized C<@ISA>, the valid attribute list
  and various subroutine references are cached for speed.  Ensure that all
  inheritance and methods are in place before creating objects. (You don't want
  to be changing that once you create objects anyway, right?)
  
  =for Pod::Coverage new get_all_attributes_for get_all_attribute_defaults_for
  prepare_class create_attributes
  
  =head1 RATIONALE
  
  =head2 Why this instead of Object::Tiny or Class::Accessor or something else?
  
  I wanted something so simple that it could potentially be used by core Perl
  modules I help maintain (or hope to write), most of which either use
  L<Class::Struct> or roll-their-own OO framework each time.
  
  L<Object::Tiny> and L<Object::Tiny::RW> were close to what I wanted, but
  lacking some features I deemed necessary, and their maintainers have an even
  more strict philosophy against feature creep than I have.
  
  I also considered L<Class::Accessor>, which has been around a long time and is
  heavily used, but it, too, lacked features I wanted and did things in ways I
  considered poor design.
  
  I looked for something else on CPAN, but after checking a dozen class creators
  I realized I could implement exactly what I wanted faster than I could search
  CPAN for something merely sufficient.
  
  In general, compared to most things on CPAN (other than Object::Tiny),
  Class::Tiny is smaller in implementation and simpler in API.
  
  Specifically, here is how Class::Tiny ("C::T") compares to Object::Tiny
  ("O::T") and Class::Accessor ("C::A"):
  
   FEATURE                            C::T    O::T      C::A
   --------------------------------------------------------------
   attributes defined via import      yes     yes       no
   read/write accessors               yes     no        yes
   lazy attribute defaults            yes     no        no
   provides new                       yes     yes       yes
   provides DESTROY                   yes     no        no
   new takes either hashref or list   yes     no (list) no (hash)
   Moo(se)-like BUILD/DEMOLISH        yes     no        no
   Moo(se)-like BUILDARGS             yes     no        no
   no extraneous methods via @ISA     yes     yes       no
  
  =head2 Why this instead of Moose or Moo?
  
  L<Moose> and L<Moo> are both excellent OO frameworks.  Moose offers a powerful
  meta-object protocol (MOP), but is slow to start up and has about 30 non-core
  dependencies including XS modules.  Moo is faster to start up and has about 10
  pure Perl dependencies but provides no true MOP, relying instead on its ability
  to transparently upgrade Moo to Moose when Moose's full feature set is
  required.
  
  By contrast, Class::Tiny has no MOP and has B<zero> non-core dependencies for
  Perls in the L<support window|perlpolicy>.  It has far less code, less
  complexity and no learning curve. If you don't need or can't afford what Moo or
  Moose offer, this is intended to be a reasonable fallback.
  
  That said, Class::Tiny offers Moose-like conventions for things like C<BUILD>
  and C<DEMOLISH> for some minimal interoperability and an easier upgrade path.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Class-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Class-Tiny>
  
    git clone https://github.com/dagolden/Class-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David Golden Gelu Lupas Karen Etheridge Olivier Mengué Toby Inkster
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Gelu Lupas <gelu@devnull.ro>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CLASS_TINY

$fatpacked{"Const/Fast.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONST_FAST';
  package Const::Fast;
  {
    $Const::Fast::VERSION = '0.014';
  }
  
  use 5.008;
  use strict;
  use warnings FATAL => 'all';
  
  use Scalar::Util qw/reftype blessed/;
  use Carp qw/croak/;
  use Sub::Exporter::Progressive 0.001007 -setup => { exports => [qw/const/], groups => { default => [qw/const/] } };
  
  sub _dclone($) {
  	require Storable;
  	no warnings 'redefine';
  	*_dclone = \&Storable::dclone;
  	goto &Storable::dclone;
  }
  
  ## no critic (RequireArgUnpacking, ProhibitAmpersandSigils)
  # The use of $_[0] is deliberate and essential, to be able to use it as an lvalue and to keep the refcount down.
  
  my %skip = map { $_ => 1 } qw/CODE GLOB/;
  
  sub _make_readonly {
  	my (undef, $dont_clone) = @_;
  	if (my $reftype = reftype $_[0] and not blessed($_[0]) and not &Internals::SvREADONLY($_[0])) {
  		$_[0] = _dclone($_[0]) if !$dont_clone && &Internals::SvREFCNT($_[0]) > 1 && !$skip{$reftype};
  		&Internals::SvREADONLY($_[0], 1);
  		if ($reftype eq 'SCALAR' || $reftype eq 'REF') {
  			_make_readonly(${ $_[0] }, 1);
  		}
  		elsif ($reftype eq 'ARRAY') {
  			_make_readonly($_) for @{ $_[0] };
  		}
  		elsif ($reftype eq 'HASH') {
  			&Internals::hv_clear_placeholders($_[0]);
  			_make_readonly($_) for values %{ $_[0] };
  		}
  	}
  	Internals::SvREADONLY($_[0], 1);
  	return;
  }
  
  ## no critic (ProhibitSubroutinePrototypes, ManyArgs)
  sub const(\[$@%]@) {
  	my (undef, @args) = @_;
  	croak 'Invalid first argument, need an reference' if not defined reftype($_[0]);
  	croak 'Attempt to reassign a readonly variable' if &Internals::SvREADONLY($_[0]);
  	if (reftype $_[0] eq 'SCALAR' or reftype $_[0] eq 'REF') {
  		croak 'No value for readonly variable' if @args == 0;
  		croak 'Too many arguments in readonly assignment' if @args > 1;
  		${ $_[0] } = $args[0];
  	}
  	elsif (reftype $_[0] eq 'ARRAY') {
  		@{ $_[0] } = @args;
  	}
  	elsif (reftype $_[0] eq 'HASH') {
  		croak 'Odd number of elements in hash assignment' if @args % 2;
  		%{ $_[0] } = @args;
  	}
  	else {
  		croak 'Can\'t make variable readonly';
  	}
  	_make_readonly($_[0], 1);
  	return;
  }
  
  1;    # End of Const::Fast
  
  # ABSTRACT: Facility for creating read-only scalars, arrays, and hashes
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Const::Fast - Facility for creating read-only scalars, arrays, and hashes
  
  =head1 VERSION
  
  version 0.014
  
  =head1 SYNOPSIS
  
   use Const::Fast;
  
   const my $foo => 'a scalar value';
   const my @bar => qw/a list value/;
   const my %buz => (a => 'hash', of => 'something');
  
  =head1 SUBROUTINES/METHODS
  
  =head2 const $var, $value
  
  =head2 const @var, @value...
  
  =head2 const %var, %value...
  
  This the only function of this module and it is exported by default. It takes a scalar, array or hash lvalue as first argument, and a list of one or more values depending on the type of the first argument as the value for the variable. It will set the variable to that value and subsequently make it readonly. Arrays and hashes will be made deeply readonly.
  
  Exporting is done using Sub::Exporter::Progressive. You may need to depend on Sub::Exporter explicitly if you need the latter's flexibility.
  
  =head1 RATIONALE
  
  This module was written because I stumbled on some serious issues of L<Readonly> that aren't easily fixable without breaking backwards compatibility in subtle ways. In particular Readonly's use of ties is a source of subtle bugs and bad performance. Instead, this module uses the builtin readonly feature of perl, making access to the variables just as fast as any normal variable without the weird side-effects of ties. Readonly can do the same for scalars when Readonly::XS is installed, but chooses not to do so in the most common case. This may change in the future if someone takes up maintenance of Readonly, and the two modules may be convergence if that happens.
  
  =head1 CAVEATS
  
  Perl doesn't distinguish between restricted hashes and readonly hashes. This means that:
  
   use Const::Fast;
   const my %a => (foo => 1, bar => 2);
   say 1 unless $a{baz}
  
  Will give the error "Attempt to access disallowed key 'baz' in a restricted hash". You have to use C<exists $a{baz}> instead. This is a limitation of perl that can hopefully be solved in the future.
  
  =head1 ACKNOWLEDGEMENTS
  
  The interface for this module was inspired by Eric Roode's L<Readonly>. The implementation is inspired by doing everything the opposite way Readonly does it.
  
  =head1 AUTHOR
  
  Leon Timmermans <fawaka@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CONST_FAST

$fatpacked{"Data/Diver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_DIVER';
  package Data::Diver;
  use strict;
  
  require Exporter;
  use vars qw( $VERSION @EXPORT_OK );
  BEGIN {
      $VERSION= 1.01_01;
      @EXPORT_OK= qw( Dive DiveRef DiveVal DiveError DiveDie DiveClear );
      *import= \&Exporter::import;
      *isa= \&UNIVERSAL::isa;
  }
  
  
  # To figure out if an item supports being treated as a particular
  # type of reference (hash ref, array ref, or scalar ref) we use:
  #   eval { my $x= DEREF_EXPR; 1 }
  # Note that we are careful to not put 'DEREF_EXPR' into an "lvalue
  # context" (to prevent autovivification) and to also avoid trying to
  # convert the value into a number or boolean or such.  The "; 1" is
  # so that the eval always returns a true value unless something die()s.
  
  # Using  'ARRAY' eq ref($ref)  is just a horrid alternative, as it would
  # prevent these routines from being used on blessed data structures.
  
  # Using  UNIVERSAL::isa($ref,'ARRAY')  is a better alternative, but it
  # still fails for more advanced cases of overloading or pathological
  # cases of blessing into very-poorly-named packages.  We use this for
  # testing for CODE references, since  eval { $ref->() }  would actually
  # run the code.
  
  
  my @lastError;
  
  
  sub _Error
  {
      @lastError= @_[2,0,1];
      return;
  }
  
  
  sub DiveError
  {
      return @lastError;
  }
  
  
  sub DiveClear
  {
      @lastError= ();
  }
  
  
  sub DiveDie
  {
      @_= Dive( @_ )   if  1 < @_;
      return  wantarray ? @_ : pop @_
          if  @_  ||  ! @lastError;
      my( $errDesc, $ref, $svKey )= @lastError;
      die "$errDesc using $$svKey on $ref (from Data::Diver).\n";
  }
  
  
  sub Dive
  {
      return   if  ! @_;
      my $ref= shift @_;
      return $ref   if  ! $ref;
      while(  @_  ) {
          my $key= shift @_;
          if(  ! defined $key  ) {
              return  _Error( $ref, \$key, "undef() on non-scalar-ref" )
                  if  ! eval { my $x= $$ref; 1 };
              $ref= $$ref;
          } elsif(    eval { my $x= $key->[0]; 1 }
                  &&  isa( $ref, 'CODE' )
          ) {
              if(  @_  &&  ! defined $_[0]  ) {
                  $ref= \ $ref->( @$key );
              } else {
                  $ref= [ $ref->( @$key ) ];
              }
          } elsif(    $key =~ /^-?\d+$/
                  &&  eval { my $x= $ref->[0]; 1 }
          ) {
              return  _Error( $ref, \$key, "Index out of range" )
                  if  $key < -@$ref
                  ||  $#$ref < $key;
              $ref= $ref->[$key];
          } elsif(  eval { exists $ref->{$key} }  ) {
              if(  eval { my $x= $$key; 1 }  ) {
                  $ref= $ref->{$$key};
              } else {
                  $ref= $ref->{$key};
              }
          } elsif(  eval { my $x= $ref->{$key}; 1 }  ) {
              return  _Error( $ref, \$key, "Key not present in hash" );
          } else {
              return  _Error( $ref, \$key, "Not a valid type of reference" );
          }
      }
      return $ref;
  }
  
  
  sub DiveVal :lvalue
  {
      ${ DiveRef( @_ ) };
  }
  
  
  sub DiveRef
  {
      return   if  ! @_;
      my $sv= \shift @_;
      return $$sv   if  ! $$sv;
      while(  @_  ) {
          my $key= shift @_;
          if(  ! defined $key  ) {
              $sv= \$$$sv;
          } elsif(    eval { my $x= $key->[0]; 1 }
                  &&  isa( $$sv, 'CODE' )
          ) {
              if(  @_  &&  ! defined $_[0]  ) {
                  $sv= \ $$sv->( @$key );
              } else {
                  $sv= \[ $$sv->( @$key ) ];
              }
          } elsif(    eval { my $x= $$key; 1 }
                  and     ! defined($$sv)
                      ||  eval { my $x= $$sv->{0}; 1 }
          ) {
              $sv= \$$sv->{$$key};
          } elsif(    $key =~ /^-?\d+$/
                  and     ! defined($$sv)
                      ||  eval { my $x= $$sv->[0]; 1 }
          ) {
              $sv= \$$sv->[$key];
          } else {
              $sv= \$$sv->{$key};
          }
      }
      return $sv;
  }
  
  
  'Data::Diver';
  
  __END__
  # Cheap pod2pm (convert POD to PerlMonk's HTMLish)
  my $p= 0;
  my $c= 0;
  while( <> ) {
      s/\r$//;
      if( /^$/ ) {
          $p= 1;
          next;
      }
      if( $p ) {
          if( /^ / ) {
              $p= 0;
              if( $c ) {
                  print $/;
              } else {
                  print "<code>\n";
                  $c= 1;
              }
          } elsif( /^\S/ and $c || !/^=/ ) {
              $p= 0;
              if( $c ) {
                  print "</code>\n";
                  $c= 0;
              } else {
                  print "<p>\n";
              }
          }
      }
      if( !$c ) {
          s#^=head(\d+)\s+(.*)# my $h= $1+2; "<h$h>$2</h$h>"#e;
          s#^=over.*#<ul>#;
          s#^=item\s+(.*)#<li>$1#;
          s#^=back.*#</ul>#;
          s/\[/&#91;/g;
          s/\]/&#93;/g;
          s#C<([^<>]+)>#<code>$1</code>#g;
          s#C<< (.+?) >>#<code>$1</code>#g;
          s#L</([^<>]+)>#<u>$1</u>#g;
      }
      print;
  }
  __END__
  
  =head1 NAME
  
  Data::Diver - Simple, ad-hoc access to elements of deeply nested structures
  
  =head1 SUMMARY
  
  Data::Diver provides the Dive() and DiveVal() functions for ad-hoc
  access to elements of deeply nested data structures, and the
  DiveRef(), DiveError(), DiveClear(), and DiveDie() support functions.
  
  =head1 SYNOPSIS
  
      use Data::Diver qw( Dive DiveRef DiveError );
  
      my $root= {
          top => [
              {   first => 1 },
              {   second => {
                      key => [
                          0, 1, 2, {
                              three => {
                                  exists => 'yes',
                              },
                          },
                      ],
                  },
              },
          ],
      };
  
      # Sets $value to 'yes'
      # ( $root->{top}[1]{second}{key}[3]{three}{exists} ):
      my $value= Dive( $root, qw( top 1 second key 3 three exists ) );
  
      # Sets $value to undef() because "missing" doesn't exist:
      $value= Dive( $root, qw( top 1 second key 3 three missing ) );
  
      # Sets $value to undef() because
      # $root->{top}[1]{second}{key}[4] is off the end of the array:
      $value= Dive( $root, qw( top 1 second key 4 ... ) );
  
      # Sets $value to undef() because
      # $root->{top}[1]{second}{key}[-5] would be a fatal error:
      $value= Dive( $root, qw( top 1 second key -5 ... ) );
  
      # Sets $ref to \$root->{top}[9]{new}{sub} (which grows
      # @{ $root->{top} } and autovifies two anonymous hashes):
      my $ref= DiveRef( $root, qw( top 9 new sub ) );
  
      # die()s because "other" isn't a valid number:
      $ref= DiveRef( $root, qw( top other ... ) );
  
      # Does: $root->{num}{1}{2}= 3;
      # (Autovivifies hashes despite the numeric keys.)
      DiveVal( $root, \( qw( num 1 2 ) ) ) = 3;
      # Same thing:
      ${ DiveRef( $root, 'num', \1, \2 ) } = 3;
  
      # Retrieves above value, $value= 3:
      $value= DiveVal( $root, 'num', \1, \2 );
      # Same thing:
      $value= ${ DiveRef( $root,  \( qw( num 1 2 ) ) ) };
  
      # Tries to do $root->{top}{1} and dies
      # because $root->{top} is an array reference:
      DiveRef( $root, 'top', \1 );
  
      # To only autovivify at the last step:
      $ref= DiveRef(
          Dive( $root, qw( top 1 second key 3 three ) ),
          'missing' );
      if(  $ref  ) {
          $$ref= 'me too'
      } else {
          my( $nestedRef, $svKey, $errDesc )= DiveError();
          die "Couldn't dereference $nestedRef via $$svKey: $errDesc\n";
      }
  
  =head1 DESCRIPTION
  
  Note that Data::Diver does C<use strict;> and so will not use symbolic
  references.  That is, a simple string can never be used as a reference.
  
  =head2 Dive
  
      $value= Dive( $root, @ListOfKeys )
  
  Dive() pulls out one value from a nested data structure.
  
  Dive() absolutely refuses to autovivify anything.  If you give any 'key'
  that would require autovivification [or would cause an error or warning],
  then an empty list is returned.
  
  How Dive() works is easiest to "explain" by looking at the examples
  listed in the L</SYNOPSIS> section above.
  
  $root should be a reference, usually a reference to hash or to an array.
  @ListOfKeys should be a list of values to use as hash keys or array
  indices [or a few other things] that will be used to deference deeper
  and deeper into the data structure that $root refers to.
  
  More details can be found under L</Simple 'key' values> and
  L</Advanced 'key' values> further down.
  
  If you want to distinguish between C<exists> and C<defined> for a hash
  element, then you can distinguish between an empty list, C<( )>, being
  returned and one C<undef>, C<( undef )>, being returned:
  
      my @exists= Dive( \%hashOfHashes, 'first', 'second' );
      if(  ! @exists  ) {
          warn "\$hashOfHashes{first}{second} does not exists.\n";
      } elsif(  ! defined $exists[0]  ) {
          warn "\$hashOfHashes{first}{second} exists but is undefined.\n";
      }
  
  =head2 DiveVal
  
      $val= DiveVal( $root, @ListOfKeys );
  
      DiveVal( $root, @ListOfKeys )= $val;
  
  DiveVal() is very much like Dive() except that it autovivifies if it
  can, dies if it can't, and is an LValue subroutine.  So you can assign
  to DiveVal() and the
  dereferenced element will be modified.  You can also take a reference
  to the call to DiveVal() or do anything else that you can do with a
  regular scalar variable.
  
  If $root is undefined, then DiveVal() immediately returns C<( undef )>
  [without overwriting C<DiveError()>].  This is for the special case of
  using C<DiveVal( Dive( ... ), ... )> because you want to only allow
  partial autovivifying.
  
  =head2 DiveRef
  
      $ref= DiveRef( $root, @ListOfKeys )
  
  =head2 Simple 'key' values
  
  Both Dive() and DiveRef() start by trying to dereference $root using
  the first element of @ListOfKeys.  We refer to the resulting value
  as C<$ref> and, if there are more elements in @ListOfKeys, then the
  next step will be to try to dereference C<$ref> using that next 'key'
  [producing a new value for C<$ref>].
  
  To dereference an array reference, you must give a 'key' value that
  is defined and matches C<m/^-?\d+$/>.  So, if you have more general
  numeric values, you should use C<int()> to convert them to simple
  integers.
  
  To dereference a hash reference, you must give a 'key' value that
  is C<defined> (or that is a reference to a scalar that will be used
  as the key).
  
  Note that all 'keys' that work for arrays also work for hashes.  If
  you have a reference that is overloaded such that it can both act
  as an array reference and as a hash reference [or, in the case of
  DiveVal() and DiveRef(), if you have an undefined C<$ref> which can
  be autovivified into either type of reference], then numeric-looking
  key values cause an array dereference.  In the above cases, if you
  want to do a hash dereference, then you need to pass in a reference
  to the key.
  
  Note that undefined keys are reserved for a special meaning
  discussed in L</Advanced 'key' values> further down.  That section
  discusses how to dereference other types of references [scalar
  references and subroutine references] and exactly how the different
  reference types and key values interact.
  
  =head2 DiveError
  
      ( $errDesc, $ref, $svKey )= DiveError();
  
  In the case of Dive() returning an empty list, a subsequent call to
  DiveError() will return a description of why Dive() failed, the
  specific reference that was trying to be dereferenced [not just the
  top-level $root reference that was passed into Dive], and a reference
  to the specific 'key'.
  
  =head2 DiveClear
  
      DiveClear();
  
  DiveClear() erases the record of any previous Dive() failures.
  
  =head2 DiveDie
  
      DiveDie();
  
  or
  
      $value= DiveDie( Dive(...) );
  
  or
  
      $value= DiveDie( $root, @ListOfKeys );
  
  This C<die>s with an error message based on the previously saved
  Dive() failure reason.
  
  If there is no previously saved failure reason or if one argument is
  passed into DiveDie(), then it simply returns that argument [or an empty list].
  
  If more than one argument is passed into DiveDie(), then those arguments
  are passed to Dive() and then DiveDie() behaves as described above.
  That is, C<DiveDie($root,@list)> acts the same as
  C<DiveDie(Dive($root,@list))>.
  
  =head2 Advanced 'key' values
  
  For both Dive() and DiveRef(), each $key in @ListOfKeys can have the
  following values:
  
  =over
  
  =item C<undef>
  
  This means that you expect C<$ref> to be a reference to a scalar and
  you want to dereference it.
  
  For Dive(), if C<$ref> is undefined or is something that can't act
  as a reference to a scalar, then the empty list is returned and
  DiveError() can tell you where the problem was.
  
  For DiveRef(), if C<$ref> is C<undef>, then it will be autovivified into
  a reference to a scalar [that will start out undefined but may quickly
  become autovivified due to the next element of @ListOfKeys].  If C<$ref>
  is something that can't act as a scalar reference, then Perl will C<die>
  to tell you why.
  
  Otherwise the scalar ref is deferenced (C<$$ref>) and we continue on to
  the next element of @ListOfKeys.
  
  =item a reference to a scalar
  
  This means that you expect C<$ref> to be a reference to a hash and
  you want to dereference it using C<$$key> as the key.
  
  This is most useful for when you want to use hash keys that match
  C<m/^-?\d+$/>.  Note that C<\( listOfScalars )> will give you a list
  of references to those scalars so you can often just add C<\(> and C<)>
  around your list of keys if you only want to do hash dereferencing:
  
      DiveVal( $ref, \( 1, -5, qw< 00 01 >, list(), 1-9, 0xFF ) )= 9;
  
  But, if your argument list of key values is build out of at least one
  array and any other item, then it won't work since:
  
      \( @a, $b, 9 ) is ( \@a, \$b, \9 )
  
  so you'll need to either wrap each array in additional parens or use C<map>:
  
      \( (@a), $b, (@c), 9 )
  
      map \$_, @a, $b, @c, 9
  
  =item C<$key =~ m/^-?\d+$/>
  
  This means that you might expect C<$ref> to be a reference to an array.
  
  For Dive(), if C<$ref> can act as a reference to an array and
  $key is in range ( -@$ref <= $key and $key <= $#$ref ), then
  C<< $ref= $ref->[$key]; >> is run [and this can't fail nor autovivify
  since we've already checked how big that array was].
  
  If $ref can't be used as an array reference, then $ref might be used
  as a hash reference instead, as described further down.
  
  If $ref is undefined or $key is out of range ($key < -@$ref or
  $#$ref < $key), then Dive() returns an empty list.
  
  For DiveRef(), if C<$ref> is undefined, then it is autovivified into
  a reference to anonymous array.  If C<$ref> can act as a reference
  to an array, then C<< $ref= $ref->[$key] >> is attempted.  If $key is
  larger than $#$ref, then @$ref will grow.  If $key is less than
  -@$ref, then Perl will C<die>.
  
  If C<$ref> cannot act as a reference to an array, then $ref might be
  used as a reference to a hash as described further down.
  
  =item a reference to an array
  
  If $key can be used as a reference to an array, then it means that
  you might expect C<$ref> to be a reference to a subroutine.
  
  If C<UNIVERSAL::isa( $ref, 'CODE' )> is true, then C<< $ref->( @$key ) >>
  is attempted.
  
  If $key isn't the last value in @ListOfKeys and the next value is
  undefined, then &$ref is called in a scalar context and $ref is set
  to refer to the scalar value returned.
  
  Otherwise, &$ref is called in a list context and $ref is set to refer
  to an anonymous array containing the value(s) returned.
  
  =item any (defined) string
  
  This means that you might expect C<$ref> to be a reference to a hash.
  
  For Dive(), if C<$ref> can act as a reference to a hash and
  C<<exists $ref->{$key} >> is true, then C<< $ref= $ref->{$key}; >> is run
  [and this can't fail nor autovivify].
  
  Otherwise, Dive() returns an empty list and DiveError() can tell you
  where the problem was.
  
  For DiveRef(), C<< $ref= $ref->{$key} >> is simply attempted.  This may
  autovivify a hash entry or even a new hash.  It may also C<die>, for
  example, if $ref can't be used as a hash reference.
  
  =back
  
  Note that the order of the above items is significant.  It represents
  the order in which cases are tested.  So an undefined $key will only
  be for derefencing a scalar reference and a numeric key will prefer
  to treat a reference as an array reference.
  
  =head1 AUTHOR
  
  Tye McQueen, http://www.perlmonks.org/?node=tye
  
  =head1 SEE ALSO
  
  Once More With Feeling -- Joss++
  
  =cut
DATA_DIVER

$fatpacked{"Data/Dmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_DMP';
  package Data::Dmp;
  
  our $DATE = '2017-01-30'; # DATE
  our $VERSION = '0.23'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  
  use Scalar::Util qw(looks_like_number blessed reftype refaddr);
  
  require Exporter;
  our @ISA = qw(Exporter);
  our @EXPORT = qw(dd dmp);
  
  # for when dealing with circular refs
  our %_seen_refaddrs;
  our %_subscripts;
  our @_fixups;
  
  our $OPT_PERL_VERSION = "5.010";
  our $OPT_REMOVE_PRAGMAS = 0;
  our $OPT_DEPARSE = 1;
  our $OPT_STRINGIFY_NUMBERS = 0;
  
  # BEGIN COPY PASTE FROM Data::Dump
  my %esc = (
      "\a" => "\\a",
      "\b" => "\\b",
      "\t" => "\\t",
      "\n" => "\\n",
      "\f" => "\\f",
      "\r" => "\\r",
      "\e" => "\\e",
  );
  
  # put a string value in double quotes
  sub _double_quote {
      local($_) = $_[0];
  
      # If there are many '"' we might want to use qq() instead
      s/([\\\"\@\$])/\\$1/g;
      return qq("$_") unless /[^\040-\176]/;  # fast exit
  
      s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
  
      # no need for 3 digits in escape for these
      s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
      s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
      s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
      return qq("$_");
  }
  # END COPY PASTE FROM Data::Dump
  
  sub _dump_code {
      my $code = shift;
  
      state $deparse = do {
          require B::Deparse;
          B::Deparse->new("-l"); # -i option doesn't have any effect?
      };
  
      my $res = $deparse->coderef2text($code);
  
      my ($res_before_first_line, $res_after_first_line) =
          $res =~ /(.+?)^(#line .+)/ms;
  
      if ($OPT_REMOVE_PRAGMAS) {
          $res_before_first_line = "{";
      } elsif ($OPT_PERL_VERSION < 5.016) {
          # older perls' feature.pm doesn't yet support q{no feature ':all';}
          # so we replace it with q{no feature}.
          $res_before_first_line =~ s/no feature ':all';/no feature;/m;
      }
      $res_after_first_line =~ s/^#line .+//gm;
  
      $res = "sub" . $res_before_first_line . $res_after_first_line;
      $res =~ s/^\s+//gm;
      $res =~ s/\n+//g;
      $res =~ s/;\}\z/}/;
      $res;
  }
  
  sub _quote_key {
      $_[0] =~ /\A-?[A-Za-z_][A-Za-z0-9_]*\z/ ||
          $_[0] =~ /\A-?[1-9][0-9]{0,8}\z/ ? $_[0] : _double_quote($_[0]);
  }
  
  sub _dump {
      my ($val, $subscript) = @_;
  
      my $ref = ref($val);
      if ($ref eq '') {
          if (!defined($val)) {
              return "undef";
          } elsif (looks_like_number($val) && !$OPT_STRINGIFY_NUMBERS &&
                       # perl does several normalizations to number literal, e.g.
                       # "+1" becomes 1, 0123 is octal literal, etc. make sure we
                       # only leave out quote when the number is not normalized
                       $val eq $val+0 &&
                       # perl also doesn't recognize Inf and NaN as numeric
                       # literals (ref: perldata) so these unquoted literals will
                       # choke under 'use strict "subs"
                       $val !~ /\A-?(?:inf(?:inity)?|nan)\z/i
                   ) {
              return $val;
          } else {
              return _double_quote($val);
          }
      }
      my $refaddr = refaddr($val);
      $_subscripts{$refaddr} //= $subscript;
      if ($_seen_refaddrs{$refaddr}++) {
          push @_fixups, "\$a->$subscript=\$a",
              ($_subscripts{$refaddr} ? "->$_subscripts{$refaddr}" : ""), ";";
          return "'fix'";
      }
  
      my $class;
  
      if ($ref eq 'Regexp' || $ref eq 'REGEXP') {
          require Regexp::Stringify;
          return Regexp::Stringify::stringify_regexp(
              regexp=>$val, with_qr=>1, plver=>$OPT_PERL_VERSION);
      }
  
      if (blessed $val) {
          $class = $ref;
          $ref = reftype($val);
      }
  
      my $res;
      if ($ref eq 'ARRAY') {
          $res = "[";
          my $i = 0;
          for (@$val) {
              $res .= "," if $i;
              $res .= _dump($_, "$subscript\[$i]");
              $i++;
          }
          $res .= "]";
      } elsif ($ref eq 'HASH') {
          $res = "{";
          my $i = 0;
          for (sort keys %$val) {
              $res .= "," if $i++;
              my $k = _quote_key($_);
              my $v = _dump($val->{$_}, "$subscript\{$k}");
              $res .= "$k=>$v";
          }
          $res .= "}";
      } elsif ($ref eq 'SCALAR') {
          $res = "\\"._dump($$val, $subscript);
      } elsif ($ref eq 'REF') {
          $res = "\\"._dump($$val, $subscript);
      } elsif ($ref eq 'CODE') {
          $res = $OPT_DEPARSE ? _dump_code($val) : 'sub{"DUMMY"}';
      } else {
          die "Sorry, I can't dump $val (ref=$ref) yet";
      }
  
      $res = "bless($res,"._double_quote($class).")" if defined($class);
      $res;
  }
  
  our $_is_dd;
  sub _dd_or_dmp {
      local %_seen_refaddrs;
      local %_subscripts;
      local @_fixups;
  
      my $res;
      if (@_ > 1) {
          $res = "(" . join(",", map {_dump($_, '')} @_) . ")";
      } else {
          $res = _dump($_[0], '');
      }
      if (@_fixups) {
          $res = "do{my\$a=$res;" . join("", @_fixups) . "\$a}";
      }
  
      if ($_is_dd) {
          say $res;
          return wantarray() || @_ > 1 ? @_ : $_[0];
      } else {
          return $res;
      }
  }
  
  sub dd { local $_is_dd=1; _dd_or_dmp(@_) } # goto &sub doesn't work here
  sub dmp { goto &_dd_or_dmp }
  
  1;
  # ABSTRACT: Dump Perl data structures as Perl code
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::Dmp - Dump Perl data structures as Perl code
  
  =head1 VERSION
  
  This document describes version 0.23 of Data::Dmp (from Perl distribution Data-Dmp), released on 2017-01-30.
  
  =head1 SYNOPSIS
  
   use Data::Dmp; # exports dd() and dmp()
   dd [1, 2, 3]; # prints "[1,2,3]"
   $a = dmp({a => 1}); # -> "{a=>1}"
  
  =head1 DESCRIPTION
  
  Data::Dmp is a Perl dumper like L<Data::Dumper>. It's compact (only about 175
  lines of code long), starts fast and does not use any non-core modules except
  L<Regexp::Stringify> when dumping regexes. It produces compact single-line
  output (similar to L<Data::Dumper::Concise>). It roughly has the same speed as
  Data::Dumper (usually a bit faster for smaller structures) and faster than
  L<Data::Dump>, but does not offer the various formatting options. It supports
  dumping objects, regexes, circular structures, coderefs. Its code is first based
  on L<Data::Dump>: I removed all the parts that I don't need, particularly the
  pretty formatting stuffs) and added some features that I need like proper regex
  dumping and coderef deparsing.
  
  =head1 SETTINGS
  
  =head2 $Data::Dmp::OPT_PERL_VERSION => str (default: 5.010)
  
  Set target Perl version. If you set this to, say C<5.010>, then the dumped code
  will keep compatibility with Perl 5.10.0. This is used in the following ways:
  
  =over
  
  =item * passed to L<Regexp::Stringify>
  
  =item * when dumping code references
  
  For example, in perls earlier than 5.016, feature.pm does not understand:
  
   no feature ':all';
  
  so we replace it with:
  
   no feature;
  
  =back
  
  =head2 $Data::Dmp::OPT_REMOVE_PRAGMAS => bool (default: 0)
  
  If set to 1, then pragmas at the start of coderef dump will be removed. Coderef
  dump is produced by L<B::Deparse> and is of the form like:
  
   sub { use feature 'current_sub', 'evalbytes', 'fc', 'say', 'state', 'switch', 'unicode_strings', 'unicode_eval'; $a <=> $b }
  
  If you want to dump short coderefs, the pragmas might be distracting. You can
  turn turn on this option which will make the above dump become:
  
   sub { $a <=> $b }
  
  Note that without the pragmas, the dump might be incorrect.
  
  =head2 $Data::Dmp::OPT_DEPARSE => bool (default: 1)
  
  Can be set to 0 to skip deparsing code. Coderefs will be dumped as
  C<sub{"DUMMY"}> instead, like in Data::Dump.
  
  =head2 $Data::Dmp::OPT_STRINGIFY_NUMBERS => bool (default: 0)
  
  If set to true, will dump numbers as quoted string, e.g. 123 as "123" instead of
  123. This might be helpful if you want to compute the hash of or get a canonical
  representation of data structure.
  
  =head1 BENCHMARKS
  
   [1..10]:
                         Rate    Data::Dump Data::Dumper Data::Dmp
   Data::Dump     30417+-55/s            --       -66.2%    -74.0%
   Data::Dumper   89888+-79/s  195.52+-0.6%           --    -23.1%
   Data::Dmp    116890+-160/s 284.29+-0.87% 30.04+-0.21%        --
   
   [1..100]:
                          Rate    Data::Dump  Data::Dmp Data::Dumper
   Data::Dump    3712.3+-7.9/s            --     -73.9%       -74.9%
   Data::Dmp    14211.3+-4.9/s 282.82+-0.82%         --        -3.8%
   Data::Dumper    14771+-28/s   297.9+-1.1% 3.94+-0.2%           --
   
   Some mixed structure:
                       Rate    Data::Dump    Data::Dmp Data::Dumper
   Data::Dump    8764+-16/s            --       -67.6%       -80.1%
   Data::Dmp    27016+-36/s  208.28+-0.7%           --       -38.6%
   Data::Dumper 43995+-13/s 402.02+-0.95% 62.85+-0.22%           --
  
  =head1 FUNCTIONS
  
  =head2 dd($data, ...) => $data ...
  
  Exported by default. Like C<Data::Dump>'s C<dd> (a.k.a. C<dump>), print one or
  more data to STDOUT. Unlike C<Data::Dump>'s C<dd>, it I<always> prints and
  return I<the original data> (like L<XXX>), making it convenient to insert into
  expressions. This also removes ambiguity and saves one C<wantarray()> call.
  
  =head2 dmp($data, ...) => $str
  
  Exported by default. Return dump result as string. Unlike C<Data::Dump>'s C<dd>
  (a.k.a. C<dump>), it I<never> prints and only return the data.
  
  =head1 FAQ
  
  =head2 When to use Data::Dmp? How does it compare to other dumper modules?
  
  Data::Dmp might be suitable for you if you want a relatively fast pure-Perl data
  structure dumper to eval-able Perl code. It produces compact, single-line Perl
  code but offers little/no formatting options. Data::Dmp and Data::Dump module
  family usually produce Perl code that is "more eval-able", e.g. it can recreate
  circular structure.
  
  L<Data::Dump> produces visually nicer output (some alignment, use of range
  operator to shorten lists, use of base64 for binary data, etc) but no built-in
  option to produce compact/single-line output. It's more suitable for debugging.
  It's also relatively slow. I usually use its variant, L<Data::Dump::Color>, for
  console debugging.
  
  L<Data::Dumper> is a core module, offers a lot of formatting options (like
  disabling hash key sorting, setting verboseness/indent level, and so on) but you
  usually have to configure it quite a bit before it does exactly like you want
  (that's why there are modules on CPAN that are just wrapping Data::Dumper with
  some configuration, like L<Data::Dumper::Concise> et al). It does not support
  dumping Perl code that can recreate circular structures.
  
  Of course, dumping to eval-able Perl code is slow (not to mention the cost of
  re-loading the code back to in-memory data, via eval-ing) compared to dumping to
  JSON, YAML, Sereal, or other format. So you need to decide first whether this is
  the appropriate route you want to take. (But note that there is also
  L<Data::Dumper::Limited> and L<Data::Undump> which uses a format similar to
  Data::Dumper but lets you load the serialized data without eval-ing them, thus
  achieving the speed comparable to JSON::XS).
  
  =head2 Is the output guaranteed to be single line dump?
  
  No. Some things can still produce multiline dump, e.g. newline in regular
  expression.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Data-Dmp>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Data-Dmp>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Data-Dmp>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Data::Dump> and other variations/derivate works in Data::Dump::*.
  
  L<Data::Dumper> and its variants.
  
  L<Data::Printer>.
  
  L<YAML>, L<JSON>, L<Storable>, L<Sereal>, and other serialization formats.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
DATA_DMP

$fatpacked{"Devel/TypeTiny/Perl56Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL56COMPAT';
  package Devel::TypeTiny::Perl56Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.002001';
  
  #### B doesn't provide perlstring() in 5.6. Monkey patch it.
  
  use B ();
  
  unless (exists &B::perlstring)
  {
  	my $d;
  	*B::perlstring = sub {
  		no warnings 'uninitialized';
  		require Data::Dumper;
  		$d ||= 'Data::Dumper'->new([])->Indent(0)->Purity(0)->Pad('')->Useqq(1)->Terse(1)->Freezer('')->Toaster('');
  		my $perlstring = $d->Values([''.shift])->Dump;
  		($perlstring =~ /^"/) ? $perlstring : qq["$perlstring"];
  	};
  }
  
  unless (exists &B::cstring)
  {
  	*B::cstring = \&B::perlstring;
  }
  
  push @B::EXPORT_OK, qw( perlstring cstring );
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl56Compat - shims to allow Type::Tiny to run on Perl 5.6.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<B> to export a
  C<perlstring> function, as this was only added in Perl 5.8.0.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL56COMPAT

$fatpacked{"Devel/TypeTiny/Perl58Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_TYPETINY_PERL58COMPAT';
  package Devel::TypeTiny::Perl58Compat;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.002001';
  
  #### re doesn't provide is_regexp in Perl < 5.10
  
  eval 'require re';
  
  unless (exists &re::is_regexp)
  {
  	require B;
  	*re::is_regexp = sub {
  		eval { B::svref_2object($_[0])->MAGIC->TYPE eq 'r' };
  	};
  }
  
  #### Done!
  
  5.6;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Devel::TypeTiny::Perl58Compat - shims to allow Type::Tiny to run on Perl 5.8.x
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  Currently this module just has one job: it patches L<re> to provide a
  C<is_regexp> function, as this was only added in Perl 5.9.5.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
DEVEL_TYPETINY_PERL58COMPAT

$fatpacked{"Error/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY';
  package Error::TypeTiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::VERSION   = '1.002001';
  }
  
  use overload
  	q[""]    => sub { $_[0]->to_string },
  	q[bool]  => sub { 1 },
  	fallback => 1,
  ;
  
  our %CarpInternal;
  $CarpInternal{$_}++ for qw(
  	Eval::TypeTiny
  	Eval::TypeTiny::Sandbox
  	Exporter::Tiny
  	Test::TypeTiny
  	Type::Coercion
  	Type::Coercion::Union
  	Error::TypeTiny
  	Type::Library
  	Type::Params
  	Type::Registry
  	Types::Standard
  	Types::Standard::_Stringable
  	Types::TypeTiny
  	Type::Tiny
  	Type::Tiny::Class
  	Type::Tiny::Duck
  	Type::Tiny::Enum
  	Type::Tiny::Intersection
  	Type::Tiny::Role
  	Type::Tiny::Union
  	Type::Utils
  );
  
  sub new
  {
  	my $class = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	return bless \%params, $class;
  }
  
  sub throw
  {
  	my $class = shift;
  	
  	my ($level, @caller, %ctxt) = 0;
  	while (
  		defined scalar caller($level) and $CarpInternal{scalar caller($level)}
  	) { $level++ };
  	if ( ((caller($level - 1))[1]||"") =~ /^parameter validation for '(.+?)'$/ )
  	{
  		my ($pkg, $func) = ($1 =~ m{^(.+)::(\w+)$});
  		$level++ if caller($level) eq ($pkg||"");
  	}
  	# Moo's Method::Generate::Constructor puts an eval in the stack trace,
  	# that is useless for debugging, so show the stack frame one above.
  	$level++ if (
  		(caller($level))[1] =~ /^\(eval \d+\)$/ and
  		(caller($level))[3] eq '(eval)' # (caller())[3] is $subroutine
  	);
  	@ctxt{qw/ package file line /} = caller($level);
  	
  	my $stack = undef;
  	if (our $StackTrace)
  	{
  		require Devel::StackTrace;
  		$stack = "Devel::StackTrace"->new(
  			ignore_package => [ keys %CarpInternal ],
  		);
  	}
  	
  	die(
  		our $LastError = $class->new(
  			context     => \%ctxt,
  			stack_trace => $stack,
  			@_,
  		)
  	);
  }
  
  sub message     { $_[0]{message} ||= $_[0]->_build_message };
  sub context     { $_[0]{context} };
  sub stack_trace { $_[0]{stack_trace} };
  
  sub to_string
  {
  	my $e = shift;
  	my $c = $e->context;
  	my $m = $e->message;
  	
  	$m =~ /\n\z/s ? $m :
  	$c            ? sprintf("%s at %s line %s.\n", $m, $c->{file}||'file?', $c->{line}||'NaN') :
  	sprintf("%s\n", $m);
  }
  
  sub _build_message
  {
  	return 'An exception has occurred';
  }
  
  sub croak
  {
  	my ($fmt, @args) = @_;
  	@_ = (
  		__PACKAGE__,
  		message => sprintf($fmt, @args),
  	);
  	goto \&throw;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny - exceptions for Type::Tiny and friends
  
  =head1 SYNOPSIS
  
     use Data::Dumper;
     use Try::Tiny;
     use Types::Standard qw(Str);
     
     try {
        Str->assert_valid(undef);
     }
     catch {
        my $exception = shift;
        warn "Encountered Error: $exception";
        warn Dumper($exception->explain)
           if $exception->isa("Error::TypeTiny::Assertion");
     };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  When Type::Tiny and its related modules encounter an error, they throw an
  exception object. These exception objects inherit from Error::TypeTiny.
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< throw(%attributes) >>
  
  Constructs an exception and passes it to C<die>.
  
  Automatically populates C<context> and C<stack_trace> if appropriate.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<message>
  
  The error message.
  
  =item C<context>
  
  Hashref containing the package, file and line that generated the error.
  
  =item C<stack_trace>
  
  A more complete stack trace. This feature requires L<Devel::StackTrace>;
  use the C<< $StackTrace >> package variable to switch it on.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<to_string>
  
  Returns the message, followed by the context if it is set.
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< Error::TypeTiny::croak($format, @args) >>
  
  Functional-style shortcut to C<throw> method. Takes an C<sprintf>-style
  format string and optional arguments to construct the C<message>.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to call C<to_string>.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< %Error::TypeTiny::CarpInternal >>
  
  Serves a similar purpose to C<< %Carp::CarpInternal >>.
  
  =item C<< $Error::TypeTiny::StackTrace >>
  
  Boolean to toggle stack trace generation.
  
  =item C<< $Error::TypeTiny::LastError >>
  
  A reference to the last exception object thrown.
  
  =back
  
  =head1 CAVEATS
  
  Although Error::TypeTiny objects are thrown for errors produced by
  Type::Tiny, that doesn't mean every time you use Type::Tiny you'll get
  Error::TypeTinys whenever you want.
  
  For example, if you use a Type::Tiny type constraint in a Moose attribute,
  Moose will not call the constraint's C<assert_valid> method (which throws
  an exception). Instead it will call C<check> and C<get_message> (which do
  not), and will C<confess> an error message of its own. (The C<< $LastError >>
  package variable may save your bacon.)
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>,
  L<Error::TypeTiny::WrongNumberOfParameters>.
  
  L<Try::Tiny>, L<Try::Tiny::ByClass>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY

$fatpacked{"Error/TypeTiny/Assertion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_ASSERTION';
  package Error::TypeTiny::Assertion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Error::TypeTiny::Assertion::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Assertion::VERSION   = '1.002001';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub type               { $_[0]{type} };
  sub value              { $_[0]{value} };
  sub varname            { $_[0]{varname} ||= '$_' };
  sub attribute_step     { $_[0]{attribute_step} };
  sub attribute_name     { $_[0]{attribute_name} };
  
  sub has_type           { defined $_[0]{type} }; # sic
  sub has_attribute_step { exists $_[0]{attribute_step} };
  sub has_attribute_name { exists $_[0]{attribute_name} };
  
  sub new
  {
  	my $class = shift;
  	my $self  = $class->SUPER::new(@_);
  	
  	if (ref $Method::Generate::Accessor::CurrentAttribute)
  	{
  		require B;
  		my %d = %{$Method::Generate::Accessor::CurrentAttribute};
  		$self->{attribute_name} = $d{name} if defined $d{name};
  		$self->{attribute_step} = $d{step} if defined $d{step};
  		
  		if (defined $d{init_arg})
  		{
  			$self->{varname} = sprintf('$args->{%s}', B::perlstring($d{init_arg}));
  		}
  		elsif (defined $d{name})
  		{
  			$self->{varname} = sprintf('$self->{%s}', B::perlstring($d{name}));
  		}
  	}
  	
  	return $self;
  }
  
  sub message
  {
  	my $e = shift;
  	$e->varname eq '$_'
  		? $e->SUPER::message
  		: sprintf('%s (in %s)', $e->SUPER::message, $e->varname);
  }
  
  sub _build_message
  {
  	my $e = shift;
  	$e->has_type
  		? sprintf('%s did not pass type constraint "%s"', Type::Tiny::_dd($e->value), $e->type)
  		: sprintf('%s did not pass type constraint', Type::Tiny::_dd($e->value))
  }
  
  *to_string = sub
  {
  	my $e = shift;
  	my $msg = $e->message;
  	
  	my $c = $e->context;
  	$msg .= sprintf(" at %s line %s", $c->{file}||'file?', $c->{line}||'NaN') if $c;
  	
  	my $explain = $e->explain;
  	return "$msg\n" unless @{ $explain || [] };
  	
  	$msg .= "\n";
  	for my $line (@$explain) {
  		$msg .= "    $line\n";
  	}
  	
  	return $msg;
  } if $] >= 5.008;
  
  sub explain
  {
  	my $e = shift;
  	return undef unless $e->has_type;
  	$e->type->validate_explain($e->value, $e->varname);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Assertion - exception when a value fails a type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This exception is thrown when a value fails a type constraint assertion.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type>
  
  The type constraint that was checked against. Weakened links are involved,
  so this may end up being C<undef>.
  
  =item C<value>
  
  The value that was tested.
  
  =item C<varname>
  
  The name of the variable that was checked, if known. Defaults to C<< '$_' >>.
  
  =item C<attribute_name>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will tell you which attribute (if
  your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =item C<attribute_step>
  
  If this exception was thrown as the result of an isa check or a failed
  coercion for a Moo attribute, then this will contain either C<< "isa check" >>
  or C<< "coercion" >> to indicate which went wrong (if your Moo is new enough).
  
  (Hopefully one day this will support other OO frameworks.)
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_type>, C<has_attribute_name>, C<has_attribute_step>
  
  Predicate methods.
  
  =item C<message>
  
  Overridden to add C<varname> to the message if defined.
  
  =item C<explain>
  
  Attempts to explain why the value did not pass the type constraint. Returns
  an arrayref of strings providing step-by-step reasoning; or returns undef if
  no explanation is possible.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_ASSERTION

$fatpacked{"Error/TypeTiny/Compilation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_COMPILATION';
  package Error::TypeTiny::Compilation;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::Compilation::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::Compilation::VERSION   = '1.002001';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub code        { $_[0]{code} };
  sub environment { $_[0]{environment} ||= {} };
  sub errstr      { $_[0]{errstr} };
  
  sub _build_message
  {
  	my $self = shift;
  	sprintf("Failed to compile source because: %s", $self->errstr);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::Compilation - exception for Eval::TypeTiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when compiling a closure fails. Common causes are problems with
  inlined type constraints, and syntax errors when coercions are given as
  strings of Perl code.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<code>
  
  The Perl source code being compiled.
  
  =item C<environment>
  
  Hashref of variables being closed over.
  
  =item C<errstr>
  
  Error message from Perl compiler.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_COMPILATION

$fatpacked{"Error/TypeTiny/WrongNumberOfParameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS';
  package Error::TypeTiny::WrongNumberOfParameters;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Error::TypeTiny::WrongNumberOfParameters::AUTHORITY = 'cpan:TOBYINK';
  	$Error::TypeTiny::WrongNumberOfParameters::VERSION   = '1.002001';
  }
  
  require Error::TypeTiny;
  our @ISA = 'Error::TypeTiny';
  
  sub minimum    { $_[0]{minimum} };
  sub maximum    { $_[0]{maximum} };
  sub got        { $_[0]{got} };
  
  sub has_minimum { exists $_[0]{minimum} };
  sub has_maximum { exists $_[0]{maximum} };
  
  sub _build_message
  {
  	my $e = shift;
  	if ($e->has_minimum and $e->has_maximum and $e->minimum == $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	elsif ($e->has_minimum and $e->has_maximum and $e->minimum < $e->maximum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected %d to %d",
  			$e->got,
  			$e->minimum,
  			$e->maximum,
  		);
  	}
  	elsif ($e->has_minimum)
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d; expected at least %d",
  			$e->got,
  			$e->minimum,
  		);
  	}
  	else
  	{
  		return sprintf(
  			"Wrong number of parameters; got %d",
  			$e->got,
  		);
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Error::TypeTiny::WrongNumberOfParameters - exception for Type::Params
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Thrown when a Type::Params compiled check is called with the wrong number
  of parameters.
  
  This package inherits from L<Error::TypeTiny>; see that for most
  documentation. Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<minimum>
  
  The minimum expected number of parameters.
  
  =item C<maximum>
  
  The maximum expected number of parameters.
  
  =item C<got>
  
  The number of parameters actually passed to the compiled check.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<has_minimum>, C<has_maximum>
  
  Predicate methods.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
ERROR_TYPETINY_WRONGNUMBEROFPARAMETERS

$fatpacked{"Eval/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EVAL_TYPETINY';
  package Eval::TypeTiny;
  
  use strict;
  
  BEGIN {
  	*HAS_LEXICAL_SUBS = ($] >= 5.018) ? sub(){!!1} : sub(){!!0};
  };
  
  {
  	my $hlv;
  	sub HAS_LEXICAL_VARS () {
  		$hlv = !! eval {
  			require Devel::LexAlias;
  			exists(&Devel::LexAlias::lexalias);
  		} unless defined $hlv;
  		$hlv;
  	}
  }
  
  sub _clean_eval
  {
  	local $@;
  	local $SIG{__DIE__};
  	my $r = eval $_[0];
  	my $e = $@;
  	return ($r, $e);
  }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.002001';
  our @EXPORT    = qw( eval_closure );
  our @EXPORT_OK = qw( HAS_LEXICAL_SUBS HAS_LEXICAL_VARS );
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  use warnings;
  
  sub eval_closure
  {
  	my (%args) = @_;
  	my $src    = ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source};
  	
  	$args{alias}  = 0 unless defined $args{alias};
  	$args{line}   = 1 unless defined $args{line};
  	$args{description} =~ s/[^\w .:-\[\]\(\)\{\}\']//g if defined $args{description};
  	$src = qq{#line $args{line} "$args{description}"\n$src} if defined $args{description} && !($^P & 0x10);
  	$args{environment} ||= {};
  	
  #	for my $k (sort keys %{$args{environment}})
  #	{
  #		next if $k =~ /^\$/ && ref($args{environment}{$k}) =~ /^(SCALAR|REF)$/;
  #		next if $k =~ /^\@/ && ref($args{environment}{$k}) eq q(ARRAY);
  #		next if $k =~ /^\%/ && ref($args{environment}{$k}) eq q(HASH);
  #		
  #		require Error::TypeTiny;
  #		Error::TypeTiny::croak("Expected a variable name and ref; got %s => %s", $k, $args{environment}{$k});
  #	}
  	
  	my $sandpkg   = 'Eval::TypeTiny::Sandbox';
  	my $alias     = exists($args{alias}) ? $args{alias} : 0;
  	my @keys      = sort keys %{$args{environment}};
  	my $i         = 0;
  	my $source    = join "\n" => (
  		"package $sandpkg;",
  		"sub {",
  		map(_make_lexical_assignment($_, $i++, $alias), @keys),
  		$src,
  		"}",
  	);
  	
  	_manufacture_ties() if $alias && !HAS_LEXICAL_VARS;
  	
  	my ($compiler, $e) = _clean_eval($source);
  	if ($e)
  	{
  		chomp $e;
  		require Error::TypeTiny::Compilation;
  		"Error::TypeTiny::Compilation"->throw(
  			code        => (ref $args{source} eq "ARRAY" ? join("\n", @{$args{source}}) : $args{source}),
  			errstr      => $e,
  			environment => $args{environment},
  		);
  	}
  	
  	my $code = $compiler->(@{$args{environment}}{@keys});
  	undef($compiler);
  
  	if ($alias && HAS_LEXICAL_VARS) {
  		Devel::LexAlias::lexalias($code, $_, $args{environment}{$_}) for grep !/^\&/, @keys;
  	}
  	
  	return $code;
  }
  
  my $tmp;
  sub _make_lexical_assignment
  {
  	my ($key, $index, $alias) = @_;
  	my $name = substr($key, 1);
  	
  	if (HAS_LEXICAL_SUBS and $key =~ /^\&/) {
  		$tmp++;
  		my $tmpname = '$__LEXICAL_SUB__'.$tmp;
  		return
  			"no warnings 'experimental::lexical_subs';".
  			"use feature 'lexical_subs';".
  			"my $tmpname = \$_[$index];".
  			"my sub $name { goto $tmpname };";
  	}
  	
  	if (!$alias) {
  		my $sigil = substr($key, 0, 1);
  		return "my $key = $sigil\{ \$_[$index] };";
  	}
  	elsif (HAS_LEXICAL_VARS) {
  		return "my $key;";
  	}
  	else {
  		my $tieclass = {
  			'@' => 'Eval::TypeTiny::_TieArray',
  			'%' => 'Eval::TypeTiny::_TieHash',
  			'$' => 'Eval::TypeTiny::_TieScalar',
  		}->{ substr($key, 0, 1) };
  		
  		return sprintf(
  			'tie(my(%s), "%s", $_[%d]);',
  			$key,
  			$tieclass,
  			$index,
  		);
  	}
  }
  
  { my $tie; sub _manufacture_ties { $tie ||= eval <<'FALLBACK'; } }
  no warnings qw(void once uninitialized numeric);
  
  {
  	package #
  		Eval::TypeTiny::_TieArray;
  	require Tie::Array;
  	our @ISA = qw( Tie::StdArray );
  	sub TIEARRAY {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(@$self) and return tied(@$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(@$self) and tied(@$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied @{$_[0]} },
  		q[""]    => sub { '' . tied @{$_[0]} },
  		q[0+]    => sub { 0  + tied @{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieHash;
  	require Tie::Hash;
  	our @ISA = qw( Tie::StdHash );
  	sub TIEHASH {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied(%$self) and return tied(%$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied(%$self) and tied(%$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied %{$_[0]} },
  		q[""]    => sub { '' . tied %{$_[0]} },
  		q[0+]    => sub { 0  + tied %{$_[0]} },
  		fallback => 1,
  	;
  }
  {
  	package #
  		Eval::TypeTiny::_TieScalar;
  	require Tie::Scalar;
  	our @ISA = qw( Tie::StdScalar );
  	sub TIESCALAR {
  		my $class = shift;
  		bless $_[0] => $class;
  	}
  	sub AUTOLOAD {
  		my $self = shift;
  		my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  		defined tied($$self) and return tied($$self)->$method(@_);
  		require Carp;
  		Carp::croak(qq[Can't call method "$method" on an undefined value]);
  	}
  	sub can {
  		my $self = shift;
  		my $code = $self->SUPER::can(@_)
  			|| (defined tied($$self) and tied($$self)->can(@_));
  		return $code;
  	}
  	use overload
  		q[bool]  => sub { !!   tied ${$_[0]} },
  		q[""]    => sub { '' . tied ${$_[0]} },
  		q[0+]    => sub { 0  + tied ${$_[0]} },
  		fallback => 1,
  	;
  }
  
  1;
  FALLBACK
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas coderefs
  
  =head1 NAME
  
  Eval::TypeTiny - utility to evaluate a string of Perl code in a clean environment
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module is used by Type::Tiny to compile coderefs from strings of
  Perl code, and hashrefs of variables to close over.
  
  =head2 Functions
  
  This module exports one function, which works much like the similarly named
  function from L<Eval::Closure>:
  
  =over
  
  =item C<< eval_closure(source => $source, environment => \%env, %opt) >>
  
  =back
  
  =head2 Constants
  
  The following constants may be exported, but are not by default.
  
  =over
  
  =item C<< HAS_LEXICAL_SUBS >>
  
  Boolean indicating whether Eval::TypeTiny has support for lexical subs.
  (This feature requires Perl 5.18.)
  
  =item C<< HAS_LEXICAL_VARS >>
  
  Don't worry; closing over lexical variables in the closures is always
  supported! However, if this constant is true, it means that
  L<Devel::LexAlias> is available, which makes them slightly faster than
  the fallback solution which uses tied variables. (This only makes any
  difference when the C<< alias => 1 >> option is used.)
  
  =back
  
  =head1 EVALUATION ENVIRONMENT
  
  The evaluation is performed in the presence of L<strict>, but the absence of
  L<warnings>. (This is different to L<Eval::Closure> which enables warnings for
  compiled closures.)
  
  The L<feature> pragma is not active in the evaluation environment, so the
  following will not work:
  
     use feature qw(say);
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { say for @_ }',
     );
     $say_all->("Hello", "World");
  
  The L<feature> pragma does not "carry over" into the stringy eval. It is
  of course possible to import pragmas into the evaluated string as part of the
  string itself:
  
     use Eval::TypeTiny qw(eval_closure);
     
     my $say_all = eval_closure(
        source => 'sub { use feature qw(say); say for @_ }',
     );
     $say_all->("Hello", "World");
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Eval::Closure>, L<Error::TypeTiny::Compilation>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EVAL_TYPETINY

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  use Exporter::Tiny ();
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  
  sub import {
  	my $me     = shift;
  	my $caller = caller;
  	
  	(my $nominal_file = $caller) =~ s(::)(/)g;
  	$INC{"$nominal_file\.pm"} ||= __FILE__;
  	
  	if (@_ == 2 and $_[0] eq -setup)
  	{
  		my (undef, $opts) = @_;
  		@_ = @{ delete($opts->{exports}) || [] };
  		
  		if (%$opts) {
  			Exporter::Tiny::_croak(
  				'Unsupported Sub::Exporter-style options: %s',
  				join(q[, ], sort keys %$opts),
  			);
  		}
  	}
  	
  	ref($_) && Exporter::Tiny::_croak('Expected sub name, got ref %s', $_) for @_;
  	
  	no strict qw(refs);
  	push @{"$caller\::ISA"}, 'Exporter::Tiny';
  	push @{"$caller\::EXPORT_OK"}, @_;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Exporter::Shiny - shortcut for Exporter::Tiny
  
  =head1 SYNOPSIS
  
     use Exporter::Shiny qw( foo bar );
  
  Is a shortcut for:
  
     use base "Exporter::Tiny";
     push our(@EXPORT_OK), qw( foo bar );
  
  For compatibility with L<Sub::Exporter>, the following longer syntax is
  also supported:
  
     use Exporter::Shiny -setup => {
        exports => [qw( foo bar )],
     };
  
  =head1 DESCRIPTION
  
  This is a very small wrapper to simplify using L<Exporter::Tiny>.
  
  It does the following:
  
  =over
  
  =item * Marks your package as loaded in C<< %INC >>;
  
  =item * Pushes any function names in the import list onto your C<< @EXPORT_OK >>; and
  
  =item * Pushes C<< "Exporter::Tiny" >> onto your C<< @ISA >>.
  
  =back
  
  It doesn't set up C<< %EXPORT_TAGS >> or C<< @EXPORT >>, but there's
  nothing stopping you doing that yourself.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SEE ALSO
  
  This module is just a wrapper around L<Exporter::Tiny>, so take a look
  at L<Exporter::Tiny::Manual::QuickStart> and
  L<Exporter::Tiny::Manual::Exporting> for further information on what
  features are available.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;
  
  use 5.006001;
  use strict;
  use warnings; no warnings qw(void once uninitialized numeric redefine);
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.000000';
  our @EXPORT_OK = qw< mkopt mkopt_hash _croak _carp >;
  
  sub _croak ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::croak }
  sub _carp  ($;@) { require Carp; my $fmt = shift; @_ = sprintf($fmt, @_); goto \&Carp::carp }
  
  my $_process_optlist = sub
  {
  	my $class = shift;
  	my ($global_opts, $opts, $want, $not_want) = @_;
  	
  	while (@$opts)
  	{
  		my $opt = shift @{$opts};
  		my ($name, $value) = @$opt;
  		
  		($name =~ m{\A\!(/.+/[msixpodual]+)\z}) ?
  			do {
  				my @not = $class->_exporter_expand_regexp($1, $value, $global_opts);
  				++$not_want->{$_->[0]} for @not;
  			} :
  		($name =~ m{\A\!(.+)\z}) ?
  			(++$not_want->{$1}) :
  		($name =~ m{\A[:-](.+)\z}) ?
  			push(@$opts, $class->_exporter_expand_tag($1, $value, $global_opts)) :
  		($name =~ m{\A/.+/[msixpodual]+\z}) ?
  			push(@$opts, $class->_exporter_expand_regexp($name, $value, $global_opts)) :
  		# else ?
  			push(@$want, $opt);
  	}
  };
  
  sub import
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { no strict qw(refs); @_ ? @_ : @{"$class\::EXPORT"} };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_opts($global_opts);
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		my %symbols = $class->_exporter_expand_sub(@$wanted, $global_opts, $permitted);
  		$class->_exporter_install_sub($_, $wanted->[1], $global_opts, $symbols{$_})
  			for keys %symbols;
  	}
  }
  
  sub unimport
  {
  	my $class = shift;
  	my $global_opts = +{ @_ && ref($_[0]) eq q(HASH) ? %{+shift} : () };
  	$global_opts->{into} = caller unless exists $global_opts->{into};
  	$global_opts->{is_unimport} = 1;
  	
  	my @want;
  	my %not_want; $global_opts->{not} = \%not_want;
  	my @args = do { our %TRACKED; @_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}}) };
  	my $opts = mkopt(\@args);
  	$class->$_process_optlist($global_opts, $opts, \@want, \%not_want);
  	
  	my $permitted = $class->_exporter_permitted_regexp($global_opts);
  	$class->_exporter_validate_unimport_opts($global_opts);
  	
  	my $expando = $class->can('_exporter_expand_sub');
  	$expando = undef if $expando == \&_exporter_expand_sub;
  	
  	for my $wanted (@want)
  	{
  		next if $not_want{$wanted->[0]};
  		
  		if ($wanted->[1])
  		{
  			_carp("Passing options to unimport '%s' makes no sense", $wanted->[0])
  				unless (ref($wanted->[1]) eq 'HASH' and not keys %{$wanted->[1]});
  		}
  		
  		my %symbols = defined($expando)
  			? $class->$expando(@$wanted, $global_opts, $permitted)
  			: ($wanted->[0] => sub { "dummy" });
  		$class->_exporter_uninstall_sub($_, $wanted->[1], $global_opts)
  			for keys %symbols;
  	}
  }
  
  # Called once per import/unimport, passed the "global" import options.
  # Expected to validate the options and carp or croak if there are problems.
  # Can also take the opportunity to do other stuff if needed.
  #
  sub _exporter_validate_opts          { 1 }
  sub _exporter_validate_unimport_opts { 1 }
  
  # Called after expanding a tag or regexp to merge the tag's options with
  # any sub-specific options.
  #
  sub _exporter_merge_opts
  {
  	my $class = shift;
  	my ($tag_opts, $global_opts, @stuff) = @_;
  	
  	$tag_opts = {} unless ref($tag_opts) eq q(HASH);
  	_croak('Cannot provide an -as option for tags')
  		if exists $tag_opts->{-as} && ref $tag_opts->{-as} ne 'CODE';
  	
  	my $optlist = mkopt(\@stuff);
  	for my $export (@$optlist)
  	{
  		next if defined($export->[1]) && ref($export->[1]) ne q(HASH);
  		
  		my %sub_opts = ( %{ $export->[1] or {} }, %$tag_opts );
  		$sub_opts{-prefix} = sprintf('%s%s', $tag_opts->{-prefix}, $export->[1]{-prefix})
  			if exists($export->[1]{-prefix}) && exists($tag_opts->{-prefix});
  		$sub_opts{-suffix} = sprintf('%s%s', $export->[1]{-suffix}, $tag_opts->{-suffix})
  			if exists($export->[1]{-suffix}) && exists($tag_opts->{-suffix});
  		$export->[1] = \%sub_opts;
  	}
  	return @$optlist;
  }
  
  # Given a tag name, looks it up in %EXPORT_TAGS and returns the list of
  # associated functions. The default implementation magically handles tags
  # "all" and "default". The default implementation interprets any undefined
  # tags as being global options.
  # 
  sub _exporter_expand_tag
  {
  	no strict qw(refs);
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $tags  = \%{"$class\::EXPORT_TAGS"};
  	
  	return $class->_exporter_merge_opts($value, $globals, $tags->{$name}->($class, @_))
  		if ref($tags->{$name}) eq q(CODE);
  	
  	return $class->_exporter_merge_opts($value, $globals, @{$tags->{$name}})
  		if exists $tags->{$name};
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"})
  		if $name eq 'all';
  	
  	return $class->_exporter_merge_opts($value, $globals, @{"$class\::EXPORT"})
  		if $name eq 'default';
  	
  	$globals->{$name} = $value || 1;
  	return;
  }
  
  # Given a regexp-like string, looks it up in @EXPORT_OK and returns the
  # list of matching functions.
  # 
  sub _exporter_expand_regexp
  {
  	no strict qw(refs);
  	our %TRACKED;
  	
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	my $compiled = eval("qr$name");
  	
  	my @possible = $globals->{is_unimport}
  		? keys( %{$TRACKED{$class}{$globals->{into}}} )
  		: @{"$class\::EXPORT_OK"};
  	
  	$class->_exporter_merge_opts($value, $globals, grep /$compiled/, @possible);
  }
  
  # Helper for _exporter_expand_sub. Returns a regexp matching all subs in
  # the exporter package which are available for export.
  #
  sub _exporter_permitted_regexp
  {
  	no strict qw(refs);
  	my $class = shift;
  	my $re = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} @{"$class\::EXPORT"}, @{"$class\::EXPORT_OK"};
  	qr{^(?:$re)$}ms;
  }
  
  # Given a sub name, returns a hash of subs to install (usually just one sub).
  # Keys are sub names, values are coderefs.
  #
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	$permitted ||= $class->_exporter_permitted_regexp($globals);
  	
  	no strict qw(refs);
  	
  	if ($name =~ $permitted)
  	{
  		my $generator = $class->can("_generate_$name");
  		return $name => $class->$generator($name, $value, $globals) if $generator;
  		
  		my $sub = $class->can($name);
  		return $name => $sub if $sub;
  	}
  	
  	$class->_exporter_fail(@_);
  }
  
  # Called by _exporter_expand_sub if it is unable to generate a key-value
  # pair for a sub.
  #
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	return if $globals->{is_unimport};
  	_croak("Could not find sub '%s' exported by %s", $name, $class);
  }
  
  # Actually performs the installation of the sub into the target package. This
  # also handles renaming the sub.
  #
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $into      = $globals->{into};
  	my $installer = $globals->{installer} || $globals->{exporter};
  	
  	$name =
  		ref    $globals->{as} ? $globals->{as}->($name) :
  		ref    $value->{-as}  ? $value->{-as}->($name) :
  		exists $value->{-as}  ? $value->{-as} :
  		$name;
  	
  	return unless defined $name;
  	
  	unless (ref($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		$name = "$prefix$name$suffix";
  	}
  	
  	return ($$name = $sym)         if ref($name) eq q(SCALAR);
  	return ($into->{$name} = $sym) if ref($into) eq q(HASH);
  	
  	no strict qw(refs);
  	
  	if (exists &{"$into\::$name"} and \&{"$into\::$name"} != $sym)
  	{
  		my ($level) = grep defined, $value->{-replace}, $globals->{replace}, q(0);
  		my $action = {
  			carp     => \&_carp,
  			0        => \&_carp,
  			''       => \&_carp,
  			warn     => \&_carp,
  			nonfatal => \&_carp,
  			croak    => \&_croak,
  			fatal    => \&_croak,
  			die      => \&_croak,
  		}->{$level} || sub {};
  		
  		$action->(
  			$action == \&_croak
  				? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s"
  				: "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",
  			$into,
  			$name,
  			$_[0],
  			$class,
  		);
  	}
  	
  	our %TRACKED;
  	$TRACKED{$class}{$into}{$name} = $sym;
  	
  	no warnings qw(prototype);
  	$installer
  		? $installer->($globals, [$name, $sym])
  		: (*{"$into\::$name"} = $sym);
  }
  
  sub _exporter_uninstall_sub
  {
  	our %TRACKED;
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	my $into = $globals->{into};
  	ref $into and return;
  	
  	no strict qw(refs);
  	
  	# Cowardly refuse to uninstall a sub that differs from the one
  	# we installed!
  	my $our_coderef = $TRACKED{$class}{$into}{$name};
  	my $cur_coderef = exists(&{"$into\::$name"}) ? \&{"$into\::$name"} : -1;
  	return unless $our_coderef == $cur_coderef;
  	
  	my $stash     = \%{"$into\::"};
  	my $old       = delete $stash->{$name};
  	my $full_name = join('::', $into, $name);
  	foreach my $type (qw(SCALAR HASH ARRAY IO)) # everything but the CODE
  	{
  		next unless defined(*{$old}{$type});
  		*$full_name = *{$old}{$type};
  	}
  	
  	delete $TRACKED{$class}{$into}{$name};
  }
  
  sub mkopt
  {
  	my $in = shift or return [];
  	my @out;
  	
  	$in = [map(($_ => ref($in->{$_}) ? $in->{$_} : ()), sort keys %$in)]
  		if ref($in) eq q(HASH);
  	
  	for (my $i = 0; $i < @$in; $i++)
  	{
  		my $k = $in->[$i];
  		my $v;
  		
  		($i == $#$in)         ? ($v = undef) :
  		!defined($in->[$i+1]) ? (++$i, ($v = undef)) :
  		!ref($in->[$i+1])     ? ($v = undef) :
  		($v = $in->[++$i]);
  		
  		push @out, [ $k => $v ];
  	}
  	
  	\@out;
  }
  
  sub mkopt_hash
  {
  	my $in  = shift or return;
  	my %out = map +($_->[0] => $_->[1]), @{ mkopt($in) };
  	\%out;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords frobnicate greps regexps
  
  =head1 NAME
  
  Exporter::Tiny - an exporter with the features of Sub::Exporter but only core dependencies
  
  =head1 SYNOPSIS
  
     package MyUtils;
     use base "Exporter::Tiny";
     our @EXPORT = qw(frobnicate);
     sub frobnicate { ... }
     1;
  
     package MyScript;
     use MyUtils "frobnicate" => { -as => "frob" };
     print frob(42);
     exit;
  
  =head1 DESCRIPTION
  
  Exporter::Tiny supports many of Sub::Exporter's external-facing features
  including renaming imported functions with the C<< -as >>, C<< -prefix >> and
  C<< -suffix >> options; explicit destinations with the C<< into >> option;
  and alternative installers with the C<< installer >> option. But it's written
  in only about 40% as many lines of code and with zero non-core dependencies.
  
  Its internal-facing interface is closer to Exporter.pm, with configuration
  done through the C<< @EXPORT >>, C<< @EXPORT_OK >> and C<< %EXPORT_TAGS >>
  package variables.
  
  If you are trying to B<write> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::QuickStart>
  
  =item *
  
  L<Exporter::Tiny::Manual::Exporting>
  
  =back
  
  If you are trying to B<use> a module that inherits from Exporter::Tiny,
  then look at:
  
  =over
  
  =item *
  
  L<Exporter::Tiny::Manual::Importing>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Exporter-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  Simplified interface to this module: L<Exporter::Shiny>.
  
  Other interesting exporters: L<Sub::Exporter>, L<Exporter>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
EXPORTER_TINY

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use strict;
  use warnings;
  use Exporter   ();
  use File::Spec ();
  
  # ABSTRACT: Perl implementation of the which utility as an API
  our $VERSION = '1.22'; # VERSION
  
  
  our @ISA       = 'Exporter';
  our @EXPORT    = 'which';
  our @EXPORT_OK = 'where';
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  use constant IS_CYG => ($^O eq 'cygwin' || $^O eq 'msys');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
    # WinNT. PATHEXT might be set on Cygwin, but not used.
    if ( $ENV{PATHEXT} ) {
      push @PATHEXT, split ';', $ENV{PATHEXT};
    } else {
      # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
      push @PATHEXT, qw{.com .exe .bat};
    }
  } elsif ( IS_VMS ) {
    push @PATHEXT, qw{.exe .com};
  } elsif ( IS_CYG ) {
    # See this for more info
    # http://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-exe
    push @PATHEXT, qw{.exe .com};
  }
  
  
  sub which {
    my ($exec) = @_;
  
    return undef unless defined $exec;
    return undef if $exec eq '';
  
    my $all = wantarray;
    my @results = ();
  
    # check for aliases first
    if ( IS_VMS ) {
      my $symbol = `SHOW SYMBOL $exec`;
      chomp($symbol);
      unless ( $? ) {
        return $symbol unless $all;
        push @results, $symbol;
      }
    }
    if ( IS_MAC ) {
      my @aliases = split /\,/, $ENV{Aliases};
      foreach my $alias ( @aliases ) {
        # This has not been tested!!
        # PPT which says MPW-Perl cannot resolve `Alias $alias`,
        # let's just hope it's fixed
        if ( lc($alias) eq lc($exec) ) {
          chomp(my $file = `Alias $alias`);
          last unless $file;  # if it failed, just go on the normal way
          return $file unless $all;
          push @results, $file;
          # we can stop this loop as if it finds more aliases matching,
          # it'll just be the same result anyway
          last;
        }
      }
    }
  
    return $exec
            if !IS_VMS and !IS_MAC and !IS_DOS and $exec =~ /\// and -f $exec and -x $exec;
  
    my @path = File::Spec->path;
    if ( IS_DOS or IS_VMS or IS_MAC ) {
      unshift @path, File::Spec->curdir;
    }
  
    foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
      for my $ext ( @PATHEXT ) {
        my $file = $base.$ext;
  
        # We don't want dirs (as they are -x)
        next if -d $file;
  
        if (
          # Executable, normal case
          -x _
          or (
            # MacOS doesn't mark as executable so we check -e
            IS_MAC
            ||
            (
              ( IS_DOS or IS_CYG )
              and
              grep {
                $file =~ /$_\z/i
              } @PATHEXT[1..$#PATHEXT]
            )
            # DOSish systems don't pass -x on
            # non-exe/bat/com files. so we check -e.
            # However, we don't want to pass -e on files
            # that aren't in PATHEXT, like README.
            and -e _
          )
        ) {
          return $file unless $all;
          push @results, $file;
        }
      }
    }
  
    if ( $all ) {
      return @results;
    } else {
      return undef;
    }
  }
  
  
  sub where {
    # force wantarray
    my @res = which($_[0]);
    return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Which - Perl implementation of the which utility as an API
  
  =head1 VERSION
  
  version 1.22
  
  =head1 SYNOPSIS
  
   use File::Which;                  # exports which()
   use File::Which qw(which where);  # exports which() and where()
   
   my $exe_path = which 'perldoc';
   
   my @paths = where 'perl';
   # Or
   my @paths = which 'perl'; # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  L<File::Which> finds the full or relative paths to executable programs on
  the system.  This is normally the function of C<which> utility.  C<which> is
  typically implemented as either a program or a built in shell command.  On
  some platforms, such as Microsoft Windows it is not provided as part of the
  core operating system.  This module provides a consistent API to this
  functionality regardless of the underlying platform.
  
  The focus of this module is correctness and portability.  As a consequence
  platforms where the current directory is implicitly part of the search path
  such as Microsoft Windows will find executables in the current directory,
  whereas on platforms such as UNIX where this is not the case executables 
  in the current directory will only be found if the current directory is
  explicitly added to the path.
  
  If you need a portable C<which> on the command line in an environment that
  does not provide it, install L<App::pwhich> which provides a command line
  interface to this API.
  
  =head2 Implementations
  
  L<File::Which> searches the directories of the user's C<PATH> (the current
  implementation uses L<File::Spec#path> to determine the correct C<PATH>),
  looking for executable files having the name specified as a parameter to
  L</which>. Under Win32 systems, which do not have a notion of directly
  executable files, but uses special extensions such as C<.exe> and C<.bat>
  to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head3 Linux, *BSD and other UNIXes
  
  There should not be any surprises here.  The current directory will not be
  searched unless it is explicitly added to the path.
  
  =head3 Modern Windows (including NT, XP, Vista, 7, 8, 10 etc)
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head3 Cygwin
  
  Cygwin provides a Unix-like environment for Microsoft Windows users.  In most
  ways it works like other Unix and Unix-like environments, but in a few key
  aspects it works like Windows.  As with other Unix environments, the current
  directory is not included in the search unless it is explicitly included in
  the search path.  Like on Windows, files with C<.EXE> or <.BAT> extensions will
  be discovered even if they are not part of the query.  C<.COM> or extensions
  specified using the C<PATHEXT> environment variable will NOT be discovered
  without the fully qualified name, however.
  
  =head3 Windows 95, 98, ME, MS-DOS, OS/2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  As of 2015 none of these platforms are tested frequently (or perhaps ever),
  but the current maintainer is determined not to intentionally remove support
  for older operating systems.
  
  =head3 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  As of 2015 the current maintainer does not test on VMS, and is in fact not
  certain it has ever been tested on VMS.  If this platform is important to you
  and you can help me verify and or support it on that platform please contact
  me.
  
  =head1 FUNCTIONS
  
  =head2 which
  
   my $path = which $short_exe_name;
   my @paths = which $short_exe_name;
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where
  
   my @paths = where $short_exe_name;
  
  Not exported by default.
  
  Same as L</which> in array context. Same as the
  C<where> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 CAVEATS
  
  This module has no non-core requirements for Perl 5.6.2 and better.
  
  This module is fully supported back to Perl 5.8.1.  It may work on 5.8.0.  
  It should work on Perl 5.6.x and I may even test on 5.6.2.  I will accept
  patches to maintain compatibility for such older Perls, but you may
  need to fix it on 5.6.x / 5.8.0 and send me a patch.
  
  Not tested on VMS although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  =head1 SUPPORT
  
  Bugs should be reported via the GitHub issue tracker
  
  L<https://github.com/plicease/File-Which/issues>
  
  For other issues, contact the maintainer.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<pwhich>, L<App::pwhich>
  
  Command line interface to this module.
  
  =item L<IPC::Cmd>
  
  Comes with a C<can_run> function with slightly different semantics that
  the traditional UNIX where.  It will find executables in the current
  directory, even though the current directory is not searched for by
  default on Unix.
  
  =item L<Devel::CheckBin>
  
  This module purports to "check that a command is available", but does not
  provide any documentation on how you might use it.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Per Einar Ellefsen <pereinar@cpan.org>
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2002 by Per Einar Ellefsen <pereinar@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;
  use warnings;
  
  package File::pushd;
  # ABSTRACT: change directory temporarily for a limited scope
  
  our $VERSION = '1.014';
  
  our @EXPORT = qw( pushd tempd );
  our @ISA    = qw( Exporter );
  
  use Exporter;
  use Carp;
  use Cwd qw( getcwd abs_path );
  use File::Path qw( rmtree );
  use File::Temp qw();
  use File::Spec;
  
  use overload
    q{""}    => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
    fallback => 1;
  
  #--------------------------------------------------------------------------#
  # pushd()
  #--------------------------------------------------------------------------#
  
  sub pushd {
      # Called in void context?
      unless (defined wantarray) {
          warnings::warnif(void => 'Useless use of File::pushd::pushd in void context');
          return
      }
  
      my ( $target_dir, $options ) = @_;
      $options->{untaint_pattern} ||= qr{^([-+@\w./]+)$};
  
      $target_dir = "." unless defined $target_dir;
      croak "Can't locate directory $target_dir" unless -d $target_dir;
  
      my $tainted_orig = getcwd;
      my $orig;
      if ( $tainted_orig =~ $options->{untaint_pattern} ) {
          $orig = $1;
      }
      else {
          $orig = $tainted_orig;
      }
  
      my $tainted_dest;
      eval { $tainted_dest = $target_dir ? abs_path($target_dir) : $orig };
      croak "Can't locate absolute path for $target_dir: $@" if $@;
  
      my $dest;
      if ( $tainted_dest =~ $options->{untaint_pattern} ) {
          $dest = $1;
      }
      else {
          $dest = $tainted_dest;
      }
  
      if ( $dest ne $orig ) {
          chdir $dest or croak "Can't chdir to $dest\: $!";
      }
  
      my $self = bless {
          _pushd    => $dest,
          _original => $orig
        },
        __PACKAGE__;
  
      return $self;
  }
  
  #--------------------------------------------------------------------------#
  # tempd()
  #--------------------------------------------------------------------------#
  
  sub tempd {
      # Called in void context?
      unless (defined wantarray) {
          warnings::warnif(void => 'Useless use of File::pushd::tempd in void context');
          return
      }
  
      my ($options) = @_;
      my $dir;
      eval { $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ), $options ) };
      croak $@ if $@;
      $dir->{_tempd} = 1;
      return $dir;
  }
  
  #--------------------------------------------------------------------------#
  # preserve()
  #--------------------------------------------------------------------------#
  
  sub preserve {
      my $self = shift;
      return 1 if !$self->{"_tempd"};
      if ( @_ == 0 ) {
          return $self->{_preserve} = 1;
      }
      else {
          return $self->{_preserve} = $_[0] ? 1 : 0;
      }
  }
  
  #--------------------------------------------------------------------------#
  # DESTROY()
  # Revert to original directory as object is destroyed and cleanup
  # if necessary
  #--------------------------------------------------------------------------#
  
  sub DESTROY {
      my ($self) = @_;
      my $orig = $self->{_original};
      chdir $orig if $orig; # should always be so, but just in case...
      if ( $self->{_tempd}
          && !$self->{_preserve} )
      {
          # don't destroy existing $@ if there is no error.
          my $err = do {
              local $@;
              eval { rmtree( $self->{_pushd} ) };
              $@;
          };
          carp $err if $err;
      }
  }
  
  1;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::pushd - change directory temporarily for a limited scope
  
  =head1 VERSION
  
  version 1.014
  
  =head1 SYNOPSIS
  
   use File::pushd;
  
   chdir $ENV{HOME};
  
   # change directory again for a limited scope
   {
       my $dir = pushd( '/tmp' );
       # working directory changed to /tmp
   }
   # working directory has reverted to $ENV{HOME}
  
   # tempd() is equivalent to pushd( File::Temp::tempdir )
   {
       my $dir = tempd();
   }
  
   # object stringifies naturally as an absolute path
   {
      my $dir = pushd( '/tmp' );
      my $filename = File::Spec->catfile( $dir, "somefile.txt" );
      # gives /tmp/somefile.txt
   }
  
  =head1 DESCRIPTION
  
  File::pushd does a temporary C<chdir> that is easily and automatically
  reverted, similar to C<pushd> in some Unix command shells.  It works by
  creating an object that caches the original working directory.  When the object
  is destroyed, the destructor calls C<chdir> to revert to the original working
  directory.  By storing the object in a lexical variable with a limited scope,
  this happens automatically at the end of the scope.
  
  This is very handy when working with temporary directories for tasks like
  testing; a function is provided to streamline getting a temporary
  directory from L<File::Temp>.
  
  For convenience, the object stringifies as the canonical form of the absolute
  pathname of the directory entered.
  
  B<Warning>: if you create multiple C<pushd> objects in the same lexical scope,
  their destruction order is not guaranteed and you might not wind up in the
  directory you expect.
  
  =head1 USAGE
  
   use File::pushd;
  
  Using File::pushd automatically imports the C<pushd> and C<tempd> functions.
  
  =head2 pushd
  
   {
       my $dir = pushd( $target_directory );
   }
  
  Caches the current working directory, calls C<chdir> to change to the target
  directory, and returns a File::pushd object.  When the object is
  destroyed, the working directory reverts to the original directory.
  
  The provided target directory can be a relative or absolute path. If
  called with no arguments, it uses the current directory as its target and
  returns to the current directory when the object is destroyed.
  
  If the target directory does not exist or if the directory change fails
  for some reason, C<pushd> will die with an error message.
  
  Can be given a hashref as an optional second argument.  The only supported
  option is C<untaint_pattern>, which is used to untaint file paths involved.
  It defaults to {qr{^(L<-+@\w./>+)$}}, which is reasonably restrictive (e.g.
  it does not even allow spaces in the path).  Change this to suit your
  circumstances and security needs if running under taint mode. *Note*: you
  must include the parentheses in the pattern to capture the untainted
  portion of the path.
  
  =head2 tempd
  
   {
       my $dir = tempd();
   }
  
  This function is like C<pushd> but automatically creates and calls C<chdir> to
  a temporary directory created by L<File::Temp>. Unlike normal L<File::Temp>
  cleanup which happens at the end of the program, this temporary directory is
  removed when the object is destroyed. (But also see C<preserve>.)  A warning
  will be issued if the directory cannot be removed.
  
  As with C<pushd>, C<tempd> will die if C<chdir> fails.
  
  It may be given a single options hash that will be passed internally
  to C<pushd>.
  
  =head2 preserve
  
   {
       my $dir = tempd();
       $dir->preserve;      # mark to preserve at end of scope
       $dir->preserve(0);   # mark to delete at end of scope
   }
  
  Controls whether a temporary directory will be cleaned up when the object is
  destroyed.  With no arguments, C<preserve> sets the directory to be preserved.
  With an argument, the directory will be preserved if the argument is true, or
  marked for cleanup if the argument is false.  Only C<tempd> objects may be
  marked for cleanup.  (Target directories to C<pushd> are always preserved.)
  C<preserve> returns true if the directory will be preserved, and false
  otherwise.
  
  =head1 DIAGNOSTICS
  
  C<pushd> and C<tempd> warn with message
  C<"Useless use of File::pushd::I<%s> in void context"> if called in
  void context and the warnings category C<void> is enabled.
  
    {
      use warnings 'void';
  
      pushd();
    }
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<File::chdir>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/File-pushd/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/File-pushd>
  
    git clone https://github.com/dagolden/File-pushd.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Diab Jerius Graham Ollis Olivier Mengué
  
  =over 4
  
  =item *
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2016 by David A Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
  
  __END__
  
  
  # vim: ts=4 sts=4 sw=4 et:
FILE_PUSHD

$fatpacked{"Getopt/Long/Subcommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG_SUBCOMMAND';
  package Getopt::Long::Subcommand;
  
  our $DATE = '2017-08-12'; # DATE
  our $VERSION = '0.102'; # VERSION
  
  use 5.010001;
  use strict;
  use warnings;
  #use Log::ger;
  
  require Exporter;
  our @ISA = qw(Exporter);
  ## no critic (Modules::ProhibitAutomaticExportation)
  our @EXPORT = qw(
                      GetOptions
              );
  ## use critic
  
  # XXX completion & configure are actually only allowed at the top-level
  my @known_cmdspec_keys = qw(
      options
      subcommands
      default_subcommand
      summary description
      completion
      configure
  );
  
  sub _cmdspec_opts_to_gl_ospec {
      my ($cmdspec_opts, $is_completion, $res) = @_;
      return { map {
          if ($is_completion) {
              # we don't want side-effects during completion (handler printing or
              # existing, etc), so we set an empty coderef for all handlers.
              ($_ => sub{});
          } else {
              my $k = $_;
              my $v = $cmdspec_opts->{$k};
              my $handler = ref($v) eq 'HASH' ? $v->{handler} : $v;
              if (ref($handler) eq 'CODE') {
                  my $orig_handler = $handler;
                  $handler = sub {
                      my ($cb, $val) = @_;
                      $orig_handler->($cb, $val, $res);
                  };
              }
              ($k => $handler);
          }
      } keys %$cmdspec_opts };
  }
  
  sub _gl_getoptions {
      require Getopt::Long;
  
      my ($ospec, $configure, $pass_through, $res) = @_;
  
      my @configure = @{
          $configure //
              ['no_ignore_case', 'no_getopt_compat', 'gnu_compat', 'bundling']
          };
      if ($pass_through) {
          push @configure, 'pass_through'
              unless grep { $_ eq 'pass_through' } @configure;
      } else {
          @configure = grep { $_ ne 'pass_through' } @configure;
      }
      #log_trace('[comp][glsubc] Performing Getopt::Long::GetOptions (configure: %s)',
      #          $pass_through, \@configure);
  
      my $old_conf = Getopt::Long::Configure(@configure);
      local $SIG{__WARN__} = sub {} if $pass_through;
  
      # ugh, this is ugly. the problem we're trying to solve: in the case of 'subc
      # --help', 'subc' is consumed first by Getopt::Long and thus removed from
      # @ARGV. when --help handler wants to find out the subcommand name ('subc'),
      # it doesn't have anywhere to look for. so we give it in $res which is
      # passed as the third argument to the handler.
      local $res->{_non_options_argv} = [];
  
      #log_trace('[comp][glsubc] @ARGV before Getopt::Long::GetOptions: %s', \@ARGV);
      #log_trace('[comp][glsubc] spec for Getopt::Long::GetOptions: %s', $ospec);
      my $gl_res = Getopt::Long::GetOptions(
          %$ospec,
          '<>' => sub { push @{ $res->{_non_options_argv} }, $_[0] },
      );
      @ARGV = @{ $res->{_non_options_argv} };
  
      #log_trace('[comp][glsubc] @ARGV after Getopt::Long::GetOptions: %s', \@ARGV);
      Getopt::Long::Configure($old_conf);
      $gl_res;
  }
  
  sub _GetOptions {
      my ($cmdspec, $is_completion, $res, $stash) = @_;
  
      $res //= {success=>undef};
      $stash //= {
          path => '', # for displaying error message
          level => 0,
      };
  
      # check command spec
      {
          #log_trace("[comp][glsubc] Checking cmdspec keys: %s", [keys %$cmdspec]);
          for my $k (keys %$cmdspec) {
              (grep { $_ eq $k } @known_cmdspec_keys)
                  or die "Unknown command specification key '$k'" .
                      ($stash->{path} ? " (under $stash->{path})" : "") . "\n";
          }
      }
  
      my $has_subcommands = $cmdspec->{subcommands} &&
          keys(%{$cmdspec->{subcommands}});
      #log_trace("TMP:has_subcommands=%s", $has_subcommands);
      my $pass_through = $has_subcommands || $is_completion;
  
      my $ospec = _cmdspec_opts_to_gl_ospec(
          $cmdspec->{options}, $is_completion, $res);
      unless (_gl_getoptions(
          $ospec, $cmdspec->{configure}, $pass_through, $res)) {
          $res->{success} = 0;
          return $res;
      }
  
      # for doing completion
      if ($is_completion) {
          $res->{comp_ospec} //= {};
          for (keys %$ospec) {
              $res->{comp_ospec}{$_} = $ospec->{$_};
          }
      }
  
      if ($has_subcommands) {
          # for doing completion of subcommand names
          if ($is_completion) {
              $res->{comp_subcommand_names}[$stash->{level}] =
                  [sort keys %{$cmdspec->{subcommands}}];
          }
  
          $res->{subcommand} //= [];
  
          my $push;
          my $sc_name;
  
          if (defined $res->{subcommand}[ $stash->{level} ]) {
              # subcommand has been set, e.g. by option handler
              $sc_name = $res->{subcommand}[ $stash->{level} ];
          } elsif (@ARGV) {
              $sc_name = shift @ARGV;
              $push++; # we need to push to $res->{subcommand} later
          } elsif (defined $cmdspec->{default_subcommand}) {
              $sc_name = $cmdspec->{default_subcommand};
              $push++;
          } else {
              # no subcommand
              $res->{success} = 1;
              return $res;
          }
  
          # for doing completion of subcommand names
          if ($is_completion) {
              push @{ $res->{comp_subcommand_name} }, $sc_name;
          }
  
          my $sc_spec = $cmdspec->{subcommands}{$sc_name};
          unless ($sc_spec) {
              warn "Unknown subcommand '$sc_name'".
                  ($stash->{path} ? " for $stash->{path}":"")."\n"
                      unless $is_completion;
              $res->{success} = 0;
              return $res;
          };
          push @{ $res->{subcommand} }, $sc_name if $push;
          local $stash->{path} = ($stash->{path} ? "/" : "") . $sc_name;
          local $stash->{level} = $stash->{level}+1;
          _GetOptions($sc_spec, $is_completion, $res, $stash);
      }
      $res->{success} //= 1;
  
      #log_trace('[comp][glsubc] Final @ARGV: %s', \@ARGV) unless $stash->{path};
      #log_trace('[comp][glsubc] TMP: stash=%s', $stash);
      #log_trace('[comp][glsubc] TMP: res=%s', $res);
      $res;
  }
  
  sub GetOptions {
      my %cmdspec = @_;
  
      # figure out if we run in completion mode
      my ($is_completion, $shell, $words, $cword);
    CHECK_COMPLETION:
      {
          if ($ENV{COMP_SHELL}) {
              ($shell = $ENV{COMP_SHELL}) =~ s!.+/!!;
          } elsif ($ENV{COMMAND_LINE}) {
              $shell = 'tcsh';
          } else {
              $shell = 'bash';
          }
  
          if ($ENV{COMP_LINE} || $ENV{COMMAND_LINE}) {
              if ($ENV{COMP_LINE}) {
                  $is_completion++;
                  require Complete::Bash;
                  ($words, $cword) = @{ Complete::Bash::parse_cmdline(
                      undef, undef, {truncate_current_word=>1}) };
                  ($words, $cword) = @{ Complete::Bash::join_wordbreak_words(
                      $words, $cword) };
              } elsif ($ENV{COMMAND_LINE}) {
                  $is_completion++;
                  require Complete::Tcsh;
                  $shell = 'tcsh';
                  ($words, $cword) = @{ Complete::Tcsh::parse_cmdline() };
              } else {
                  last CHECK_COMPLETION;
              }
  
              shift @$words; $cword--; # strip program name
              @ARGV = @$words;
          }
      }
  
      my $res = _GetOptions(\%cmdspec, $is_completion);
  
      if ($is_completion) {
          my $ospec = $res->{comp_ospec};
          require Complete::Getopt::Long;
          my $compres = Complete::Getopt::Long::complete_cli_arg(
              words => $words, cword => $cword, getopt_spec=>$ospec,
              extras => {
                  stash => $res->{stash},
              },
              bundling => do {
                  if (!$cmdspec{configure}) {
                      1;
                  } elsif (grep { $_ eq 'bundling' } @{ $cmdspec{configure} }) {
                      1;
                  } elsif (grep { $_ eq 'no_bundling' } @{ $cmdspec{configure} }) {
                      0;
                  } else {
                      0;
                  }
              },
              completion => sub {
                  my %args = @_;
  
                  my $word  = $args{word} // '';
                  my $type  = $args{type};
                  my $stash = $args{stash};
  
                  # complete subcommand names
                  if ($type eq 'arg' &&
                          $args{argpos} < @{$res->{comp_subcommand_names}//[]}) {
                      require Complete::Util;
                      return Complete::Util::complete_array_elem(
                          array => $res->{comp_subcommand_names}[$args{argpos}],
                          word  => $res->{comp_subcommand_name}[$args{argpos}],
                      );
                  }
  
                  $args{getopt_res} = $res;
                  $args{subcommand} = $res->{comp_subcommand_name};
                  $cmdspec{completion}->(%args) if $cmdspec{completion};
              },
          );
  
          if ($shell eq 'bash') {
              print Complete::Bash::format_completion($compres);
          } elsif ($shell eq 'tcsh') {
              print Complete::Tcsh::format_completion($compres);
          } else {
              die "Unknown shell '$shell'";
          }
  
          exit 0;
      }
  
      # cleanup unneeded details
      $res;
  }
  
  1;
  # ABSTRACT: Process command-line options, with subcommands and completion
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Getopt::Long::Subcommand - Process command-line options, with subcommands and completion
  
  =head1 VERSION
  
  This document describes version 0.102 of Getopt::Long::Subcommand (from Perl distribution Getopt-Long-Subcommand), released on 2017-08-12.
  
  =head1 SYNOPSIS
  
   use Getopt::Long::Subcommand; # exports GetOptions
  
   my %opts;
   my $res = GetOptions(
  
       summary => 'Summary about your program ...',
  
       # common options recognized by all subcommands
       options => {
           'help|h|?' => {
               summary => 'Display help message',
               handler => sub {
                   my ($cb, $val, $res) = @_;
                   if ($res->{subcommand}) {
                       say "Help message for $res->{subcommand} ...";
                   } else {
                       say "General help message ...";
                   }
                   exit 0;
               },
           'version|v' => {
               summary => 'Display program version',
               handler => sub {
                   say "Program version $main::VERSION";
                   exit 0;
               },
           'verbose' => {
               handler => \$opts{verbose},
           },
       },
  
       # list your subcommands here
       subcommands => {
           subcmd1 => {
               summary => 'The first subcommand',
               # subcommand-specific options
               options => {
                   'foo=i' => {
                       handler => \$opts{foo},
                   },
               },
           },
           subcmd1 => {
               summary => 'The second subcommand',
               options => {
                   'bar=s' => \$opts{bar},
                   'baz'   => \$opts{baz},
               },
           },
       },
  
       # tell how to complete option value and arguments. see
       # Getopt::Long::Complete for more details, the arguments are the same
       # except there is an additional 'subcommand' that gives the subcommand
       # name.
       completion => sub {
           my %args = @_;
           ...
       },
  
   );
   die "GetOptions failed!\n" unless $res->{success};
   say "Running subcommand $res->{subcommand} ...";
  
  To run your script:
  
   % script
   Missing subcommand
  
   % script --help
   General help message ...
  
   % script subcmd1
   Running subcommand subcmd1 ...
  
   % script subcmd1 --help
   Help message for subcmd1 ...
  
   % script --verbose subcmd2 --baz --bar val
   Running subcommand subcmd2 ...
  
   % script subcmd3
   Unknown subcommand 'subcmd3'
   GetOptions failed!
  
  =head1 DESCRIPTION
  
  This module extends L<Getopt::Long> with subcommands and tab completion ability.
  
  How parsing works: First we call C<Getopt::Long::GetOptions> with the top-level
  options, passing through unknown options if we have subcommands. Then,
  subcommand name is taken from the first argument. If subcommand has options, the
  process is repeated. So C<Getopt::Long::GetOptions> is called once at every
  level.
  
  Completion: Scripts using this module can complete themselves. Just put your
  script somewhere in your C<PATH> and run something like this in your bash shell:
  C<complete -C script-name script-name>. See also L<shcompgen> to manage
  completion scripts for multiple applications easily.
  
  How completion works: Environment variable C<COMP_LINE> or C<COMMAND_LINE> (for
  tcsh) is first checked. If it exists, we are in completion mode and C<@ARGV> is
  parsed/formed from it. We then perform parsing to get subcommand names. Finally
  we hand it off to L<Complete::Getopt::Long>.
  
  =head1 CAVEATS
  
  =head2 Common options take precedence over subcommand options
  
  Common options (e.g. C<--help>) are parsed and removed from the command-line
  first. This is done for convenience so you can do something like C<cmd subc
  --help> or C<cmd --help subc> to get help. The consequence is you cannot have a
  subcommand option with the same name as common option.
  
  Similarly, options for a subcommand takes precedence over its sub-subcommand,
  and so on.
  
  =head1 FUNCTIONS
  
  =head2 GetOptions(%cmdspec) => hash
  
  Exported by default.
  
  Process options and/or subcommand names specified in C<%cmdspec>, and remove
  them from C<@ARGV> (thus modifying it). Will warn to STDERR on errors. Actual
  command-line options parsing will be done using L<Getopt::Long>.
  
  Return hash structure, with these keys: C<success> (bool, false if parsing
  options failed e.g. unknown option/subcommand, illegal option value, etc),
  C<subcommand> (array of str, subcommand name, if there is any; nested
  subcommands will be listed in order, e.g. C<< ["sub1", "subsub1"] >>).
  
  Arguments:
  
  =over
  
  =item * summary => str
  
  Used by autohelp (not yet implemented).
  
  =item * options => hash
  
  A hash of option names and its specification. The specification is the same as
  what you would feed to L<Getopt::Long>'s C<GetOptions>.
  
  =item * subcommands => hash
  
  A hash of subcommand name and its specification. The specification looks like
  C<GetOptions> argument, with keys like C<summary>, C<options>, C<subcommands>
  (for nested subcommands).
  
  =item * default_subcommand => str
  
  Default subcommand to use if no subcommand name is set. Subcommand can be set
  using the first argument, or your option handler can also set the subcommand
  using:
  
   $_[2]{subcommand_name} = 'something';
  
  =item * configure => arrayref
  
  Custom Getopt::Long configuration. The default is:
  
   ['no_ignore_case', 'no_getopt_compat', 'gnu_compat', 'bundling']
  
  Note that even though you use custom configuration here, the tab completion
  (performed by L<Complete::Getopt::Long> only supports C<no_ignore_case>,
  C<gnu_compat>, and C<no_getopt_compat>.
  
  =back
  
  Differences with C<Getopt::Long>'s C<GetOptions>:
  
  =over
  
  =item *
  
  Accept a command/subcommand specification (C<%cmdspec>) instead of just options
  specification (C<%ospec>) like in C<Getopt::Long>).
  
  =item *
  
  This module's function returns hash instead of bool.
  
  =item *
  
  Coderefs in C<options> will receive an extra argument C<$res> which is the
  result hash (being built). So the arguments that the coderefs get is:
  
   ($callback, $value, $res)
  
  =back
  
  =head1 FAQ
  
  =head2 How to avoid modifying @ARGV? How to process from another array, like Getopt::Long's GetOptionsFromArray?
  
  Instead of adding another function, you can use C<local>.
  
   {
       local @ARGV = ['--some', 'value'];
       GetOptions(...);
   }
   # the original @ARGV is restored
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/Getopt-Long-Subcommand>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/perlancar/perl-Getopt-Long-Subcommand>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=Getopt-Long-Subcommand>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 SEE ALSO
  
  L<Getopt::Long>
  
  L<Getopt::Long::Complete>
  
  L<Perinci::CmdLine> - a more full featured command-line application framework,
  also with subcommands and completion.
  
  L<Pod::Weaver::Section::Completion::GetoptLongSubcommand>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017, 2016, 2015 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
GETOPT_LONG_SUBCOMMAND

$fatpacked{"Graph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH';
  package Graph;
  
  use strict;
  use warnings;
  
  # Need to get my head around all those redefines! -NEILB
  no warnings 'redefine';
  
  BEGIN {
      if (0) { # SET THIS TO ZERO FOR TESTING AND RELEASES!
  	$SIG{__DIE__ } = \&__carp_confess;
  	$SIG{__WARN__} = \&__carp_confess;
      }
      sub __carp_confess { require Carp; Carp::confess(@_) }
  }
  
  use Graph::AdjacencyMap qw(:flags :fields);
  
  use vars qw($VERSION);
  
  $VERSION = '0.9704';
  
  require 5.006; # Weak references are absolutely required.
  
  my $can_deep_copy_Storable =
    eval {
      require Storable;
      require B::Deparse;
      Storable->VERSION(2.05);
      B::Deparse->VERSION(0.61);
      1;
    };
  
  sub _can_deep_copy_Storable () {
      return $can_deep_copy_Storable;
  }
  
  use Graph::AdjacencyMap::Heavy;
  use Graph::AdjacencyMap::Light;
  use Graph::AdjacencyMap::Vertex;
  use Graph::UnionFind;
  use Graph::TransitiveClosure;
  use Graph::Traversal::DFS;
  use Graph::MSTHeapElem;
  use Graph::SPTHeapElem;
  use Graph::Undirected;
  
  use Heap071::Fibonacci;
  use List::Util qw(shuffle first);
  use Scalar::Util qw(weaken);
  
  use Safe;  # For deep_copy().
  
  sub _F () { 0 } # Flags.
  sub _G () { 1 } # Generation.
  sub _V () { 2 } # Vertices.
  sub _E () { 3 } # Edges.
  sub _A () { 4 } # Attributes.
  sub _U () { 5 } # Union-Find.
  sub _S () { 6 } # Successors.
  sub _P () { 7 } # Predecessors.
  
  my $Inf;
  
  BEGIN {
    if ($] >= 5.022) {
      $Inf = eval '+"Inf"';
    } else {
      local $SIG{FPE};
      eval { $Inf = exp(999) } ||
  	eval { $Inf = 9**9**9 } ||
  	    eval { $Inf = 1e+999 } ||
  		{ $Inf = 1e+99 };  # Close enough for most practical purposes.
    }
  }
  
  sub Infinity () { $Inf }
  
  # Graphs are blessed array references.
  # - The first element contains the flags.
  # - The second element is the vertices.
  # - The third element is the edges.
  # - The fourth element is the attributes of the whole graph.
  # The defined flags for Graph are:
  # - _COMPAT02 for user API compatibility with the Graph 0.20xxx series.
  # The vertices are contained in either a "simplemap"
  # (if no hypervertices) or in a "map".
  # The edges are always in a "map".
  # The defined flags for maps are:
  # - _COUNT for countedness: more than one instance
  # - _HYPER for hyperness: a different number of "coordinates" than usual;
  #   expects one for vertices and two for edges
  # - _UNORD for unordered coordinates (a set): if _UNORD is not set
  #   the coordinates are assumed to be meaningfully ordered
  # - _UNIQ for unique coordinates: if set duplicates are removed,
  #   if not, duplicates are assumed to meaningful
  # - _UNORDUNIQ: just a union of _UNORD and UNIQ
  # Vertices are assumed to be _UNORDUNIQ; edges assume none of these flags.
  
  use Graph::Attribute array => _A, map => 'graph';
  
  sub _COMPAT02 () { 0x00000001 }
  
  sub stringify {
      my $g = shift;
      my $u = $g->is_undirected;
      my $e = $u ? '=' : '-';
      my @e =
  	map {
  	    my @v =
  		map {
  		    ref($_) eq 'ARRAY' ? "[" . join(" ", @$_) . "]" : "$_"
  		}
  	    @$_;
  	    join($e, $u ? sort { "$a" cmp "$b" } @v : @v) } $g->edges05;
      my @s = sort { "$a" cmp "$b" } @e;
      push @s, sort { "$a" cmp "$b" } $g->isolated_vertices;
      join(",", @s);
  }
  
  sub eq {
      "$_[0]" eq "$_[1]"
  }
  
  sub boolify {
    1;  # Important for empty graphs: they stringify to "", which is false.
  }
  
  sub ne {
      "$_[0]" ne "$_[1]"
  }
  
  use overload
      '""' => \&stringify,
      'bool' => \&boolify,
      'eq' => \&eq,
      'ne' => \&ne;
  
  sub _opt {
      my ($opt, $flags, %flags) = @_;
      while (my ($flag, $FLAG) = each %flags) {
  	if (exists $opt->{$flag}) {
  	    $$flags |= $FLAG if $opt->{$flag};
  	    delete $opt->{$flag};
  	}
  	if (exists $opt->{my $non = "non$flag"}) {
  	    $$flags &= ~$FLAG if $opt->{$non};
  	    delete $opt->{$non};
  	}
      }
  }
  
  sub is_compat02 {
      my ($g) = @_;
      $g->[ _F ] & _COMPAT02;
  }
  
  *compat02 = \&is_compat02;
  
  sub has_union_find {
      my ($g) = @_;
      ($g->[ _F ] & _UNIONFIND) && defined $g->[ _U ];
  }
  
  sub _get_union_find {
      my ($g) = @_;
      $g->[ _U ];
  }
  
  sub _opt_get {
      my ($opt, $key, $var) = @_;
      if (exists $opt->{$key}) {
  	$$var = $opt->{$key};
  	delete $opt->{$key};
      }
  }
  
  sub _opt_unknown {
      my ($opt) = @_;
      if (my @opt = keys %$opt) {
  	my $f = (caller(1))[3];
  	require Carp;
  	Carp::confess(sprintf
  		      "$f: Unknown option%s: @{[map { qq['$_'] } sort @opt]}",
  		      @opt > 1 ? 's' : '');
      }
  }
  
  sub new {
      my $class = shift;
      my $gflags = 0;
      my $vflags;
      my $eflags;
      my %opt = _get_options( \@_ );
  
      if (ref $class && $class->isa('Graph')) {
  	no strict 'refs';
          for my $c (qw(undirected refvertexed compat02
                        hypervertexed countvertexed multivertexed
                        hyperedged countedged multiedged omniedged
  		      __stringified)) {
  #            $opt{$c}++ if $class->$c; # 5.00504-incompatible
  	    if (&{"Graph::$c"}($class)) { $opt{$c}++ }
          }
  #        $opt{unionfind}++ if $class->has_union_find; # 5.00504-incompatible
  	if (&{"Graph::has_union_find"}($class)) { $opt{unionfind}++ }
      }
  
      _opt_get(\%opt, undirected   => \$opt{omniedged});
      _opt_get(\%opt, omnidirected => \$opt{omniedged});
  
      if (exists $opt{directed}) {
  	$opt{omniedged} = !$opt{directed};
  	delete $opt{directed};
      }
  
      my $vnonomni =
  	$opt{nonomnivertexed} ||
  	    (exists $opt{omnivertexed} && !$opt{omnivertexed});
      my $vnonuniq =
  	$opt{nonuniqvertexed} ||
  	    (exists $opt{uniqvertexed} && !$opt{uniqvertexed});
  
      _opt(\%opt, \$vflags,
  	 countvertexed	=> _COUNT,
  	 multivertexed	=> _MULTI,
  	 hypervertexed	=> _HYPER,
  	 omnivertexed	=> _UNORD,
  	 uniqvertexed	=> _UNIQ,
  	 refvertexed	=> _REF,
  	 refvertexed_stringified => _REFSTR ,
  	 __stringified => _STR,
  	);
  
      _opt(\%opt, \$eflags,
  	 countedged	=> _COUNT,
  	 multiedged	=> _MULTI,
  	 hyperedged	=> _HYPER,
  	 omniedged	=> _UNORD,
  	 uniqedged	=> _UNIQ,
  	);
  
      _opt(\%opt, \$gflags,
  	 compat02      => _COMPAT02,
  	 unionfind     => _UNIONFIND,
  	);
  
      if (exists $opt{vertices_unsorted}) { # Graph 0.20103 compat.
  	my $unsorted = $opt{vertices_unsorted};
  	delete $opt{vertices_unsorted};
  	require Carp;
  	Carp::confess("Graph: vertices_unsorted must be true")
  	    unless $unsorted;
      }
  
      my @V;
      if ($opt{vertices}) {
  	require Carp;
  	Carp::confess("Graph: vertices should be an array ref")
  	    unless ref $opt{vertices} eq 'ARRAY';
  	@V = @{ $opt{vertices} };
  	delete $opt{vertices};
      }
  
      my @E;
      if ($opt{edges}) {
  	unless (ref $opt{edges} eq 'ARRAY') {
  	    require Carp;
  	    Carp::confess("Graph: edges should be an array ref of array refs");
  	}
  	@E = @{ $opt{edges} };
  	delete $opt{edges};
      }
  
      _opt_unknown(\%opt);
  
      my $uflags;
      if (defined $vflags) {
  	$uflags = $vflags;
  	$uflags |= _UNORD unless $vnonomni;
  	$uflags |= _UNIQ  unless $vnonuniq;
      } else {
  	$uflags = _UNORDUNIQ;
  	$vflags = 0;
      }
  
      if (!($vflags & _HYPER) && ($vflags & _UNORDUNIQ)) {
  	my @but;
  	push @but, 'unordered' if ($vflags & _UNORD);
  	push @but, 'unique'    if ($vflags & _UNIQ);
  	require Carp;
  	Carp::confess(sprintf "Graph: not hypervertexed but %s",
  		      join(' and ', @but));
      }
  
      unless (defined $eflags) {
  	$eflags = ($gflags & _COMPAT02) ? _COUNT : 0;
      }
  
      if (!($vflags & _HYPER) && ($vflags & _UNIQ)) {
  	require Carp;
  	Carp::confess("Graph: not hypervertexed but uniqvertexed");
      }
  
      if (($vflags & _COUNT) && ($vflags & _MULTI)) {
  	require Carp;
  	Carp::confess("Graph: both countvertexed and multivertexed");
      }
  
      if (($eflags & _COUNT) && ($eflags & _MULTI)) {
  	require Carp;
  	Carp::confess("Graph: both countedged and multiedged");
      }
  
      my $g = bless [ ], ref $class || $class;
  
      $g->[ _F ] = $gflags;
      $g->[ _G ] = 0;
      $g->[ _V ] = ($vflags & (_HYPER | _MULTI)) ?
  	Graph::AdjacencyMap::Heavy->_new($uflags, 1) :
  	    (($vflags & ~_UNORD) ?
  	     Graph::AdjacencyMap::Vertex->_new($uflags, 1) :
  	     Graph::AdjacencyMap::Light->_new($g, $uflags, 1));
      $g->[ _E ] = (($vflags & _HYPER) || ($eflags & ~_UNORD)) ?
  	Graph::AdjacencyMap::Heavy->_new($eflags, 2) :
  	    Graph::AdjacencyMap::Light->_new($g, $eflags, 2);
  
      $g->add_vertices(@V) if @V;
  
      if (@E) {
  	for my $e (@E) {
  	    unless (ref $e eq 'ARRAY') {
  		require Carp;
  		Carp::confess("Graph: edges should be array refs");
  	    }
  	    $g->add_edge(@$e);
  	}
      }
  
      if (($gflags & _UNIONFIND)) {
  	$g->[ _U ] = Graph::UnionFind->new;
      }
  
      return $g;
  }
  
  sub countvertexed { $_[0]->[ _V ]->_is_COUNT }
  sub multivertexed { $_[0]->[ _V ]->_is_MULTI }
  sub hypervertexed { $_[0]->[ _V ]->_is_HYPER }
  sub omnivertexed  { $_[0]->[ _V ]->_is_UNORD }
  sub uniqvertexed  { $_[0]->[ _V ]->_is_UNIQ  }
  sub refvertexed   { $_[0]->[ _V ]->_is_REF   }
  sub refvertexed_stringified { $_[0]->[ _V ]->_is_REFSTR }
  sub __stringified { $_[0]->[ _V ]->_is_STR   }
  
  sub countedged    { $_[0]->[ _E ]->_is_COUNT }
  sub multiedged    { $_[0]->[ _E ]->_is_MULTI }
  sub hyperedged    { $_[0]->[ _E ]->_is_HYPER }
  sub omniedged     { $_[0]->[ _E ]->_is_UNORD }
  sub uniqedged     { $_[0]->[ _E ]->_is_UNIQ  }
  
  *undirected   = \&omniedged;
  *omnidirected = \&omniedged;
  sub directed { ! $_[0]->[ _E ]->_is_UNORD }
  
  *is_directed      = \&directed;
  *is_undirected    = \&undirected;
  
  *is_countvertexed = \&countvertexed;
  *is_multivertexed = \&multivertexed;
  *is_hypervertexed = \&hypervertexed;
  *is_omnidirected  = \&omnidirected;
  *is_uniqvertexed  = \&uniqvertexed;
  *is_refvertexed   = \&refvertexed;
  *is_refvertexed_stringified = \&refvertexed_stringified;
  
  *is_countedged    = \&countedged;
  *is_multiedged    = \&multiedged;
  *is_hyperedged    = \&hyperedged;
  *is_omniedged     = \&omniedged;
  *is_uniqedged     = \&uniqedged;
  
  sub _union_find_add_vertex {
      my ($g, $v) = @_;
      my $UF = $g->[ _U ];
      $UF->add( $g->[ _V ]->_get_path_id( $v ) );
  }
  
  sub add_vertex {
      my $g = shift;
      if (@_ != 1) {
        $g->expect_hypervertexed;
      }
      if ($g->is_multivertexed) {
  	return $g->add_vertex_by_id(@_, _GEN_ID);
      }
      my @r;
      if (@_ > 1) {
  	unless ($g->is_countvertexed || $g->is_hypervertexed) {
  	    require Carp;
  	    Carp::croak("Graph::add_vertex: use add_vertices for more than one vertex or use hypervertexed");
  	}
  	for my $v ( @_ ) {
  	    if (defined $v) {
  		$g->[ _V ]->set_path( $v ) unless $g->has_vertex( $v );
  	    } else {
  		require Carp;
  		Carp::croak("Graph::add_vertex: undef vertex");
  	    }
  	}
      }
      for my $v ( @_ ) {
  	unless (defined $v) {
  	    require Carp;
  	    Carp::croak("Graph::add_vertex: undef vertex");
  	}
      }
      $g->[ _V ]->set_path( @_ );
      $g->[ _G ]++;
      $g->_union_find_add_vertex( @_ ) if $g->has_union_find;
      return $g;
  }
  
  sub has_vertex {
      my $g = shift;
      my $V = $g->[ _V ];
      return exists $V->[ _s ]->{ $_[0] } if ($V->[ _f ] & _LIGHT);
      $V->has_path( @_ );
  }
  
  sub vertices05 {
      my $g = shift;
      my @v = $g->[ _V ]->paths( @_ );
      if (wantarray) {
  	return $g->[ _V ]->_is_HYPER ?
  	    @v : map { ref $_ eq 'ARRAY' ? @$_ : $_ } @v;
      } else {
  	return scalar @v;
      }
  }
  
  sub vertices {
      my $g = shift;
      my @v = $g->vertices05;
      if ($g->is_compat02) {
          wantarray ? sort @v : scalar @v;
      } else {
  	if ($g->is_multivertexed || $g->is_countvertexed) {
  	    if (wantarray) {
  		my @V;
  		for my $v ( @v ) {
  		    push @V, ($v) x $g->get_vertex_count($v);
  		}
  		return @V;
  	    } else {
  		my $V = 0;
  		for my $v ( @v ) {
  		    $V += $g->get_vertex_count($v);
  		}
  		return $V;
  	    }
  	} else {
  	    return @v;
  	}
      }
  }
  
  *vertices_unsorted = \&vertices_unsorted; # Graph 0.20103 compat.
  
  sub unique_vertices {
      my $g = shift;
      my @v = $g->vertices05;
      if ($g->is_compat02) {
          wantarray ? sort @v : scalar @v;
      } else {
  	return @v;
      }
  }
  
  sub has_vertices {
      my $g = shift;
      scalar $g->[ _V ]->has_paths( @_ );
  }
  
  sub _add_edge {
      my $g = shift;
      my $V = $g->[ _V ];
      my @e;
      if (($V->[ _f ]) & _LIGHT) {
  	for my $v ( @_ ) {
  	    $g->add_vertex( $v ) unless exists $V->[ _s ]->{ $v };
  	    push @e, $V->[ _s ]->{ $v };
  	}
      } else {
  	my $h = $g->[ _V ]->_is_HYPER;
  	for my $v ( @_ ) {
  	    my @v = ref $v eq 'ARRAY' && $h ? @$v : $v;
  	    $g->add_vertex( @v ) unless $V->has_path( @v );
  	    push @e, $V->_get_path_id( @v );
  	}
      }
      return @e;
  }
  
  sub _union_find_add_edge {
      my ($g, $u, $v) = @_;
      $g->[ _U ]->union($u, $v);
  }
  
  sub add_edge {
      my $g = shift;
      if (@_ != 2) {
        $g->expect_hyperedged;
      }
      if ($g->is_multiedged) {
  	unless (@_ == 2 || $g->is_hyperedged) {
  	    require Carp;
  	    Carp::croak("Graph::add_edge: use add_edges for more than one edge");
  	}
  	return $g->add_edge_by_id(@_, _GEN_ID);
      }
      my @e = $g->_add_edge( @_ );
      $g->[ _E ]->set_path( @e );
      $g->[ _G ]++;
      $g->_union_find_add_edge( @e ) if $g->has_union_find;
      return $g;
  }
  
  sub _vertex_ids {
      my $g = shift;
      my $V = $g->[ _V ];
      my @e;
      if (($V->[ _f ] & _LIGHT)) {
  	for my $v ( @_ ) {
  	    return () unless exists $V->[ _s ]->{ $v };
  	    push @e, $V->[ _s ]->{ $v };
  	}
      } else {
  	my $h = $g->[ _V ]->_is_HYPER;
  	for my $v ( @_ ) {
  	    my @v = ref $v eq 'ARRAY' && $h ? @$v : $v;
  	    return () unless $V->has_path( @v );
  	    push @e, $V->_get_path_id( @v );
  	}
      }
      return @e;
  }
  
  sub has_edge {
      my $g = shift;
      my $E = $g->[ _E ];
      my $V = $g->[ _V ];
      my @i;
      if (($V->[ _f ] & _LIGHT) && @_ == 2) {
  	return 0 unless
  	    exists $V->[ _s ]->{ $_[0] } &&
  	    exists $V->[ _s ]->{ $_[1] };
  	@i = @{ $V->[ _s ] }{ @_[ 0, 1 ] };
      } else {
  	@i = $g->_vertex_ids( @_ );
  	return 0 if @i == 0 && @_;
      }
      my $f = $E->[ _f ];
      if ($E->[ _a ] == 2 && @i == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@i = sort @i if ($f & _UNORD);
  	return exists $E->[ _s ]->{ $i[0] } &&
  	       exists $E->[ _s ]->{ $i[0] }->{ $i[1] } ? 1 : 0;
      } else {
  	return defined $E->_get_path_id( @i ) ? 1 : 0;
      }
  }
  
  sub edges05 {
      my $g = shift;
      my $V = $g->[ _V ];
      my @e = $g->[ _E ]->paths( @_ );
      wantarray ?
  	map { [ map { my @v = $V->_get_id_path($_);
  		      @v == 1 ? $v[0] : [ @v ] }
  		@$_ ] }
              @e : @e;
  }
  
  sub edges02 {
      my $g = shift;
      if (@_ && defined $_[0]) {
  	unless (defined $_[1]) {
  	    my @e = $g->edges_at($_[0]);
  	    wantarray ?
  		map { @$_ }
                      sort { $a->[0] cmp $b->[0] || $a->[1] cmp $b->[1] } @e
                  : @e;
  	} else {
  	    die "edges02: unimplemented option";
  	}
      } else {
  	my @e = map { ($_) x $g->get_edge_count(@$_) } $g->edges05( @_ );
  	wantarray ?
            map { @$_ }
                sort { $a->[0] cmp $b->[0] || $a->[1] cmp $b->[1] } @e
            : @e;
      }
  }
  
  sub unique_edges {
      my $g = shift;
      ($g->is_compat02) ? $g->edges02( @_ ) : $g->edges05( @_ );
  }
  
  sub edges {
      my $g = shift;
      if ($g->is_compat02) {
  	return $g->edges02( @_ );
      } else {
  	if ($g->is_multiedged || $g->is_countedged) {
  	    if (wantarray) {
  		my @E;
  		for my $e ( $g->edges05 ) {
  		    push @E, ($e) x $g->get_edge_count(@$e);
  		}
  		return @E;
  	    } else {
  		my $E = 0;
  		for my $e ( $g->edges05 ) {
  		    $E += $g->get_edge_count(@$e);
  		}
  		return $E;
  	    }
  	} else {
  	    return $g->edges05;
  	}
      }
  }
  
  sub has_edges {
      my $g = shift;
      scalar $g->[ _E ]->has_paths( @_ );
  }
  
  ###
  # by_id
  #
  
  sub add_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->[ _V ]->set_path_by_multi_id( @_ );
      $g->[ _G ]++;
      $g->_union_find_add_vertex( @_ ) if $g->has_union_find;
      return $g;
  }
  
  sub add_vertex_get_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $id = $g->[ _V ]->set_path_by_multi_id( @_, _GEN_ID );
      $g->[ _G ]++;
      $g->_union_find_add_vertex( @_ ) if $g->has_union_find;
      return $id;
  }
  
  sub has_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->[ _V ]->has_path_by_multi_id( @_ );
  }
  
  sub delete_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->expect_non_unionfind;
      my $V = $g->[ _V ];
      return unless $V->has_path_by_multi_id( @_ );
      # TODO: what to about the edges at this vertex?
      # If the multiness of this vertex goes to zero, delete the edges?
      $V->del_path_by_multi_id( @_ );
      $g->[ _G ]++;
      return $g;
  }
  
  sub get_multivertex_ids {
      my $g = shift;
      $g->expect_multivertexed;
      $g->[ _V ]->get_multi_ids( @_ );
  }
  
  sub add_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      my @e = $g->_add_edge( @_ );
      $g->[ _E ]->set_path_by_multi_id( @e, $id );
      $g->[ _G ]++;
      $g->_union_find_add_edge( @e ) if $g->has_union_find;
      return $g;
  }
  
  sub add_edge_get_id {
      my $g = shift;
      $g->expect_multiedged;
      my @i = $g->_add_edge( @_ );
      my $id = $g->[ _E ]->set_path_by_multi_id( @i, _GEN_ID );
      $g->_union_find_add_edge( @i ) if $g->has_union_find;
      $g->[ _G ]++;
      return $id;
  }
  
  sub has_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      my @i = $g->_vertex_ids( @_ );
      return 0 if @i == 0 && @_;
      $g->[ _E ]->has_path_by_multi_id( @i, $id );
  }
  
  sub delete_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->expect_non_unionfind;
      my $V = $g->[ _E ];
      my $id = pop;
      my @i = $g->_vertex_ids( @_ );
      return unless $V->has_path_by_multi_id( @i, $id );
      $V->del_path_by_multi_id( @i, $id );
      $g->[ _G ]++;
      return $g;
  }
  
  sub get_multiedge_ids {
      my $g = shift;
      $g->expect_multiedged;
      my @id = $g->_vertex_ids( @_ );
      return unless @id;
      $g->[ _E ]->get_multi_ids( @id );
  }
  
  ###
  # Neighbourhood.
  #
  
  sub vertices_at {
      my $g = shift;
      my $V = $g->[ _V ];
      return @_ unless ($V->[ _f ] & _HYPER);
      my %v;
      my @i;
      for my $v ( @_ ) {
  	my $i = $V->_get_path_id( $v );
  	return unless defined $i;
  	push @i, ( $v{ $v } = $i );
      }
      my $Vi = $V->_ids;
      my @v;
      while (my ($i, $v) = each %{ $Vi }) {
  	my %i;
  	my $h = $V->[_f ] & _HYPER;
  	@i{ @i } = @i if @i; # @todo: nonuniq hyper vertices?
  	for my $u (ref $v eq 'ARRAY' && $h ? @$v : $v) {
  	    my $j = exists $v{ $u } ? $v{ $u } : ( $v{ $u } = $i );
  	    if (defined $j && exists $i{ $j }) {
  		delete $i{ $j };
  		unless (keys %i) {
  		    push @v, $v;
  		    last;
  		}
  	    }
  	}
      }
      return @v;
  }
  
  sub _edges_at {
      my $g = shift;
      my $V = $g->[ _V ];
      my $E = $g->[ _E ];
      my @e;
      my $en = 0;
      my %ev;
      my $h = $V->[_f ] & _HYPER;
      for my $v ( $h ? $g->vertices_at( @_ ) : @_ ) {
  	my $vi = $V->_get_path_id( ref $v eq 'ARRAY' && $h ? @$v : $v );
  	next unless defined $vi;
  	my $Ei = $E->_ids;
  	while (my ($ei, $ev) = each %{ $Ei }) {
  	    if (wantarray) {
  		for my $j (@$ev) {
  		    push @e, [ $ei, $ev ]
  			if $j == $vi && !$ev{$ei}++;
  		}
  	    } else {
  		for my $j (@$ev) {
  		    $en++ if $j == $vi;
  		}
  	    }		    
  	}
      }
      return wantarray ? @e : $en;
  }
  
  sub _edges {
      my $g = shift;
      my $n = pop;
      my $i = $n == _S ? 0 : -1;  # _edges_from() or _edges_to()
      my $V = $g->[ _V ];
      my $E = $g->[ _E ];
      my $N = $g->[ $n ];
      my $h = $V->[ _f ] & _HYPER;
      unless (defined $N && $N->[ 0 ] == $g->[ _G ]) {
  	$g->[ $n ]->[ 1 ] = { };
  	$N = $g->[ $n ];
  	my $u = $E->[ _f ] & _UNORD;
  	my $Ei = $E->_ids;
  	while (my ($ei, $ev) = each %{ $Ei }) {
  	    next unless @$ev;
  	    my $e = [ $ei, $ev ];
  	    if ($u) {
  		push @{ $N->[ 1 ]->{ $ev->[ 0] } }, $e;
  		push @{ $N->[ 1 ]->{ $ev->[-1] } }, $e;
  	    } else {
  		my $e = [ $ei, $ev ];
  		push @{ $N->[ 1 ]->{ $ev->[$i] } }, $e;
  	    }
  	}
  	$N->[ 0 ] = $g->[ _G ];
      }
      my @e;
      my @at = $h ? $g->vertices_at( @_ ) : @_;
      my %at; @at{@at} = ();
      for my $v ( @at ) {
  	my $vi = $V->_get_path_id( ref $v eq 'ARRAY' && $h ? @$v : $v );
  	next unless defined $vi && exists $N->[ 1 ]->{ $vi };
  	push @e, @{ $N->[ 1 ]->{ $vi } };
      }
      if (wantarray && $g->is_undirected) {
  	my @i = map { $V->_get_path_id( $_ ) } @_;
  	for my $e ( @e ) {
  	    unless ( $e->[ 1 ]->[ $i ] == $i[ $i ] ) {
  		$e = [ $e->[ 0 ], [ reverse @{ $e->[ 1 ] } ] ];
  	    }
  	}
      }
      return @e;
  }
  
  sub _edges_from {
      push @_, _S;
      goto &_edges;
  }
  
  sub _edges_to {
      push @_, _P;
      goto &_edges;
  }
  
  sub _edges_id_path {
      my $g = shift;
      my $V  = $g->[ _V ];
      [ map { my @v = $V->_get_id_path($_);
  	    @v == 1 ? $v[0] : [ @v ] }
            @{ $_[0]->[1] } ];
  }
  
  sub edges_at {
      my $g = shift;
      map { $g->_edges_id_path($_ ) } $g->_edges_at( @_ );
  }
  
  sub edges_from {
      my $g = shift;
      map { $g->_edges_id_path($_ ) } $g->_edges_from( @_ );
  }
  
  sub edges_to {
      my $g = shift;
      map { $g->_edges_id_path($_ ) } $g->_edges_to( @_ );
  }
  
  sub successors {
      my $g = shift;
      my $E = $g->[ _E ];
      ($E->[ _f ] & _LIGHT) ?
  	$E->_successors($g, @_) :
  	Graph::AdjacencyMap::_successors($E, $g, @_);
  }
  
  sub predecessors {
      my $g = shift;
      my $E = $g->[ _E ];
      ($E->[ _f ] & _LIGHT) ?
  	$E->_predecessors($g, @_) :
  	Graph::AdjacencyMap::_predecessors($E, $g, @_);
  }
  
  sub _all_successors {
      my $g = shift;
      my @init = @_;
      my %todo;
      @todo{@init} = @init;
      my %seen;
      my %init = %todo;
      my %self;
      while (keys %todo) {
        my @todo = values %todo;
        for my $t (@todo) {
  	$seen{$t} = delete $todo{$t};
  	for my $s ($g->successors($t)) {
  	  $self{$s} = $s if exists $init{$s};
  	  $todo{$s} = $s unless exists $seen{$s};
  	}
        }
      }
      for my $v (@init) {
        delete $seen{$v} unless $g->has_edge($v, $v) || $self{$v};
      }
      return values %seen;
  }
  
  sub all_successors {
      my $g = shift;
      $g->expect_directed;
      return $g->_all_successors(@_);
  }
  
  sub _all_predecessors {
      my $g = shift;
      my @init = @_;
      my %todo;
      @todo{@init} = @init;
      my %seen;
      my %init = %todo;
      my %self;
      while (keys %todo) {
        my @todo = values %todo;
        for my $t (@todo) {
  	$seen{$t} = delete $todo{$t};
  	for my $p ($g->predecessors($t)) {
  	  $self{$p} = $p if exists $init{$p};
  	  $todo{$p} = $p unless exists $seen{$p};
  	}
        }
      }
      for my $v (@init) {
        delete $seen{$v} unless $g->has_edge($v, $v) || $self{$v};
      }
      return values %seen;
  }
  
  sub all_predecessors {
      my $g = shift;
      $g->expect_directed;
      return $g->_all_predecessors(@_);
  }
  
  sub neighbours {
      my $g = shift;
      my $V  = $g->[ _V ];
      my @s = map { my @v = @{ $_->[ 1 ] }; shift @v; @v } $g->_edges_from( @_ );
      my @p = map { my @v = @{ $_->[ 1 ] }; pop   @v; @v } $g->_edges_to  ( @_ );
      my %n;
      @n{ @s } = @s;
      @n{ @p } = @p;
      map { $V->_get_id_path($_) } keys %n;
  }
  
  *neighbors = \&neighbours;
  
  sub all_neighbours {
      my $g = shift;
      my @init = @_;
      my @v = @init;
      my %n;
      my $o = 0;
      while (1) {
        my @p = $g->_all_predecessors(@v);
        my @s = $g->_all_successors(@v);
        @n{@p} = @p;
        @n{@s} = @s;
        @v = values %n;
        last if @v == $o;  # Leave if no growth.
        $o = @v;
      }
      for my $v (@init) {
        delete $n{$v} unless $g->has_edge($v, $v);
      }
      return values %n;
  }
  
  *all_neighbors = \&all_neighbours;
  
  sub all_reachable {
      my $g = shift;
      $g->directed ? $g->all_successors(@_) : $g->all_neighbors(@_);
  }
  
  sub delete_edge {
      my $g = shift;
      $g->expect_non_unionfind;
      my @i = $g->_vertex_ids( @_ );
      return $g unless @i;
      my $i = $g->[ _E ]->_get_path_id( @i );
      return $g unless defined $i;
      $g->[ _E ]->_del_id( $i );
      $g->[ _G ]++;
      return $g;
  }
  
  sub delete_vertex {
      my $g = shift;
      $g->expect_non_unionfind;
      my $V = $g->[ _V ];
      return $g unless $V->has_path( @_ );
      if (@_ == 1 && !($g->[ _f ] & (_HYPER|_REF|_UNIQ))) {
        $g->delete_edge($_[0], $_) for $g->successors($_[0]);
        $g->delete_edge($_, $_[0]) for $g->predecessors($_[0]);
      } else {
        # TODO: _edges_at is excruciatingly slow (rt.cpan.org 92427)
        my $E = $g->[ _E ];
        for my $e ( $g->_edges_at( @_ ) ) {
          $E->_del_id( $e->[ 0 ] );
        }
      }
      $V->del_path( @_ );
      $g->[ _G ]++;
      return $g;
  }
  
  sub get_vertex_count {
      my $g = shift;
      $g->[ _V ]->_get_path_count( @_ ) || 0;
  }
  
  sub get_edge_count {
      my $g = shift;
      my @e = $g->_vertex_ids( @_ );
      return 0 unless @e;
      $g->[ _E ]->_get_path_count( @e ) || 0;
  }
  
  sub delete_vertices {
      my $g = shift;
      $g->expect_non_unionfind;
      while (@_) {
  	my $v = shift @_;
  	$g->delete_vertex($v);
      }
      return $g;
  }
  
  sub delete_edges {
      my $g = shift;
      $g->expect_non_unionfind;
      while (@_) {
  	my ($u, $v) = splice @_, 0, 2;
  	$g->delete_edge($u, $v);
      }
      return $g;
  }
  
  ###
  # Degrees.
  #
  
  sub _in_degree {
      my $g = shift;
      return undef unless @_ && $g->has_vertex( @_ );
      my $in = 0;
      $in += $g->get_edge_count( @$_ ) for $g->edges_to( @_ );
      return $in;
  }
  
  sub in_degree {
      my $g = shift;
      $g->_in_degree( @_ );
  }
  
  sub _out_degree {
      my $g = shift;
      return undef unless @_ && $g->has_vertex( @_ );
      my $out = 0;
      $out += $g->get_edge_count( @$_ ) for $g->edges_from( @_ );
      return $out;
  }
  
  sub out_degree {
      my $g = shift;
      $g->_out_degree( @_ );
  }
  
  sub _total_degree {
      my $g = shift;
      return undef unless @_ && $g->has_vertex( @_ );
      $g->is_undirected ?
  	$g->_in_degree( @_ ) :
  	$g-> in_degree( @_ ) - $g-> out_degree( @_ );
  }
  
  sub degree {
      my $g = shift;
      if (@_) {
  	$g->_total_degree( @_ );
      } elsif ($g->is_undirected) {
  	my $total = 0;
  	$total += $g->_total_degree( $_ ) for $g->vertices05;
  	return $total;
      } else {
  	return 0;
      }
  }
  
  *vertex_degree = \&degree;
  
  sub is_sink_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->successors( @_ ) == 0 && $g->predecessors( @_ ) > 0;
  }
  
  sub is_source_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0 && $g->successors( @_ ) > 0;
  }
  
  sub is_successorless_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->successors( @_ ) == 0;
  }
  
  sub is_predecessorless_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0;
  }
  
  sub is_successorful_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->successors( @_ ) > 0;
  }
  
  sub is_predecessorful_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) > 0;
  }
  
  sub is_isolated_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0 && $g->successors( @_ ) == 0;
  }
  
  sub is_interior_vertex {
      my $g = shift;
      return 0 unless @_;
      my $p = $g->predecessors( @_ );
      my $s = $g->successors( @_ );
      if ($g->is_self_loop_vertex( @_ )) {
  	$p--;
  	$s--;
      }
      $p > 0 && $s > 0;
  }
  
  sub is_exterior_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0 || $g->successors( @_ ) == 0;
  }
  
  sub is_self_loop_vertex {
      my $g = shift;
      return 0 unless @_;
      for my $s ( $g->successors( @_ ) ) {
  	return 1 if $s eq $_[0]; # @todo: multiedges, hypervertices
      }
      return 0;
  }
  
  sub sink_vertices {
      my $g = shift;
      grep { $g->is_sink_vertex($_) } $g->vertices05;
  }
  
  sub source_vertices {
      my $g = shift;
      grep { $g->is_source_vertex($_) } $g->vertices05;
  }
  
  sub successorless_vertices {
      my $g = shift;
      grep { $g->is_successorless_vertex($_) } $g->vertices05;
  }
  
  sub predecessorless_vertices {
      my $g = shift;
      grep { $g->is_predecessorless_vertex($_) } $g->vertices05;
  }
  
  sub successorful_vertices {
      my $g = shift;
      grep { $g->is_successorful_vertex($_) } $g->vertices05;
  }
  
  sub predecessorful_vertices {
      my $g = shift;
      grep { $g->is_predecessorful_vertex($_) } $g->vertices05;
  }
  
  sub isolated_vertices {
      my $g = shift;
      grep { $g->is_isolated_vertex($_) } $g->vertices05;
  }
  
  sub interior_vertices {
      my $g = shift;
      grep { $g->is_interior_vertex($_) } $g->vertices05;
  }
  
  sub exterior_vertices {
      my $g = shift;
      grep { $g->is_exterior_vertex($_) } $g->vertices05;
  }
  
  sub self_loop_vertices {
      my $g = shift;
      grep { $g->is_self_loop_vertex($_) } $g->vertices05;
  }
  
  ###
  # Paths and cycles.
  #
  
  sub add_path {
      my $g = shift;
      my $u = shift;
      while (@_) {
  	my $v = shift;
  	$g->add_edge($u, $v);
  	$u = $v;
      }
      return $g;
  }
  
  sub delete_path {
      my $g = shift;
      $g->expect_non_unionfind;
      my $u = shift;
      while (@_) {
  	my $v = shift;
  	$g->delete_edge($u, $v);
  	$u = $v;
      }
      return $g;
  }
  
  sub has_path {
      my $g = shift;
      my $u = shift;
      while (@_) {
  	my $v = shift;
  	return 0 unless $g->has_edge($u, $v);
  	$u = $v;
      }
      return $g;
  }
  
  sub add_cycle {
      my $g = shift;
      $g->add_path(@_, $_[0]);
  }
  
  sub delete_cycle {
      my $g = shift;
      $g->expect_non_unionfind;
      $g->delete_path(@_, $_[0]);
  }
  
  sub has_cycle {
      my $g = shift;
      @_ ? ($g->has_path(@_, $_[0]) ? 1 : 0) : 0;
  }
  
  *has_this_cycle = \&has_cycle;
  
  sub has_a_cycle {
      my $g = shift;
      my @r = ( back_edge => \&Graph::Traversal::has_a_cycle );
      push @r,
        down_edge => \&Graph::Traversal::has_a_cycle
         if $g->is_undirected;
      my $t = Graph::Traversal::DFS->new($g, @r, @_);
      $t->dfs;
      return $t->get_state('has_a_cycle');
  }
  
  sub find_a_cycle {
      my $g = shift;
      my @r = ( back_edge => \&Graph::Traversal::find_a_cycle);
      push @r,
        down_edge => \&Graph::Traversal::find_a_cycle
  	if $g->is_undirected;
      my $t = Graph::Traversal::DFS->new($g, @r, @_);
      $t->dfs;
      $t->has_state('a_cycle') ? @{ $t->get_state('a_cycle') } : ();
  }
  
  ###
  # Attributes.
  
  # Vertex attributes.
  
  sub set_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $value = pop;
      my $attr  = pop;
      $g->add_vertex( @_ ) unless $g->has_vertex( @_ );
      $g->[ _V ]->_set_path_attr( @_, $attr, $value );
  }
  
  sub set_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $value = pop;
      my $attr  = pop;
      $g->add_vertex_by_id( @_ ) unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_set_path_attr( @_, $attr, $value );
  }
  
  sub set_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      $g->add_vertex( @_ ) unless $g->has_vertex( @_ );
      $g->[ _V ]->_set_path_attrs( @_, $attr );
  }
  
  sub set_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      $g->add_vertex_by_id( @_ ) unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_set_path_attrs( @_, $attr );
  }
  
  sub has_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      return 0 unless $g->has_vertex( @_ );
      $g->[ _V ]->_has_path_attrs( @_ );
  }
  
  sub has_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return 0 unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_has_path_attrs( @_ );
  }
  
  sub has_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      return 0 unless $g->has_vertex( @_ );
      $g->[ _V ]->_has_path_attr( @_, $attr );
  }
  
  sub has_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      return 0 unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_has_path_attr( @_, $attr );
  }
  
  sub get_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      return unless $g->has_vertex( @_ );
      my $a = $g->[ _V ]->_get_path_attrs( @_ );
      ($g->is_compat02) ? (defined $a ? %{ $a } : ()) : $a;
  }
  
  sub get_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attrs( @_ );
  }
  
  sub get_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      return unless $g->has_vertex( @_ );
      $g->[ _V ]->_get_path_attr( @_, $attr );
  }
  
  sub get_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attr( @_, $attr );
  }
  
  sub get_vertex_attribute_names {
      my $g = shift;
      $g->expect_non_multivertexed;
      return unless $g->has_vertex( @_ );
      $g->[ _V ]->_get_path_attr_names( @_ );
  }
  
  sub get_vertex_attribute_names_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attr_names( @_ );
  }
  
  sub get_vertex_attribute_values {
      my $g = shift;
      $g->expect_non_multivertexed;
      return unless $g->has_vertex( @_ );
      $g->[ _V ]->_get_path_attr_values( @_ );
  }
  
  sub get_vertex_attribute_values_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attr_values( @_ );
  }
  
  sub delete_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      return undef unless $g->has_vertex( @_ );
      $g->[ _V ]->_del_path_attrs( @_ );
  }
  
  sub delete_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return undef unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_del_path_attrs( @_ );
  }
  
  sub delete_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      return undef unless $g->has_vertex( @_ );
      $g->[ _V ]->_del_path_attr( @_, $attr );
  }
  
  sub delete_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      return undef unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_del_path_attr( @_, $attr );
  }
  
  # Edge attributes.
  
  sub _set_edge_attribute {
      my $g = shift;
      my $value = pop;
      my $attr  = pop;
      my $E = $g->[ _E ];
      my $f = $E->[ _f ];
      my @i;
      if ($E->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	my $s = $E->[ _s ];
  	$g->add_edge( @_ ) unless exists $s->{ $_[0] } && exists $s->{ $_[0] }->{ $_[1] };
  	@i = @{ $g->[ _V ]->[ _s ] }{ @_ };
      } else {
  	$g->add_edge( @_ ) unless $g->has_edge( @_ );
  	@i = $g->_vertex_ids( @_ );
      }
      $g->[ _E ]->_set_path_attr( @i, $attr, $value );
  }
  
  sub set_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $value = pop;
      my $attr  = pop;
      my $E = $g->[ _E ];
      $g->add_edge( @_ ) unless $g->has_edge( @_ );
      $E->_set_path_attr( $g->_vertex_ids( @_ ), $attr, $value );
  }
  
  sub set_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $value = pop;
      my $attr  = pop;
      # $g->add_edge_by_id( @_ ) unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_set_path_attr( $g->_vertex_ids( @_ ), $id, $attr, $value );
  }
  
  sub set_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      $g->add_edge( @_ ) unless $g->has_edge( @_ );
      $g->[ _E ]->_set_path_attrs( $g->_vertex_ids( @_ ), $attr );
  }
  
  sub set_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      $g->add_edge_by_id( @_ ) unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_set_path_attrs( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  sub has_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      return 0 unless $g->has_edge( @_ );
      $g->[ _E ]->_has_path_attrs( $g->_vertex_ids( @_ ) );
  }
  
  sub has_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return 0 unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_has_path_attrs( $g->_vertex_ids( @_ ), $id );
  }
  
  sub has_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      return 0 unless $g->has_edge( @_ );
      $g->[ _E ]->_has_path_attr( $g->_vertex_ids( @_ ), $attr );
  }
  
  sub has_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      return 0 unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_has_path_attr( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  sub get_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      my $a = $g->[ _E ]->_get_path_attrs( $g->_vertex_ids( @_ ) );
      ($g->is_compat02) ? (defined $a ? %{ $a } : ()) : $a;
  }
  
  sub get_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      return $g->[ _E ]->_get_path_attrs( $g->_vertex_ids( @_ ), $id );
  }
  
  sub _get_edge_attribute { # Fast path; less checks.
      my $g = shift;
      my $attr = pop;
      my $E = $g->[ _E ];
      my $f = $E->[ _f ];
      if ($E->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	my $s = $E->[ _s ];
  	return unless exists $s->{ $_[0] } && exists $s->{ $_[0] }->{ $_[1] };
      } else {
  	return unless $g->has_edge( @_ );
      }
      my @i = $g->_vertex_ids( @_ );
      $E->_get_path_attr( @i, $attr );
  }
  
  sub get_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      return undef unless $g->has_edge( @_ );
      my @i = $g->_vertex_ids( @_ );
      return undef if @i == 0 && @_;
      my $E = $g->[ _E ];
      $E->_get_path_attr( @i, $attr );
  }
  
  sub get_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_get_path_attr( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  sub get_edge_attribute_names {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_get_path_attr_names( $g->_vertex_ids( @_ ) );
  }
  
  sub get_edge_attribute_names_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_get_path_attr_names( $g->_vertex_ids( @_ ), $id );
  }
  
  sub get_edge_attribute_values {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_get_path_attr_values( $g->_vertex_ids( @_ ) );
  }
  
  sub get_edge_attribute_values_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_get_path_attr_values( $g->_vertex_ids( @_ ), $id );
  }
  
  sub delete_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_del_path_attrs( $g->_vertex_ids( @_ ) );
  }
  
  sub delete_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_del_path_attrs( $g->_vertex_ids( @_ ), $id );
  }
  
  sub delete_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_del_path_attr( $g->_vertex_ids( @_ ), $attr );
  }
  
  sub delete_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_del_path_attr( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  ###
  # Compat.
  #
  
  sub vertex {
      my $g = shift;
      $g->has_vertex( @_ ) ? @_ : undef;
  }
  
  sub out_edges {
      my $g = shift;
      return unless @_ && $g->has_vertex( @_ );
      my @e = $g->edges_from( @_ );
      wantarray ? map { @$_ } @e : @e;
  }
  
  sub in_edges {
      my $g = shift;
      return unless @_ && $g->has_vertex( @_ );
      my @e = $g->edges_to( @_ );
      wantarray ? map { @$_ } @e : @e;
  }
  
  sub add_vertices {
      my $g = shift;
      $g->add_vertex( $_ ) for @_;
      return $g;
  }
  
  sub add_edges {
      my $g = shift;
      while (@_) {
  	my $u = shift @_;
  	if (ref $u eq 'ARRAY') {
  	    $g->add_edge( @$u );
  	} else {
  	    if (@_) {
  		my $v = shift @_;
  		$g->add_edge( $u, $v );
  	    } else {
  		require Carp;
  		Carp::croak("Graph::add_edges: missing end vertex");
  	    }
  	}
      }
      return $g;
  }
  
  ###
  # More constructors.
  #
  
  sub copy {
      my $g = shift;
      my %opt = _get_options( \@_ );
  
      my $c =
  	(ref $g)->new(map { $_ => $g->$_ ? 1 : 0 }
  		      qw(directed
  			 compat02
  			 refvertexed
  			 hypervertexed
  			 countvertexed
  			 multivertexed
  			 hyperedged
  			 countedged
  			 multiedged
  			 omniedged
  		         __stringified));
      for my $v ($g->isolated_vertices) { $c->add_vertex($v) }
      for my $e ($g->edges05)           { $c->add_edge(@$e)  }
  
      return $c;
  }
  
  *copy_graph = \&copy;
  
  sub _deep_copy_Storable {
      my $g = shift;
      my $safe = new Safe;
      local $Storable::Deparse = 1;
      local $Storable::Eval = sub { $safe->reval($_[0]) };
      return Storable::thaw(Storable::freeze($g));
  }
  
  sub _deep_copy_DataDumper {
      my $g = shift;
      my $d = Data::Dumper->new([$g]);
      use vars qw($VAR1);
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      $d->Deparse(1) if $] >= 5.008;
      eval $d->Dump;
  }
  
  sub deep_copy {
      if (_can_deep_copy_Storable()) {
  	return _deep_copy_Storable(@_);
      } else {
  	return _deep_copy_DataDumper(@_);
      }
  }
  
  *deep_copy_graph = \&deep_copy;
  
  sub transpose_edge {
      my $g = shift;
      if ($g->is_directed) {
  	return undef unless $g->has_edge( @_ );
  	my $c = $g->get_edge_count( @_ );
  	my $a = $g->get_edge_attributes( @_ );
  	my @e = reverse @_;
  	$g->delete_edge( @_ ) unless $g->has_edge( @e );
  	$g->add_edge( @e ) for 1..$c;
  	$g->set_edge_attributes(@e, $a) if $a;
      }
      return $g;
  }
  
  sub transpose_graph {
      my $g = shift;
      my $t = $g->copy;
      if ($t->directed) {
  	for my $e ($t->edges05) {
  	    $t->transpose_edge(@$e);
  	}
      }
      return $t;
  }
  
  *transpose = \&transpose_graph;
  
  sub complete_graph {
      my $g = shift;
      my $c = $g->new( directed => $g->directed );
      my @v = $g->vertices05;
      for (my $i = 0; $i <= $#v; $i++ ) {
  	for (my $j = 0; $j <= $#v; $j++ ) {
  	    next if $i >= $j;
  	    if ($g->is_undirected) {
  		$c->add_edge($v[$i], $v[$j]);
  	    } else {
  		$c->add_edge($v[$i], $v[$j]);
  		$c->add_edge($v[$j], $v[$i]);
  	    }
  	}
      }
      return $c;
  }
  
  *complement = \&complement_graph;
  
  sub complement_graph {
      my $g = shift;
      my $c = $g->new( directed => $g->directed );
      my @v = $g->vertices05;
      for (my $i = 0; $i <= $#v; $i++ ) {
  	for (my $j = 0; $j <= $#v; $j++ ) {
  	    next if $i >= $j;
  	    if ($g->is_undirected) {
  		$c->add_edge($v[$i], $v[$j])
  		    unless $g->has_edge($v[$i], $v[$j]);
  	    } else {
  		$c->add_edge($v[$i], $v[$j])
  		    unless $g->has_edge($v[$i], $v[$j]);
  		$c->add_edge($v[$j], $v[$i])
  		    unless $g->has_edge($v[$j], $v[$i]);
  	    }
  	}
      }
      return $c;
  }
  
  *complete = \&complete_graph;
  
  sub subgraph {
    my ($g, $src, $dst) = @_;
    $dst = $src unless defined $dst;
    unless (ref $src eq 'ARRAY' && ref $dst eq 'ARRAY') {
      Carp::croak("Graph::subgraph: need src and dst array references");
    }
    my $s = $g->new;
    my @u = grep { $g->has_vertex($_) } @$src;
    my @v = grep { $g->has_vertex($_) } @$dst;
    $s->add_vertices(@u, @v);
    for my $u (@u) {
      my @e;
      for my $v (@v) {
        if ($g->has_edge($u, $v)) {
          push @e, [$u, $v];
        }
      }
      $s->add_edges(@e);
    }
    return $s;
  }
  
  ###
  # Transitivity.
  #
  
  sub is_transitive {
      my $g = shift;
      Graph::TransitiveClosure::is_transitive($g);
  }
  
  ###
  # Weighted vertices.
  #
  
  my $defattr = 'weight';
  
  sub _defattr {
      return $defattr;
  }
  
  sub add_weighted_vertex {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $w = pop;
      $g->add_vertex(@_);
      $g->set_vertex_attribute(@_, $defattr, $w);
  }
  
  sub add_weighted_vertices {
      my $g = shift;
      $g->expect_non_multivertexed;
      while (@_) {
  	my ($v, $w) = splice @_, 0, 2;
  	$g->add_vertex($v);
  	$g->set_vertex_attribute($v, $defattr, $w);
      }
  }
  
  sub get_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      $g->get_vertex_attribute(@_, $defattr);
  }
  
  sub has_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      $g->has_vertex_attribute(@_, $defattr);
  }
  
  sub set_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $w = pop;
      $g->set_vertex_attribute(@_, $defattr, $w);
  }
  
  sub delete_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      $g->delete_vertex_attribute(@_, $defattr);
  }
  
  sub add_weighted_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $w = pop;
      $g->add_vertex_by_id(@_);
      $g->set_vertex_attribute_by_id(@_, $defattr, $w);
  }
  
  sub add_weighted_vertices_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $id = pop;
      while (@_) {
  	my ($v, $w) = splice @_, 0, 2;
  	$g->add_vertex_by_id($v, $id);
  	$g->set_vertex_attribute_by_id($v, $id, $defattr, $w);
      }
  }
  
  sub get_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->get_vertex_attribute_by_id(@_, $defattr);
  }
  
  sub has_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->has_vertex_attribute_by_id(@_, $defattr);
  }
  
  sub set_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $w = pop;
      $g->set_vertex_attribute_by_id(@_, $defattr, $w);
  }
  
  sub delete_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->delete_vertex_attribute_by_id(@_, $defattr);
  }
  
  ###
  # Weighted edges.
  #
  
  sub add_weighted_edge {
      my $g = shift;
      $g->expect_non_multiedged;
      if ($g->is_compat02) {
  	my $w = splice @_, 1, 1;
  	$g->add_edge(@_);
  	$g->set_edge_attribute(@_, $defattr, $w);
      } else {
  	my $w = pop;
  	$g->add_edge(@_);
  	$g->set_edge_attribute(@_, $defattr, $w);
      }
  }
  
  sub add_weighted_edges {
      my $g = shift;
      $g->expect_non_multiedged;
      if ($g->is_compat02) {
  	while (@_) {
  	    my ($u, $w, $v) = splice @_, 0, 3;
  	    $g->add_edge($u, $v);
  	    $g->set_edge_attribute($u, $v, $defattr, $w);
  	}
      } else {
  	while (@_) {
  	    my ($u, $v, $w) = splice @_, 0, 3;
  	    $g->add_edge($u, $v);
  	    $g->set_edge_attribute($u, $v, $defattr, $w);
  	}
      }
  }
  
  sub add_weighted_edges_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      while (@_) {
  	my ($u, $v, $w) = splice @_, 0, 3;
  	$g->add_edge_by_id($u, $v, $id);
  	$g->set_edge_attribute_by_id($u, $v, $id, $defattr, $w);
      }
  }
  
  sub add_weighted_path {
      my $g = shift;
      $g->expect_non_multiedged;
      my $u = shift;
      while (@_) {
  	my ($w, $v) = splice @_, 0, 2;
  	$g->add_edge($u, $v);
  	$g->set_edge_attribute($u, $v, $defattr, $w);
  	$u = $v;
      }
  }
  
  sub get_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      $g->get_edge_attribute(@_, $defattr);
  }
  
  sub has_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      $g->has_edge_attribute(@_, $defattr);
  }
  
  sub set_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      my $w = pop;
      $g->set_edge_attribute(@_, $defattr, $w);
  }
  
  sub delete_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      $g->delete_edge_attribute(@_, $defattr);
  }
  
  sub add_weighted_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      if ($g->is_compat02) {
  	my $w = splice @_, 1, 1;
  	$g->add_edge_by_id(@_);
  	$g->set_edge_attribute_by_id(@_, $defattr, $w);
      } else {
  	my $w = pop;
  	$g->add_edge_by_id(@_);
  	$g->set_edge_attribute_by_id(@_, $defattr, $w);
      }
  }
  
  sub add_weighted_path_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      my $u = shift;
      while (@_) {
  	my ($w, $v) = splice @_, 0, 2;
  	$g->add_edge_by_id($u, $v, $id);
  	$g->set_edge_attribute_by_id($u, $v, $id, $defattr, $w);
  	$u = $v;
      }
  }
  
  sub get_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->get_edge_attribute_by_id(@_, $defattr);
  }
  
  sub has_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->has_edge_attribute_by_id(@_, $defattr);
  }
  
  sub set_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $w = pop;
      $g->set_edge_attribute_by_id(@_, $defattr, $w);
  }
  
  sub delete_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->delete_edge_attribute_by_id(@_, $defattr);
  }
  
  ###
  # Error helpers.
  #
  
  my %expected;
  @expected{qw(directed undirected acyclic)} = qw(undirected directed cyclic);
  
  sub _expected {
      my $exp = shift;
      my $got = @_ ? shift : $expected{$exp};
      $got = defined $got ? ", got $got" : "";
      if (my @caller2 = caller(2)) {
  	die "$caller2[3]: expected $exp graph$got, at $caller2[1] line $caller2[2].\n";
      } else {
  	my @caller1 = caller(1);
  	die "$caller1[3]: expected $exp graph$got, at $caller1[1] line $caller1[2].\n";
      }
  }
  
  sub expect_no_args {
      my $g = shift;
      return unless @_;
      my @caller1 = caller(1);
      die "$caller1[3]: expected no arguments, got " . scalar @_ . ", at $caller1[1] line $caller1[2]\n";
  }
  
  sub expect_undirected {
      my $g = shift;
      _expected('undirected') unless $g->is_undirected;
  }
  
  sub expect_directed {
      my $g = shift;
      _expected('directed') unless $g->is_directed;
  }
  
  sub expect_acyclic {
      my $g = shift;
      _expected('acyclic') unless $g->is_acyclic;
  }
  
  sub expect_dag {
      my $g = shift;
      my @got;
      push @got, 'undirected' unless $g->is_directed;
      push @got, 'cyclic'     unless $g->is_acyclic;
      _expected('directed acyclic', "@got") if @got;
  }
  
  sub expect_hypervertexed {
      my $g = shift;
      _expected('hypervertexed') unless $g->is_hypervertexed;
  }
  
  sub expect_hyperedged {
      my $g = shift;
      _expected('hyperedged') unless $g->is_hyperedged;
  }
  
  sub expect_multivertexed {
      my $g = shift;
      _expected('multivertexed') unless $g->is_multivertexed;
  }
  
  sub expect_non_multivertexed {
      my $g = shift;
      _expected('non-multivertexed') if $g->is_multivertexed;
  }
  
  sub expect_non_multiedged {
      my $g = shift;
      _expected('non-multiedged') if $g->is_multiedged;
  }
  
  sub expect_multiedged {
      my $g = shift;
      _expected('multiedged') unless $g->is_multiedged;
  }
  
  sub expect_non_unionfind {
      my $g = shift;
      _expected('non-unionfind') if $g->has_union_find;
  }
  
  sub _get_options {
      my @caller = caller(1);
      unless (@_ == 1 && ref $_[0] eq 'ARRAY') {
  	die "$caller[3]: internal error: should be called with only one array ref argument, at $caller[1] line $caller[2].\n";
      }
      my @opt = @{ $_[0] };
      unless (@opt  % 2 == 0) {
  	die "$caller[3]: expected an options hash, got a non-even number of arguments, at $caller[1] line $caller[2].\n";
      }
      return @opt;
  }
  
  ###
  # Random constructors and accessors.
  #
  
  sub __fisher_yates_shuffle (@) {
      # From perlfaq4, but modified to be non-modifying.
      my @a = @_;
      my $i = @a;
      while ($i--) {
  	my $j = int rand ($i+1);
  	@a[$i,$j] = @a[$j,$i];
      }
      return @a;
  }
  
  BEGIN {
      sub _shuffle(@);
      # Workaround for the Perl bug [perl #32383] where -d:Dprof and
      # List::Util::shuffle do not like each other: if any debugging
      # (-d) flags are on, fall back to our own Fisher-Yates shuffle.
      # The bug was fixed by perl changes #26054 and #26062, which
      # went to Perl 5.9.3.  If someone tests this with a pre-5.9.3
      # bleadperl that calls itself 5.9.3 but doesn't yet have the
      # patches, oh, well.
      *_shuffle = $^P && $] < 5.009003 ?
  	\&__fisher_yates_shuffle : \&List::Util::shuffle;
  }
  
  sub random_graph {
      my $class = (@_ % 2) == 0 ? 'Graph' : shift;
      my %opt = _get_options( \@_ );
      my $random_edge;
      unless (exists $opt{vertices} && defined $opt{vertices}) {
  	require Carp;
  	Carp::croak("Graph::random_graph: argument 'vertices' missing or undef");
      }
      if (exists $opt{random_seed}) {
  	srand($opt{random_seed});
  	delete $opt{random_seed};
      }
      if (exists $opt{random_edge}) {
  	$random_edge = $opt{random_edge};
  	delete $opt{random_edge};
      }
      my @V;
      if (my $ref = ref $opt{vertices}) {
  	if ($ref eq 'ARRAY') {
  	    @V = @{ $opt{vertices} };
  	} else {
  	    Carp::croak("Graph::random_graph: argument 'vertices' illegal");
  	}
      } else {
  	@V = 0..($opt{vertices} - 1);
      }
      delete $opt{vertices};
      my $V = @V;
      my $C = $V * ($V - 1) / 2;
      my $E;
      if (exists $opt{edges} && exists $opt{edges_fill}) {
  	Carp::croak("Graph::random_graph: both arguments 'edges' and 'edges_fill' specified");
      }
      $E = exists $opt{edges_fill} ? $opt{edges_fill} * $C : $opt{edges};
      delete $opt{edges};
      delete $opt{edges_fill};
      my $g = $class->new(%opt);
      $g->add_vertices(@V);
      return $g if $V < 2;
      $C *= 2 if $g->directed;
      $E = $C / 2 unless defined $E;
      $E = int($E + 0.5);
      my $p = $E / $C;
      $random_edge = sub { $p } unless defined $random_edge;
      # print "V = $V, E = $E, C = $C, p = $p\n";
      if ($p > 1.0 && !($g->countedged || $g->multiedged)) {
  	require Carp;
  	Carp::croak("Graph::random_graph: needs to be countedged or multiedged ($E > $C)");
      }
      my @V1 = @V;
      my @V2 = @V;
      # Shuffle the vertex lists so that the pairs at
      # the beginning of the lists are not more likely.
      @V1 = _shuffle @V1;
      @V2 = _shuffle @V2;
   LOOP:
      while ($E) {
  	for my $v1 (@V1) {
  	    for my $v2 (@V2) {
  		next if $v1 eq $v2; # TODO: allow self-loops?
  		my $q = $random_edge->($g, $v1, $v2, $p);
  		if ($q && ($q == 1 || rand() <= $q) &&
  		    !$g->has_edge($v1, $v2)) {
  		    $g->add_edge($v1, $v2);
  		    $E--;
  		    last LOOP unless $E;
  		}
  	    }
  	}
      }
      return $g;
  }
  
  sub random_vertex {
      my $g = shift;
      my @V = $g->vertices05;
      @V[rand @V];
  }
  
  sub random_edge {
      my $g = shift;
      my @E = $g->edges05;
      @E[rand @E];
  }
  
  sub random_successor {
      my ($g, $v) = @_;
      my @S = $g->successors($v);
      @S[rand @S];
  }
  
  sub random_predecessor {
      my ($g, $v) = @_;
      my @P = $g->predecessors($v);
      @P[rand @P];
  }
  
  ###
  # Algorithms.
  #
  
  my $MST_comparator = sub { ($_[0] || 0) <=> ($_[1] || 0) };
  
  sub _MST_attr {
      my $attr = shift;
      my $attribute =
  	exists $attr->{attribute}  ?
  	    $attr->{attribute}  : $defattr;
      my $comparator =
  	exists $attr->{comparator} ?
  	    $attr->{comparator} : $MST_comparator;
      return ($attribute, $comparator);
  }
  
  sub _MST_edges {
      my ($g, $attr) = @_;
      my ($attribute, $comparator) = _MST_attr($attr);
      map { $_->[1] }
          sort { $comparator->($a->[0], $b->[0], $a->[1], $b->[1]) }
               map { [ $g->get_edge_attribute(@$_, $attribute), $_ ] }
                   $g->edges05;
  }
  
  sub MST_Kruskal {
      my ($g, %attr) = @_;
  
      $g->expect_undirected;
  
      my $MST = Graph::Undirected->new;
  
      my $UF  = Graph::UnionFind->new;
      for my $v ($g->vertices05) { $UF->add($v) }
  
      for my $e ($g->_MST_edges(\%attr)) {
  	my ($u, $v) = @$e; # TODO: hyperedges
  	my $t0 = $UF->find( $u );
  	my $t1 = $UF->find( $v );
  	unless ($t0 eq $t1) {
  	    $UF->union($u, $v);
  	    $MST->add_edge($u, $v);
  	}
      }
  
      return $MST;
  }
  
  sub _MST_add {
      my ($g, $h, $HF, $r, $attr, $unseen) = @_;
      for my $s ( grep { exists $unseen->{ $_ } } $g->successors( $r ) ) {
  	$HF->add( Graph::MSTHeapElem->new( $r, $s, $g->get_edge_attribute( $r, $s, $attr ) ) );
      }
  }
  
  sub _next_alphabetic { shift; (sort               keys %{ $_[0] })[0] }
  sub _next_numeric    { shift; (sort { $a <=> $b } keys %{ $_[0] })[0] }
  sub _next_random     { shift; (values %{ $_[0] })[ rand keys %{ $_[0] } ] }
  
  sub _root_opt {
      my $g = shift;
      my %opt = @_ == 1 ? ( first_root => $_[0] ) : _get_options( \@_ );
      my %unseen;
      my @unseen = $g->vertices05;
      @unseen{ @unseen } = @unseen;
      @unseen = _shuffle @unseen;
      my $r;
      if (exists $opt{ start }) {
  	$opt{ first_root } = $opt{ start };
  	$opt{ next_root  } = undef;
      }
      if (exists $opt{ get_next_root }) {
  	$opt{ next_root  } = $opt{ get_next_root }; # Graph 0.201 compat.
      }
      if (exists $opt{ first_root }) {
  	if (ref $opt{ first_root } eq 'CODE') {
  	    $r = $opt{ first_root }->( $g, \%unseen );
  	} else {
  	    $r = $opt{ first_root };
  	}
      } else {
  	$r = shift @unseen;
      }
      my $next =
  	exists $opt{ next_root } ?
  	    $opt{ next_root } :
                $opt{ next_alphabetic } ?
                  \&_next_alphabetic :
                    $opt{ next_numeric } ?
                      \&_next_numeric :
                        \&_next_random;
      my $code = ref $next eq 'CODE';
      my $attr = exists $opt{ attribute } ? $opt{ attribute } : $defattr;
      return ( \%opt, \%unseen, \@unseen, $r, $next, $code, $attr );
  }
  
  sub _heap_walk {
      my ($g, $h, $add, $etc) = splice @_, 0, 4; # Leave %opt in @_.
  
      my ($opt, $unseenh, $unseena, $r, $next, $code, $attr) = $g->_root_opt(@_);
      my $HF = Heap071::Fibonacci->new;
  
      while (defined $r) {
          # print "r = $r\n";
  	$add->($g, $h, $HF, $r, $attr, $unseenh, $etc);
  	delete $unseenh->{ $r };
  	while (defined $HF->top) {
  	    my $t = $HF->extract_top;
  	    # use Data::Dumper; print "t = ", Dumper($t);
  	    if (defined $t) {
  		my ($u, $v, $w) = $t->val;
  		# print "extracted top: $u $v $w\n";
  		if (exists $unseenh->{ $v }) {
  		    $h->set_edge_attribute($u, $v, $attr, $w);
  		    delete $unseenh->{ $v };
  		    $add->($g, $h, $HF, $v, $attr, $unseenh, $etc);
  		}
  	    }
  	}
  	return $h unless defined $next;
  	$r = $code ? $next->( $g, $unseenh ) : shift @$unseena;
          last unless defined $r;
      }
  
      return $h;
  }
  
  sub MST_Prim {
      my $g = shift;
      $g->expect_undirected;
      $g->_heap_walk(Graph::Undirected->new(), \&_MST_add, undef, @_);
  }
  
  *MST_Dijkstra = \&MST_Prim;
  
  *minimum_spanning_tree = \&MST_Prim;
  
  ###
  # Cycle detection.
  #
  
  *is_cyclic = \&has_a_cycle;
  
  sub is_acyclic {
      my $g = shift;
      return !$g->is_cyclic;
  }
  
  sub is_dag {
      my $g = shift;
      return $g->is_directed && $g->is_acyclic ? 1 : 0;
  }
  
  *is_directed_acyclic_graph = \&is_dag;
  
  ###
  # Backward compat.
  #
  
  sub average_degree {
      my $g = shift;
      my $V = $g->vertices05;
  
      return $V ? $g->degree / $V : 0;
  }
  
  sub density_limits {
      my $g = shift;
  
      my $V = $g->vertices05;
      my $M = $V * ($V - 1);
  
      $M /= 2 if $g->is_undirected;
  
      return ( 0.25 * $M, 0.75 * $M, $M );
  }
  
  sub density {
      my $g = shift;
      my ($sparse, $dense, $complete) = $g->density_limits;
  
      return $complete ? $g->edges / $complete : 0;
  }
  
  ###
  # Attribute backward compat
  #
  
  sub _attr02_012 {
      my ($g, $op, $ga, $va, $ea) = splice @_, 0, 5;
      if ($g->is_compat02) {
  	if    (@_ == 0) { return $ga->( $g ) }
  	elsif (@_ == 1) { return $va->( $g, @_ ) }
  	elsif (@_ == 2) { return $ea->( $g, @_ ) }
  	else {
  	    die sprintf "$op: wrong number of arguments (%d)", scalar @_;
  	}
      } else {
  	die "$op: not a compat02 graph"
      }
  }
  
  sub _attr02_123 {
      my ($g, $op, $ga, $va, $ea) = splice @_, 0, 5;
      if ($g->is_compat02) {
  	if    (@_ == 1) { return $ga->( $g, @_ ) }
  	elsif (@_ == 2) { return $va->( $g, @_[1, 0] ) }
  	elsif (@_ == 3) { return $ea->( $g, @_[1, 2, 0] ) }
  	else {
  	    die sprintf "$op: wrong number of arguments (%d)", scalar @_;
  	}
      } else {
  	die "$op: not a compat02 graph"
      }
  }
  
  sub _attr02_234 {
      my ($g, $op, $ga, $va, $ea) = splice @_, 0, 5;
      if ($g->is_compat02) {
  	if    (@_ == 2) { return $ga->( $g, @_ ) }
  	elsif (@_ == 3) { return $va->( $g, @_[1, 0, 2] ) }
  	elsif (@_ == 4) { return $ea->( $g, @_[1, 2, 0, 3] ) }
  	else {
  	    die sprintf "$op: wrong number of arguments (%d)", scalar @_;
  	}
      } else {
  	die "$op: not a compat02 graph";
      }
  }
  
  sub set_attribute {
      my $g = shift;
      $g->_attr02_234('set_attribute',
  		    \&Graph::set_graph_attribute,
  		    \&Graph::set_vertex_attribute,
  		    \&Graph::set_edge_attribute,
  		    @_);
  
  }
  
  sub set_attributes {
      my $g = shift;
      my $a = pop;
      $g->_attr02_123('set_attributes',
  		    \&Graph::set_graph_attributes,
  		    \&Graph::set_vertex_attributes,
  		    \&Graph::set_edge_attributes,
  		    $a, @_);
  
  }
  
  sub get_attribute {
      my $g = shift;
      $g->_attr02_123('get_attribute',
  		    \&Graph::get_graph_attribute,
  		    \&Graph::get_vertex_attribute,
  		    \&Graph::get_edge_attribute,
  		    @_);
  
  }
  
  sub get_attributes {
      my $g = shift;
      $g->_attr02_012('get_attributes',
  		    \&Graph::get_graph_attributes,
  		    \&Graph::get_vertex_attributes,
  		    \&Graph::get_edge_attributes,
  		    @_);
  
  }
  
  sub has_attribute {
      my $g = shift;
      return 0 unless @_;
      $g->_attr02_123('has_attribute',
  		    \&Graph::has_graph_attribute,
  		    \&Graph::has_vertex_attribute,
  		    \&Graph::get_edge_attribute,
  		    @_);
  
  }
  
  sub has_attributes {
      my $g = shift;
      $g->_attr02_012('has_attributes',
  		    \&Graph::has_graph_attributes,
  		    \&Graph::has_vertex_attributes,
  		    \&Graph::has_edge_attributes,
  		    @_);
  
  }
  
  sub delete_attribute {
      my $g = shift;
      $g->_attr02_123('delete_attribute',
  		    \&Graph::delete_graph_attribute,
  		    \&Graph::delete_vertex_attribute,
  		    \&Graph::delete_edge_attribute,
  		    @_);
  
  }
  
  sub delete_attributes {
      my $g = shift;
      $g->_attr02_012('delete_attributes',
  		    \&Graph::delete_graph_attributes,
  		    \&Graph::delete_vertex_attributes,
  		    \&Graph::delete_edge_attributes,
  		    @_);
  
  }
  
  ###
  # Simple DFS uses.
  #
  
  sub topological_sort {
      my $g = shift;
      my %opt = _get_options( \@_ );
      my $eic = $opt{ empty_if_cyclic };
      my $hac;
      if ($eic) {
  	$hac = $g->has_a_cycle;
      } else {
  	$g->expect_dag;
      }
      delete $opt{ empty_if_cyclic };
      my $t = Graph::Traversal::DFS->new($g, %opt);
      my @s = $t->dfs;
      $hac ? () : reverse @s;
  }
  
  *toposort = \&topological_sort;
  
  sub _undirected_copy_compute {
    my $g = shift;
    my $c = Graph::Undirected->new;
    for my $v ($g->isolated_vertices) { # TODO: if iv ...
      $c->add_vertex($v);
    }
    for my $e ($g->edges05) {
      $c->add_edge(@$e);
    }
    return $c;
  }
  
  sub undirected_copy {
      my $g = shift;
      $g->expect_directed;
      return _check_cache($g, 'undirected', \&_undirected_copy_compute);
  }
  
  *undirected_copy_graph = \&undirected_copy;
  
  sub directed_copy {
      my $g = shift;
      $g->expect_undirected;
      my $c = Graph::Directed->new;
      for my $v ($g->isolated_vertices) { # TODO: if iv ...
  	$c->add_vertex($v);
      }
      for my $e ($g->edges05) {
  	my @e = @$e;
  	$c->add_edge(@e);
  	$c->add_edge(reverse @e);
      }
      return $c;
  }
  
  *directed_copy_graph = \&directed_copy;
  
  ###
  # Cache or not.
  #
  
  my %_cache_type =
      (
       'connectivity'        => '_ccc',
       'strong_connectivity' => '_scc',
       'biconnectivity'      => '_bcc',
       'SPT_Dijkstra'        => '_spt_di',
       'SPT_Bellman_Ford'    => '_spt_bf',
       'undirected'          => '_undirected',
      );
  
  sub _check_cache {
      my ($g, $type, $code) = splice @_, 0, 3;
      my $c = $_cache_type{$type};
      if (defined $c) {
  	my $a = $g->get_graph_attribute($c);
  	unless (defined $a && $a->[ 0 ] == $g->[ _G ]) {
  	    $a->[ 0 ] = $g->[ _G ];
  	    $a->[ 1 ] = $code->( $g, @_ );
  	    $g->set_graph_attribute($c, $a);
  	}
  	return $a->[ 1 ];
      } else {
  	Carp::croak("Graph: unknown cache type '$type'");
      }
  }
  
  sub _clear_cache {
      my ($g, $type) = @_;
      my $c = $_cache_type{$type};
      if (defined $c) {
  	$g->delete_graph_attribute($c);
      } else {
  	Carp::croak("Graph: unknown cache type '$type'");
      }
  }
  
  sub connectivity_clear_cache {
      my $g = shift;
      _clear_cache($g, 'connectivity');
  }
  
  sub strong_connectivity_clear_cache {
      my $g = shift;
      _clear_cache($g, 'strong_connectivity');
  }
  
  sub biconnectivity_clear_cache {
      my $g = shift;
      _clear_cache($g, 'biconnectivity');
  }
  
  sub SPT_Dijkstra_clear_cache {
      my $g = shift;
      _clear_cache($g, 'SPT_Dijkstra');
      $g->delete_graph_attribute('SPT_Dijkstra_first_root');
  }
  
  sub SPT_Bellman_Ford_clear_cache {
      my $g = shift;
      _clear_cache($g, 'SPT_Bellman_Ford');
  }
  
  sub undirected_copy_clear_cache {
      my $g = shift;
      _clear_cache($g, 'undirected_copy');
  }
  
  ###
  # Connected components.
  #
  
  sub _connected_components_compute {
      my $g = shift;
      my %cce;
      my %cci;
      my $cc = 0;
      if ($g->has_union_find) {
  	my $UF = $g->_get_union_find();
  	my $V  = $g->[ _V ];
  	my %icce; # Isolated vertices.
  	my %icci;
  	my $icc = 0;
  	for my $v ( $g->unique_vertices ) {
  	    $cc = $UF->find( $V->_get_path_id( $v ) );
  	    if (defined $cc) {
  		$cce{ $v } = $cc;
  		push @{ $cci{ $cc } }, $v;
  	    } else {
  		$icce{ $v } = $icc;
  		push @{ $icci{ $icc } }, $v;
  		$icc++;
  	    }
  	}
  	if ($icc) {
  	    @cce{ keys %icce } = values %icce;
  	    @cci{ keys %icci } = values %icci;
  	}
      } else {
  	my @u = $g->unique_vertices;
  	my %r; @r{ @u } = @u;
  	my $froot = sub {
  	    (each %r)[1];
  	};
  	my $nroot = sub {
  	    $cc++ if keys %r;
  	    (each %r)[1];
  	};
  	my $t = Graph::Traversal::DFS->new($g,
  					   first_root => $froot,
  					   next_root  => $nroot,
  					   pre => sub {
  					       my ($v, $t) = @_;
  					       $cce{ $v } = $cc;
  					       push @{ $cci{ $cc } }, $v;
  					       delete $r{ $v };
  					   },
  					   @_);
  	$t->dfs;
      }
      return [ \%cce, \%cci ];
  }
  
  sub _connected_components {
      my $g = shift;
      my $ccc = _check_cache($g, 'connectivity',
  			   \&_connected_components_compute, @_);
      return @{ $ccc };
  }
  
  sub connected_component_by_vertex {
      my ($g, $v) = @_;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return $CCE->{ $v };
  }
  
  sub connected_component_by_index {
      my ($g, $i) = @_;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return defined $CCI->{ $i } ? @{ $CCI->{ $i } } : ( );
  }
  
  sub connected_components {
      my $g = shift;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return values %{ $CCI };
  }
  
  sub same_connected_components {
      my $g = shift;
      $g->expect_undirected;
      if ($g->has_union_find) {
  	my $UF = $g->_get_union_find();
  	my $V  = $g->[ _V ];
  	my $u = shift;
  	my $c = $UF->find( $V->_get_path_id ( $u ) );
  	my $d;
  	for my $v ( @_) {
  	    return 0
  		unless defined($d = $UF->find( $V->_get_path_id( $v ) )) &&
  		       $d eq $c;
  	}
  	return 1;
      } else {
  	my ($CCE, $CCI) = $g->_connected_components();
  	my $u = shift;
  	my $c = $CCE->{ $u };
  	for my $v ( @_ ) {
  	    return 0
  		unless defined $CCE->{ $v } &&
  		       $CCE->{ $v } eq $c;
  	}
  	return 1;
      }
  }
  
  my $super_component = sub { join("+", sort @_) };
  
  sub connected_graph {
      my ($g, %opt) = @_;
      $g->expect_undirected;
      my $cg = Graph->new(undirected => 1);
      if ($g->has_union_find && $g->vertices == 1) {
  	# TODO: super_component?
  	$cg->add_vertices($g->vertices);
      } else {
  	my $sc_cb =
  	    exists $opt{super_component} ?
  		$opt{super_component} : $super_component;
  	for my $cc ( $g->connected_components() ) {
  	    my $sc = $sc_cb->(@$cc);
  	    $cg->add_vertex($sc);
  	    $cg->set_vertex_attribute($sc, 'subvertices', [ @$cc ]);
  	}
      }
      return $cg;
  }
  
  sub is_connected {
      my $g = shift;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return keys %{ $CCI } == 1;
  }
  
  sub is_weakly_connected {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->is_connected(@_);
  }
  
  *weakly_connected = \&is_weakly_connected;
  
  sub weakly_connected_components {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_components(@_);
  }
  
  sub weakly_connected_component_by_vertex {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_component_by_vertex(@_);
  }
  
  sub weakly_connected_component_by_index {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_component_by_index(@_);
  }
  
  sub same_weakly_connected_components {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->same_connected_components(@_);
  }
  
  sub weakly_connected_graph {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_graph(@_);
  }
  
  sub _strongly_connected_components_compute {
      my $g = shift;
      my $t = Graph::Traversal::DFS->new($g);
      my @d = reverse $t->dfs;
      my @c;
      my $h = $g->transpose_graph;
      my $u =
  	Graph::Traversal::DFS->new($h,
  				   next_root => sub {
  				       my ($t, $u) = @_;
  				       my $root;
  				       while (defined($root = shift @d)) {
  					   last if exists $u->{ $root };
  				       }
  				       if (defined $root) {
  					   push @c, [];
  					   return $root;
  				       } else {
  					   return;
  				       }
  				   },
  				   pre => sub {
  				       my ($v, $t) = @_;
  				       push @{ $c[-1] }, $v;
  				   },
  				   @_);
      $u->dfs;
      return \@c;
  }
  
  sub _strongly_connected_components {
      my $g = shift;
      my $type = 'strong_connectivity';
      my $scc = _check_cache($g, $type,
  			   \&_strongly_connected_components_compute, @_);
      return defined $scc ? @$scc : ( );
  }
  
  sub strongly_connected_components {
      my $g = shift;
      $g->expect_directed;
      $g->_strongly_connected_components(@_);
  }
  
  sub strongly_connected_component_by_vertex {
      my $g = shift;
      my $v = shift;
      $g->expect_directed;
      my @scc = $g->_strongly_connected_components( next_alphabetic => 1, @_ );
      for (my $i = 0; $i <= $#scc; $i++) {
  	for (my $j = 0; $j <= $#{ $scc[$i] }; $j++) {
  	    return $i if $scc[$i]->[$j] eq $v;
  	}
      }
      return;
  }
  
  sub strongly_connected_component_by_index {
      my $g = shift;
      my $i = shift;
      $g->expect_directed;
      my $c = ( $g->_strongly_connected_components(@_) )[ $i ];
      return defined $c ? @{ $c } : ();
  }
  
  sub same_strongly_connected_components {
      my $g = shift;
      $g->expect_directed;
      my @scc = $g->_strongly_connected_components( next_alphabetic => 1, @_ );
      my @i;
      while (@_) {
  	my $v = shift;
  	for (my $i = 0; $i <= $#scc; $i++) {
  	    for (my $j = 0; $j <= $#{ $scc[$i] }; $j++) {
  		if ($scc[$i]->[$j] eq $v) {
  		    push @i, $i;
  		    return 0 if @i > 1 && $i[-1] ne $i[0];
  		}
  	    }
  	}
      }
      return 1;
  }
  
  sub is_strongly_connected {
      my $g = shift;
      $g->expect_directed;
      my $t = Graph::Traversal::DFS->new($g);
      my @d = reverse $t->dfs;
      my @c;
      my $h = $g->transpose;
      my $u =
  	Graph::Traversal::DFS->new($h,
  				   next_root => sub {
  				       my ($t, $u) = @_;
  				       my $root;
  				       while (defined($root = shift @d)) {
  					   last if exists $u->{ $root };
  				       }
  				       if (defined $root) {
  					   unless (@{ $t->{ roots } }) {
  					       push @c, [];
  					       return $root;
  					   } else {
  					       $t->terminate;
  					       return;
  					   }
  				       } else {
  					   return;
  				       }
  				   },
  				   pre => sub {
  				       my ($v, $t) = @_;
  				       push @{ $c[-1] }, $v;
  				   },
  				   @_);
      $u->dfs;
      return @{ $u->{ roots } } == 1 && keys %{ $u->{ unseen } } == 0;
  }
  
  *strongly_connected = \&is_strongly_connected;
  
  sub strongly_connected_graph {
      my $g = shift;
      my %attr = @_;
  
      $g->expect_directed;
  
      my $t = Graph::Traversal::DFS->new($g);
      my @d = reverse $t->dfs;
      my @c;
      my $h = $g->transpose;
      my $u =
  	Graph::Traversal::DFS->new($h,
  				   next_root => sub {
  				       my ($t, $u) = @_;
  				       my $root;
  				       while (defined($root = shift @d)) {
  					   last if exists $u->{ $root };
  				       }
  				       if (defined $root) {
  					   push @c, [];
  					   return $root;
  				       } else {
  					   return;
  				       }
  				   },
  				   pre => sub {
  				       my ($v, $t) = @_;
  				       push @{ $c[-1] }, $v;
  				   }
  				   );
  
      $u->dfs;
  
      my $sc_cb;
      my $hv_cb;
  
      _opt_get(\%attr, super_component => \$sc_cb);
      _opt_get(\%attr, hypervertex => \$hv_cb);
      _opt_unknown(\%attr);
  
      if (defined $hv_cb && !defined $sc_cb) {
  	$sc_cb = sub { $hv_cb->( [ @_ ] ) };
      }
      unless (defined $sc_cb) {
  	$sc_cb = $super_component;
      }
  
      my $s = Graph->new;
  
      my %c;
      my @s;
      for (my $i = 0; $i <  @c; $i++) {
  	my $c = $c[$i];
  	$s->add_vertex( $s[$i] = $sc_cb->(@$c) );
  	$s->set_vertex_attribute($s[$i], 'subvertices', [ @$c ]);
  	for my $v (@$c) {
  	    $c{$v} = $i;
  	}
      }
  
      my $n = @c;
      for my $v ($g->vertices) {
  	unless (exists $c{$v}) {
  	    $c{$v} = $n;
  	    $s[$n] = $v;
  	    $n++;
  	}
      }
  
      for my $e ($g->edges05) {
  	my ($u, $v) = @$e; # @TODO: hyperedges
  	unless ($c{$u} == $c{$v}) {
  	    my ($p, $q) = ( $s[ $c{ $u } ], $s[ $c{ $v } ] );
  	    $s->add_edge($p, $q) unless $s->has_edge($p, $q);
  	}
      }
  
      if (my @i = $g->isolated_vertices) {
  	$s->add_vertices(map { $s[ $c{ $_ } ] } @i);
      }
  
      return $s;
  }
  
  ###
  # Biconnectivity.
  #
  
  sub _biconnectivity_out {
    my ($state, $u, $v) = @_;
    if (exists $state->{stack}) {
      my @BC;
      while (@{$state->{stack}}) {
        my $e = pop @{$state->{stack}};
        push @BC, $e;
        last if defined $u && $e->[0] eq $u && $e->[1] eq $v;
      }
      if (@BC) {
        push @{$state->{BC}}, \@BC;
      }
    }
  }
  
  sub _biconnectivity_dfs {
    my ($g, $u, $state) = @_;
    $state->{num}->{$u} = $state->{dfs}++;
    $state->{low}->{$u} = $state->{num}->{$u};
    for my $v ($g->successors($u)) {
      unless (exists $state->{num}->{$v}) {
        push @{$state->{stack}}, [$u, $v];
        $state->{pred}->{$v} = $u;
        $state->{succ}->{$u}->{$v}++;
        _biconnectivity_dfs($g, $v, $state);
        if ($state->{low}->{$v} < $state->{low}->{$u}) {
  	$state->{low}->{$u} = $state->{low}->{$v};
        }
        if ($state->{low}->{$v} >= $state->{num}->{$u}) {
  	_biconnectivity_out($state, $u, $v);
        }
      } elsif (defined $state->{pred}->{$u} &&
  	     $state->{pred}->{$u} ne $v &&
  	     $state->{num}->{$v} < $state->{num}->{$u}) {
        push @{$state->{stack}}, [$u, $v];
        if ($state->{num}->{$v} < $state->{low}->{$u}) {
  	$state->{low}->{$u} = $state->{num}->{$v};
        }
      }
    }
  }
  
  sub _biconnectivity_compute {
      my ($g) = @_;
      my %state;
      @{$state{BC}} = ();
      @{$state{BR}} = ();
      %{$state{V2BC}} = ();
      %{$state{BC2V}} = ();
      @{$state{AP}} = ();
      $state{dfs} = 0;
      my @u = _shuffle $g->vertices;
      for my $u (@u) {
        unless (exists $state{num}->{$u}) {
  	_biconnectivity_dfs($g, $u, \%state);
  	_biconnectivity_out(\%state);
  	delete $state{stack};
        }
      }
  
      # Mark the components each vertex belongs to.
      my $bci = 0;
      for my $bc (@{$state{BC}}) {
        for my $e (@$bc) {
  	for my $v (@$e) {
  	  $state{V2BC}->{$v}->{$bci}++;
  	}
        }
        $bci++;
      }
  
      # Any isolated vertices get each their own component.
      for my $v ($g->vertices) {
        unless (exists $state{V2BC}->{$v}) {
  	$state{V2BC}->{$v}->{$bci++}++;
        }
      }
  
      for my $v ($g->vertices) {
        for my $bc (keys %{$state{V2BC}->{$v}}) {
  	$state{BC2V}->{$bc}->{$v}->{$bc}++;
        }
      }
  
      # Articulation points / cut vertices are the vertices
      # which belong to more than one component.
      for my $v (keys %{$state{V2BC}}) {
        if (keys %{$state{V2BC}->{$v}} > 1) {
  	push @{$state{AP}}, $v;
        }
      }
  
      # Bridges / cut edges are the components of two vertices.
      for my $v (keys %{$state{BC2V}}) {
        my @v = keys %{$state{BC2V}->{$v}};
        if (@v == 2) {
  	push @{$state{BR}}, \@v;
        }
      }
  
      # Create the subgraph components.
      my @sg;
      for my $bc (@{$state{BC}}) {
        my %v;
        my $w = Graph::Undirected->new();
        for my $e (@$bc) {
  	my ($u, $v) = @$e;
  	$v{$u}++;
  	$v{$v}++;
  	$w->add_edge($u, $v);
        }
        push @sg, [ keys %v ];
      }
  
      return [ $state{AP}, \@sg, $state{BR}, $state{V2BC}, ];
  }
  
  sub biconnectivity {
      my $g = shift;
      $g->expect_undirected;
      my $bcc = _check_cache($g, 'biconnectivity',
  			   \&_biconnectivity_compute, @_);
      return defined $bcc ? @$bcc : ( );
  }
  
  sub is_biconnected {
      my $g = shift;
      my ($ap) = ($g->biconnectivity(@_))[0];
      return $g->edges >= 2 ? @$ap == 0 : undef ;
  }
  
  sub is_edge_connected {
      my $g = shift;
      my ($br) = ($g->biconnectivity(@_))[2];
      return $g->edges >= 2 ? @$br == 0 : undef;
  }
  
  sub is_edge_separable {
      my $g = shift;
      my ($br) = ($g->biconnectivity(@_))[2];
      return $g->edges >= 2 ? @$br > 0 : undef;
  }
  
  sub articulation_points {
      my $g = shift;
      my ($ap) = ($g->biconnectivity(@_))[0];
      return @$ap;
  }
  
  *cut_vertices = \&articulation_points;
  
  sub biconnected_components {
      my $g = shift;
      my ($bc) = ($g->biconnectivity(@_))[1];
      return @$bc;
  }
  
  sub biconnected_component_by_index {
      my $g = shift;
      my $i = shift;
      my ($bc) = ($g->biconnectivity(@_))[1];
      return $bc->[ $i ];
  }
  
  sub biconnected_component_by_vertex {
      my $g = shift;
      my $v = shift;
      my ($v2bc) = ($g->biconnectivity(@_))[3];
      return defined $v2bc->{ $v } ? keys %{ $v2bc->{ $v } } : ();
  }
  
  sub same_biconnected_components {
      my $g = shift;
      my $u = shift;
      my @u = $g->biconnected_component_by_vertex($u, @_);
      return 0 unless @u;
      my %ubc; @ubc{ @u } = ();
      while (@_) {
  	my $v = shift;
  	my @v = $g->biconnected_component_by_vertex($v);
  	if (@v) {
  	    my %vbc; @vbc{ @v } = ();
  	    my $vi;
  	    for my $ui (keys %ubc) {
  		if (exists $vbc{ $ui }) {
  		    $vi = $ui;
  		    last;
  		}
  	    }
  	    return 0 unless defined $vi;
  	}
      }
      return 1;
  }
  
  sub biconnected_graph {
      my ($g, %opt) = @_;
      my ($bc, $v2bc) = ($g->biconnectivity, %opt)[1, 3];
      my $bcg = Graph::Undirected->new;
      my $sc_cb =
  	exists $opt{super_component} ?
  	    $opt{super_component} : $super_component;
      for my $c (@$bc) {
  	$bcg->add_vertex(my $s = $sc_cb->(@$c));
  	$bcg->set_vertex_attribute($s, 'subvertices', [ @$c ]);
      }
      my %k;
      for my $i (0..$#$bc) {
  	my @u = @{ $bc->[ $i ] };
  	my %i; @i{ @u } = ();
  	for my $j (0..$#$bc) {
  	    if ($i > $j) {
  		my @v = @{ $bc->[ $j ] };
  		my %j; @j{ @v } = ();
  		for my $u (@u) {
  		    if (exists $j{ $u }) {
  			unless ($k{ $i }{ $j }++) {
  			    $bcg->add_edge($sc_cb->(@{$bc->[$i]}),
  					   $sc_cb->(@{$bc->[$j]}));
  			}
  			last;
  		    }
  		}
  	    }
  	}
      }
      return $bcg;
  }
  
  sub bridges {
      my $g = shift;
      my ($br) = ($g->biconnectivity(@_))[2];
      return defined $br ? @$br : ();
  }
  
  ###
  # SPT.
  #
  
  sub _SPT_add {
      my ($g, $h, $HF, $r, $attr, $unseen, $etc) = @_;
      my $etc_r = $etc->{ $r } || 0;
      for my $s ( grep { exists $unseen->{ $_ } } $g->successors( $r ) ) {
  	my $t = $g->get_edge_attribute( $r, $s, $attr );
  	$t = 1 unless defined $t;
  	if ($t < 0) {
  	    require Carp;
  	    Carp::croak("Graph::SPT_Dijkstra: edge $r-$s is negative ($t)");
  	}
  	if (!defined($etc->{ $s }) || ($etc_r + $t) < $etc->{ $s }) {
  	    my $etc_s = $etc->{ $s } || 0;
  	    $etc->{ $s } = $etc_r + $t;
  	    # print "$r - $s : setting $s to $etc->{ $s } ($etc_r, $etc_s)\n";
  	    $h->set_vertex_attribute( $s, $attr, $etc->{ $s });
  	    $h->set_vertex_attribute( $s, 'p', $r );
  	    $HF->add( Graph::SPTHeapElem->new($r, $s, $etc->{ $s }) );
  	}
      }
  }
  
  sub _SPT_Dijkstra_compute {
  }
  
  sub SPT_Dijkstra {
      my $g = shift;
      my %opt = @_ == 1 ? (first_root => $_[0]) : @_;
      my $first_root = $opt{ first_root };
      unless (defined $first_root) {
  	$opt{ first_root } = $first_root = $g->random_vertex();
      }
      my $spt_di = $g->get_graph_attribute('_spt_di');
      unless (defined $spt_di &&
              exists $spt_di->{ $first_root } &&
              $spt_di->{ $first_root }->[ 0 ] == $g->[ _G ]) {
  	my %etc;
  	my $sptg = $g->_heap_walk($g->new, \&_SPT_add, \%etc, %opt);
  	$spt_di->{ $first_root } = [ $g->[ _G ], $sptg ];
  	$g->set_graph_attribute('_spt_di', $spt_di);
      }
  
      my $spt = $spt_di->{ $first_root }->[ 1 ];
  
      $spt->set_graph_attribute('SPT_Dijkstra_root', $first_root);
  
      return $spt;
  }
  
  *SSSP_Dijkstra = \&SPT_Dijkstra;
  
  *single_source_shortest_paths = \&SPT_Dijkstra;
  
  sub SP_Dijkstra {
      my ($g, $u, $v) = @_;
      my $sptg = $g->SPT_Dijkstra(first_root => $u);
      my @path = ($v);
      my %seen;
      my $V = $g->vertices;
      my $p;
      while (defined($p = $sptg->get_vertex_attribute($v, 'p'))) {
  	last if exists $seen{$p};
  	push @path, $p;
  	$v = $p;
  	$seen{$p}++;
  	last if keys %seen == $V || $u eq $v;
      }
      @path = () if @path && $path[-1] ne $u;
      return reverse @path;
  }
  
  sub __SPT_Bellman_Ford {
      my ($g, $u, $v, $attr, $d, $p, $c0, $c1) = @_;
      return unless $c0->{ $u };
      my $w = $g->get_edge_attribute($u, $v, $attr);
      $w = 1 unless defined $w;
      if (defined $d->{ $v }) {
  	if (defined $d->{ $u }) {
  	    if ($d->{ $v } > $d->{ $u } + $w) {
  		$d->{ $v } = $d->{ $u } + $w;
  		$p->{ $v } = $u;
  		$c1->{ $v }++;
  	    }
  	} # else !defined $d->{ $u } &&  defined $d->{ $v }
      } else {
  	if (defined $d->{ $u }) {
  	    #  defined $d->{ $u } && !defined $d->{ $v }
  	    $d->{ $v } = $d->{ $u } + $w;
  	    $p->{ $v } = $u;
  	    $c1->{ $v }++;
  	} # else !defined $d->{ $u } && !defined $d->{ $v }
      }
  }
  
  sub _SPT_Bellman_Ford {
      my ($g, $opt, $unseenh, $unseena, $r, $next, $code, $attr) = @_;
      my %d;
      return unless defined $r;
      $d{ $r } = 0;
      my %p;
      my $V = $g->vertices;
      my %c0; # Changed during the last iteration?
      $c0{ $r }++;
      for (my $i = 0; $i < $V; $i++) {
  	my %c1;
  	for my $e ($g->edges) {
  	    my ($u, $v) = @$e;
  	    __SPT_Bellman_Ford($g, $u, $v, $attr, \%d, \%p, \%c0, \%c1);
  	    if ($g->undirected) {
  		__SPT_Bellman_Ford($g, $v, $u, $attr, \%d, \%p, \%c0, \%c1);
  	    }
  	}
  	%c0 = %c1 unless $i == $V - 1;
      }
  
      for my $e ($g->edges) {
  	my ($u, $v) = @$e;
  	if (defined $d{ $u } && defined $d{ $v }) {
  	    my $d = $g->get_edge_attribute($u, $v, $attr);
  	    if (defined $d && $d{ $v } > $d{ $u } + $d) {
  		require Carp;
  		Carp::croak("Graph::SPT_Bellman_Ford: negative cycle exists");
  	    }
  	}
      }
  
      return (\%p, \%d);
  }
  
  sub _SPT_Bellman_Ford_compute {
  }
  
  sub SPT_Bellman_Ford {
      my $g = shift;
  
      my ($opt, $unseenh, $unseena, $r, $next, $code, $attr) = $g->_root_opt(@_);
  
      unless (defined $r) {
  	$r = $g->random_vertex();
  	return unless defined $r;
      }
  
      my $spt_bf = $g->get_graph_attribute('_spt_bf');
      unless (defined $spt_bf &&
  	    exists $spt_bf->{ $r } && $spt_bf->{ $r }->[ 0 ] == $g->[ _G ]) {
  	my ($p, $d) =
  	    $g->_SPT_Bellman_Ford($opt, $unseenh, $unseena,
  				  $r, $next, $code, $attr);
  	my $h = $g->new;
  	for my $v (keys %$p) {
  	    my $u = $p->{ $v };
  	    $h->add_edge( $u, $v );
  	    $h->set_edge_attribute( $u, $v, $attr,
  				    $g->get_edge_attribute($u, $v, $attr));
  	    $h->set_vertex_attribute( $v, $attr, $d->{ $v } );
  	    $h->set_vertex_attribute( $v, 'p', $u );
  	}
  	$spt_bf->{ $r } = [ $g->[ _G ], $h ];
  	$g->set_graph_attribute('_spt_bf', $spt_bf);
      }
  
      my $spt = $spt_bf->{ $r }->[ 1 ];
  
      $spt->set_graph_attribute('SPT_Bellman_Ford_root', $r);
  
      return $spt;
  }
  
  *SSSP_Bellman_Ford = \&SPT_Bellman_Ford;
  
  sub SP_Bellman_Ford {
      my ($g, $u, $v) = @_;
      my $sptg = $g->SPT_Bellman_Ford(first_root => $u);
      my @path = ($v);
      my %seen;
      my $V = $g->vertices;
      my $p;
      while (defined($p = $sptg->get_vertex_attribute($v, 'p'))) {
  	last if exists $seen{$p};
  	push @path, $p;
  	$v = $p;
  	$seen{$p}++;
  	last if keys %seen == $V;
      }
      # @path = () if @path && "$path[-1]" ne "$u";
      return reverse @path;
  }
  
  ###
  # Transitive Closure.
  #
  
  sub TransitiveClosure_Floyd_Warshall {
      my $self = shift;
      my $class = ref $self || $self;
      $self = shift unless ref $self;
      bless Graph::TransitiveClosure->new($self, @_), $class;
  }
  
  *transitive_closure = \&TransitiveClosure_Floyd_Warshall;
  
  sub APSP_Floyd_Warshall {
      my $self = shift;
      my $class = ref $self || $self;
      $self = shift unless ref $self;
      bless Graph::TransitiveClosure->new($self, path => 1, @_), $class;
  }
  
  *all_pairs_shortest_paths = \&APSP_Floyd_Warshall;
  
  sub _transitive_closure_matrix_compute {
  }
  
  sub transitive_closure_matrix {
      my $g = shift;
      my $tcm = $g->get_graph_attribute('_tcm');
      if (defined $tcm) {
  	if (ref $tcm eq 'ARRAY') { # YECHHH!
  	    if ($tcm->[ 0 ] == $g->[ _G ]) {
  		$tcm = $tcm->[ 1 ];
  	    } else {
  		undef $tcm;
  	    }
  	}
      }
      unless (defined $tcm) {
  	my $apsp = $g->APSP_Floyd_Warshall(@_);
  	$tcm = $apsp->get_graph_attribute('_tcm');
  	$g->set_graph_attribute('_tcm', [ $g->[ _G ], $tcm ]);
      }
  
      return $tcm;
  }
  
  sub path_length {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->path_length(@_);
  }
  
  sub path_predecessor {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->path_predecessor(@_);
  }
  
  sub path_vertices {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->path_vertices(@_);
  }
  
  sub is_reachable {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->is_reachable(@_);
  }
  
  sub for_shortest_paths {
      my $g = shift;
      my $c = shift;
      my $t = $g->transitive_closure_matrix;
      my @v = $g->vertices;
      my $n = 0;
      for my $u (@v) {
  	for my $v (@v) {
  	    next unless $t->is_reachable($u, $v);
  	    $n++;
  	    $c->($t, $u, $v, $n);
  	}
      }
      return $n;
  }
  
  sub _minmax_path {
      my $g = shift;
      my $min;
      my $max;
      my $minp;
      my $maxp;
      $g->for_shortest_paths(sub {
  			       my ($t, $u, $v, $n) = @_;
  			       my $l = $t->path_length($u, $v);
  			       return unless defined $l;
  			       my $p;
  			       if ($u ne $v && (!defined $max || $l > $max)) {
  				   $max = $l;
  				   $maxp = $p = [ $t->path_vertices($u, $v) ];
  			       }
  			       if ($u ne $v && (!defined $min || $l < $min)) {
  				   $min = $l;
  				   $minp = $p || [ $t->path_vertices($u, $v) ];
  			       }
  			   });
      return ($min, $max, $minp, $maxp);
  }
  
  sub diameter {
      my $g = shift;
      my ($min, $max, $minp, $maxp) = $g->_minmax_path(@_);
      return defined $maxp ? (wantarray ? @$maxp : $max) : undef;
  }
  
  *graph_diameter = \&diameter;
  
  sub longest_path {
      my ($g, $u, $v) = @_;
      my $t = $g->transitive_closure_matrix;
      if (defined $u) {
  	if (defined $v) {
  	    return wantarray ?
  		$t->path_vertices($u, $v) : $t->path_length($u, $v);
  	} else {
  	    my $max;
  	    my @max;
  	    for my $v ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $max || $l > $max)) {
  		    $max = $l;
  		    @max = $t->path_vertices($u, $v);
  		}
  	    }
  	    return wantarray ? @max : $max;
  	}
      } else {
  	if (defined $v) {
  	    my $max;
  	    my @max;
  	    for my $u ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $max || $l > $max)) {
  		    $max = $l;
  		    @max = $t->path_vertices($u, $v);
  		}
  	    }
  	    return wantarray ? @max : @max - 1;
  	} else {
  	    my ($min, $max, $minp, $maxp) = $g->_minmax_path(@_);
  	    return defined $maxp ? (wantarray ? @$maxp : $max) : undef;
  	}
      }
  }
  
  sub vertex_eccentricity {
      my ($g, $u) = @_;
      $g->expect_undirected;
      if ($g->is_connected) {
  	my $max;
  	for my $v ($g->vertices) {
  	    next if $u eq $v;
  	    my $l = $g->path_length($u, $v);
  	    if (defined $l && (!defined $max || $l > $max)) {
  		$max = $l;
  	    }
  	}
  	return defined $max ? $max : Infinity();
      } else {
  	return Infinity();
      }
  }
  
  sub shortest_path {
      my ($g, $u, $v) = @_;
      $g->expect_undirected;
      my $t = $g->transitive_closure_matrix;
      if (defined $u) {
  	if (defined $v) {
  	    return wantarray ?
  		$t->path_vertices($u, $v) : $t->path_length($u, $v);
  	} else {
  	    my $min;
  	    my @min;
  	    for my $v ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $min || $l < $min)) {
  		    $min = $l;
  		    @min = $t->path_vertices($u, $v);
  		}
  	    }
              print "min/1 = @min\n";
  	    return wantarray ? @min : $min;
  	}
      } else {
  	if (defined $v) {
  	    my $min;
  	    my @min;
  	    for my $u ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $min || $l < $min)) {
  		    $min = $l;
  		    @min = $t->path_vertices($u, $v);
  		}
  	    }
              print "min/2 = @min\n";
  	    return wantarray ? @min : $min;
  	} else {
  	    my ($min, $max, $minp, $maxp) = $g->_minmax_path(@_);
  	    return defined $minp
                ? (wantarray ? @$minp : $min)
                : wantarray ? () : undef;
  	}
      }
  }
  
  sub radius {
      my $g = shift;
      $g->expect_undirected;
      my ($center, $radius) = (undef, Infinity());
      for my $v ($g->vertices) {
  	my $x = $g->vertex_eccentricity($v);
  	($center, $radius) = ($v, $x) if defined $x && $x < $radius;
      }
      return $radius;
  }
  
  sub center_vertices {
      my ($g, $delta) = @_;
      $g->expect_undirected;
      $delta = 0 unless defined $delta;
      $delta = abs($delta);
      my @c;
      my $Inf = Infinity();
      my $r = $g->radius;
      if (defined $r && $r != $Inf) {
  	for my $v ($g->vertices) {
  	    my $e = $g->vertex_eccentricity($v);
  	    next unless defined $e && $e != $Inf;
  	    push @c, $v if abs($e - $r) <= $delta;
  	}
      }
      return @c;
  }
  
  *centre_vertices = \&center_vertices;
  
  sub average_path_length {
      my $g = shift;
      my @A = @_;
      my $d = 0;
      my $m = 0;
      my $n = $g->for_shortest_paths(sub {
  				       my ($t, $u, $v, $n) = @_;
  				       my $l = $t->path_length($u, $v);
  				       if ($l) {
  					   my $c = @A == 0 ||
  					       (@A == 1 && $u eq $A[0]) ||
  						   ((@A == 2) &&
  						    (defined $A[0] &&
  						     $u eq $A[0]) ||
  						    (defined $A[1] &&
  						     $v eq $A[1]));
  					   if ($c) {
  					       $d += $l;
  					       $m++;
  					   }
  				       }
  				   });
      return $m ? $d / $m : undef;
  }
  
  ###
  # Simple tests.
  #
  
  sub is_multi_graph {
      my $g = shift;
      return 0 unless $g->is_multiedged || $g->is_countedged;
      my $multiedges = 0;
      for my $e ($g->edges05) {
  	my ($u, @v) = @$e;
  	for my $v (@v) {
  	    return 0 if $u eq $v;
  	}
  	$multiedges++ if $g->get_edge_count(@$e) > 1;
      }
      return $multiedges;
  }
  
  sub is_simple_graph {
      my $g = shift;
      return 1 unless $g->is_countedged || $g->is_multiedged;
      for my $e ($g->edges05) {
  	return 0 if $g->get_edge_count(@$e) > 1;
      }
      return 1;
  }
  
  sub is_pseudo_graph {
      my $g = shift;
      my $m = $g->is_countedged || $g->is_multiedged;
      for my $e ($g->edges05) {
  	my ($u, @v) = @$e;
  	for my $v (@v) {
  	    return 1 if $u eq $v;
  	}
  	return 1 if $m && $g->get_edge_count($u, @v) > 1;
      }
      return 0;
  }
  
  ###
  # Rough isomorphism guess.
  #
  
  my %_factorial = (0 => 1, 1 => 1);
  
  sub __factorial {
      my $n = shift;
      for (my $i = 2; $i <= $n; $i++) {
  	next if exists $_factorial{$i};
  	$_factorial{$i} = $i * $_factorial{$i - 1};
      }
      $_factorial{$n};
  }
  
  sub _factorial {
      my $n = int(shift);
      if ($n < 0) {
  	require Carp;
  	Carp::croak("factorial of a negative number");
      }
      __factorial($n) unless exists $_factorial{$n};
      return $_factorial{$n};
  }
  
  sub could_be_isomorphic {
      my ($g0, $g1) = @_;
      return 0 unless $g0->vertices == $g1->vertices;
      return 0 unless $g0->edges05  == $g1->edges05;
      my %d0;
      for my $v0 ($g0->vertices) {
  	$d0{ $g0->in_degree($v0) }{ $g0->out_degree($v0) }++
      }
      my %d1;
      for my $v1 ($g1->vertices) {
  	$d1{ $g1->in_degree($v1) }{ $g1->out_degree($v1) }++
      }
      return 0 unless keys %d0 == keys %d1;
      for my $da (keys %d0) {
  	return 0
  	    unless exists $d1{$da} &&
  		   keys %{ $d0{$da} } == keys %{ $d1{$da} };
  	for my $db (keys %{ $d0{$da} }) {
  	    return 0
  		unless exists $d1{$da}{$db} && 
  		       $d0{$da}{$db} == $d1{$da}{$db};
  	}
      }
      for my $da (keys %d0) {
  	for my $db (keys %{ $d0{$da} }) {
  	    return 0 unless $d1{$da}{$db} == $d0{$da}{$db};
  	}
  	delete $d1{$da};
      }
      return 0 unless keys %d1 == 0;
      my $f = 1;
      for my $da (keys %d0) {
  	for my $db (keys %{ $d0{$da} }) {
  	    $f *= _factorial(abs($d0{$da}{$db}));
  	}
      }
      return $f;
  }
  
  ###
  # Analysis functions.
  
  sub subgraph_by_radius
  {
      my ($g, $n, $rad) = @_;
  
      return unless defined $n && defined $rad && $rad >= 0;
  
      my $r = (ref $g)->new;
  
      if ($rad == 0) {
  	return $r->add_vertex($n);
      }
  
      my %h;
      $h{1} = [ [ $n, $g->successors($n) ] ];
      for my $i (1..$rad) {
  	$h{$i+1} = [];
  	for my $arr (@{ $h{$i} }) {
  	    my ($p, @succ) = @{ $arr };
  	    for my $s (@succ) {
  		$r->add_edge($p, $s);
  		push(@{ $h{$i+1} }, [$s, $g->successors($s)]) if $i < $rad;
  	    }
  	}
      }
  
      return $r;
  }
  
  sub clustering_coefficient {
      my ($g) = @_;
      my %clustering;
  
      my $gamma = 0;
  
      for my $n ($g->vertices()) {
  	my $gamma_v = 0;
  	my @neigh = $g->successors($n);
  	my %c;
  	for my $u (@neigh) {
  	    for my $v (@neigh) {
  		if (!$c{"$u-$v"} && $g->has_edge($u, $v)) {
  		    $gamma_v++;
  		    $c{"$u-$v"} = 1;
  		    $c{"$v-$u"} = 1;
  		}
  	    }
  	}
  	if (@neigh > 1) {
  	    $clustering{$n} = $gamma_v/(@neigh * (@neigh - 1) / 2);
  	    $gamma += $gamma_v/(@neigh * (@neigh - 1) / 2);
  	} else {
  	    $clustering{$n} = 0;
  	}
      }
  
      $gamma /= $g->vertices();
  
      return wantarray ? ($gamma, %clustering) : $gamma;
  }
  
  sub betweenness {
      my $g = shift;
  
      my @V = $g->vertices();
  
      my %Cb; # C_b{w} = 0
  
      $Cb{$_} = 0 for @V;
  
      for my $s (@V) {
  	my @S; # stack (unshift, shift)
  
  	my %P; # P{w} = empty list
  	$P{$_} = [] for @V;
  
  	my %sigma; # \sigma{t} = 0
  	$sigma{$_} = 0 for @V;
  	$sigma{$s} = 1;
  
  	my %d; # d{t} = -1;
  	$d{$_} = -1 for @V;
  	$d{$s} = 0;
  
  	my @Q; # queue (push, shift)
  	push @Q, $s;
  
  	while (@Q) {
  	    my $v = shift @Q;
  	    unshift @S, $v;
  	    for my $w ($g->successors($v)) {
  		# w found for first time
  		if ($d{$w} < 0) {
  		    push @Q, $w;
  		    $d{$w} = $d{$v} + 1;
  		}
  		# Shortest path to w via v
  		if ($d{$w} == $d{$v} + 1) {
  		    $sigma{$w} += $sigma{$v};
  		    push @{ $P{$w} }, $v;
  		}
  	    }
  	}
  
  	my %delta;
  	$delta{$_} = 0 for @V;
  
  	while (@S) {
  	    my $w = shift @S;
  	    for my $v (@{ $P{$w} }) {
  		$delta{$v} += $sigma{$v}/$sigma{$w} * (1 + $delta{$w});
  	    }
  	    if ($w ne $s) {
  		$Cb{$w} += $delta{$w};
  	    }
  	}
      }
  
      return %Cb;
  }
  
  ###
  # Debugging.
  #
  
  sub _dump {
      require Data::Dumper;
      my $d = Data::Dumper->new([$_[0]],[ref $_[0]]);
      defined wantarray ? $d->Dump : print $d->Dump;
  }
  
  1;
GRAPH

$fatpacked{"Graph/AdjacencyMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP';
  package Graph::AdjacencyMap;
  
  use strict;
  
  require Exporter;
  use vars qw(@ISA @EXPORT_OK %EXPORT_TAGS);
  @ISA = qw(Exporter);
  @EXPORT_OK   = qw(_COUNT _MULTI _COUNTMULTI _GEN_ID
  		  _HYPER _UNORD _UNIQ _REF _UNORDUNIQ _UNIONFIND _LIGHT
  		  _STR _REFSTR
  		  _n _f _a _i _s _p _g _u _ni _nc _na _nm);
  %EXPORT_TAGS =
      (flags =>  [qw(_COUNT _MULTI _COUNTMULTI _GEN_ID
  		   _HYPER _UNORD _UNIQ _REF _UNORDUNIQ _UNIONFIND _LIGHT
  		   _STR _REFSTR)],
       fields => [qw(_n _f _a _i _s _p _g _u _ni _nc _na _nm)]);
  
  sub _COUNT       () {  0x00000001   }
  sub _MULTI       () {  0x00000002   }
  sub _COUNTMULTI  () { _COUNT|_MULTI }
  sub _HYPER       () {  0x00000004   }
  sub _UNORD       () {  0x00000008   }
  sub _UNIQ        () {  0x00000010   }
  sub _REF         () {  0x00000020   }
  sub _UNORDUNIQ   () { _UNORD|_UNIQ  }
  sub _UNIONFIND   () {  0x00000040   }
  sub _LIGHT       () {  0x00000080   }
  sub _STR         () {  0x00000100   }
  sub _REFSTR      () { _REF|_STR     }
  
  my $_GEN_ID = 0;
  
  sub _GEN_ID () { \$_GEN_ID }
  
  sub _ni () { 0 } # Node index.
  sub _nc () { 1 } # Node count.
  sub _na () { 2 } # Node attributes.
  sub _nm () { 3 } # Node map.
  
  sub _n () { 0 } # Next id.
  sub _f () { 1 } # Flags.
  sub _a () { 2 } # Arity.
  sub _i () { 3 } # Index to path.
  sub _s () { 4 } # Successors / Path to Index.
  sub _p () { 5 } # Predecessors.
  sub _g () { 6 } # Graph (AdjacencyMap::Light)
  
  sub _V () { 2 }  # Graph::_V()
  
  sub _new {
      my $class = shift;
      my $map = bless [ 0, @_ ], $class;
      return $map;
  }
  
  sub _ids {
      my $m = shift;
      return $m->[ _i ];
  }
  
  sub has_paths {
      my $m = shift;
      return defined $m->[ _i ] && keys %{ $m->[ _i ] };
  }
  
  sub _dump {
      my $d = Data::Dumper->new([$_[0]],[ref $_[0]]);
      defined wantarray ? $d->Dump : print $d->Dump;
  }
  
  sub _del_id {
      my ($m, $i) = @_;
      my @p = $m->_get_id_path( $i );
      $m->del_path( @p ) if @p;
  }
  
  sub _new_node {
      my ($m, $n, $id) = @_;
      my $f = $m->[ _f ];
      my $i = $m->[ _n ]++;
      if (($f & _MULTI)) {
  	$id = 0 if $id eq _GEN_ID;
  	$$n = [ $i, 0, undef, { $id => { } } ];
      } elsif (($f & _COUNT)) {
  	$$n = [ $i, 1 ];
      } else {
  	$$n = $i;
      }
      return $i;
  }
  
  sub _inc_node {
      my ($m, $n, $id) = @_;
      my $f = $m->[ _f ];
      if (($f & _MULTI)) {
  	if ($id eq _GEN_ID) {
  	    $$n->[ _nc ]++
  		while exists $$n->[ _nm ]->{ $$n->[ _nc ] };
  	    $id = $$n->[ _nc ];
  	}
  	$$n->[ _nm ]->{ $id } = { };
      } elsif (($f & _COUNT)) {
  	$$n->[ _nc ]++;
      }
      return $id;
  }
  
  sub __get_path_node {
      my $m = shift;
      my ($p, $k);
      my $f = $m->[ _f ];
      @_ = sort @_ if ($f & _UNORD);
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	return unless exists $m->[ _s ]->{ $_[0] };
  	$p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
  	$k = [ $_[0], $_[1] ];
      } else {
  	($p, $k) = $m->__has_path( @_ );
      }
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      return ( exists $p->[-1]->{ $l }, $p->[-1]->{ $l }, $p, $k, $l );
  }
  
  sub set_path_by_multi_id {
      my $m = shift;
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      return $m->__set_path_node( $p, $l, @_ );
  }
  
  sub get_multi_ids {
      my $m = shift;
      my $f = $m->[ _f ];
      return () unless ($f & _MULTI);
      my ($e, $n) = $m->__get_path_node( @_ );
      return $e ? keys %{ $n->[ _nm ] } : ();
  }
  
  sub _has_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	return keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } } ? 1 : 0;
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return ref $n && $#$n == _na && keys %{ $n->[ _na ] } ? 1 : 0;
      }
  }
  
  sub _set_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( @_ );
      push @_, $id if ($f & _MULTI);
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      $m->__set_path_node( $p, $l, @_ ) unless exists $p->[-1]->{ $l };
      if (($f & _MULTI)) {
  	$p->[-1]->{ $l }->[ _nm ]->{ $id } = $attr;
      } else {
  	# Extend the node if it is a simple id node.
  	$p->[-1]->{ $l } = [ $p->[-1]->{ $l }, 1 ] unless ref $p->[-1]->{ $l };
  	$p->[-1]->{ $l }->[ _na ] = $attr;
      }
  }
  
  sub _has_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	exists $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return ref $n && $#$n == _na ? exists $n->[ _na ]->{ $attr } : undef;
      }
  }
  
  sub _set_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $val  = pop;
      my $attr = pop;
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      my ($p, $k);
      $m->__attr( \@_ ); # _LIGHT maps need this to get upgraded when needed.
      push @_, $id if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_REF|_UNIQ|_HYPER|_UNIQ))) {
  	$m->[ _s ]->{ $_[0] } ||= { };
  	$p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
  	$k = [ $_[0], $_[1] ];
      } else {
  	($p, $k) = $m->__set_path( @_ );
      }
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      $m->__set_path_node( $p, $l, @_ ) unless exists $p->[-1]->{ $l };
      if (($f & _MULTI)) {
  	$p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr } = $val;
      } else {
  	# Extend the node if it is a simple id node.
  	$p->[-1]->{ $l } = [ $p->[-1]->{ $l }, 1 ] unless ref $p->[-1]->{ $l };
  	$p->[-1]->{ $l }->[ _na ]->{ $attr } = $val;
      }
      return $val;
  }
  
  sub _get_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	$p->[-1]->{ $l }->[ _nm ]->{ $id };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return unless $e;
  	return $n->[ _na ] if ref $n && $#$n == _na;
  	return;
      }
  }
  
  sub _get_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	return $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return ref $n && $#$n == _na ? $n->[ _na ]->{ $attr } : undef;
      }
  }
  
  sub _get_path_attr_names {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return keys %{ $n->[ _na ] } if ref $n && $#$n == _na;
  	return;
      }
  }
  
  sub _get_path_attr_values {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	values %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return values %{ $n->[ _na ] } if ref $n && $#$n == _na;
  	return;
      }
  }
  
  sub _del_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	delete $p->[-1]->{ $l }->[ _nm ]->{ $id };
  	unless (keys %{ $p->[-1]->{ $l }->[ _nm ] } ||
  		(defined $p->[-1]->{ $l }->[ _na ] &&
  		 keys %{ $p->[-1]->{ $l }->[ _na ] })) {
  	    delete $p->[-1]->{ $l };
  	}
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	if (ref $n) {
  	    $e = _na == $#$n && keys %{ $n->[ _na ] } ? 1 : 0;
  	    $#$n = _na - 1;
  	    return $e;
  	} else {
  	    return 0;
  	}
      }
  }
  
  sub _del_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	delete $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr };
  	$m->_del_path_attrs( @_, $id )
  	    unless keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	if (ref $n && $#$n == _na && exists $n->[ _na ]->{ $attr }) {
  	    delete $n->[ _na ]->{ $attr };
  	    return 1;
  	} else {
  	    return 0;
  	}
      }
  }
  
  sub _is_COUNT { $_[0]->[ _f ] & _COUNT }
  sub _is_MULTI { $_[0]->[ _f ] & _MULTI }
  sub _is_HYPER { $_[0]->[ _f ] & _HYPER }
  sub _is_UNORD { $_[0]->[ _f ] & _UNORD }
  sub _is_UNIQ  { $_[0]->[ _f ] & _UNIQ  }
  sub _is_REF   { $_[0]->[ _f ] & _REF   }
  sub _is_STR   { $_[0]->[ _f ] & _STR   }
  
  sub __arg {
      my $m = shift;
      my $f = $m->[ _f ];
      my @a = @{$_[0]};
      if ($f & _UNIQ) {
  	my %u;
  	if ($f & _UNORD) {
  	    @u{ @a } = @a;
  	    @a = values %u;
  	} else {
  	    my @u;
  	    for my $e (@a) {
  		push @u, $e if $u{$e}++ == 0;
  	    }
  	    @a = @u;
  	}
      }
      # Alphabetic or numeric sort, does not matter as long as it unifies.
      @{$_[0]} = ($f & _UNORD) ? sort @a : @a;
  }
  
  sub _successors {
      my $E = shift;
      my $g = shift;
      my $V = $g->[ _V ];
      map { my @v = @{ $_->[ 1 ] };
  	  shift @v;
  	  map { $V->_get_id_path($_) } @v } $g->_edges_from( @_ );
  }
  
  sub _predecessors {
      my $E = shift;
      my $g = shift;
      my $V = $g->[ _V ];
      if (wantarray) {
  	map { my @v = @{ $_->[ 1 ] };
  	      pop @v;
  	      map { $V->_get_id_path($_) } @v } $g->_edges_to( @_ );
      } else {
  	return $g->_edges_to( @_ );
      }
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::AdjacencyMap - create and a map of graph vertices or edges
  
  =head1 SYNOPSIS
  
      Internal.
  
  =head1 DESCRIPTION
  
  B<This module is meant for internal use by the Graph module.>
  
  =head2 Object Methods
  
  =over 4
  
  =item del_path(@id)
  
  Delete a Map path by ids.
  
  =item del_path_by_multi_id($id)
  
  Delete a Map path by a multi(vertex) id.
  
  =item get_multi_ids
  
  Return the multi ids.
  
  =item has_path(@id)
  
  Return true if the Map has the path by ids, false if not.
  
  =item has_paths
  
  Return true if the Map has any paths, false if not.
  
  =item has_path_by_multi_id($id)
  
  Return true if the Map has the path by a multi(vertex) id, false if not.
  
  =item paths
  
  Return all the paths of the Map.
  
  =item set_path(@id)
  
  Set the path by @ids.
  
  =item set_path_by_multi_id
  
  Set the path in the Map by the multi id.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_ADJACENCYMAP

$fatpacked{"Graph/AdjacencyMap/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP_HEAVY';
  package Graph::AdjacencyMap::Heavy;
  
  # THIS IS INTERNAL IMPLEMENTATION ONLY, NOT TO BE USED DIRECTLY.
  # THE INTERFACE IS HARD TO USE AND GOING TO STAY THAT WAY AND
  # ALMOST GUARANTEED TO CHANGE OR GO AWAY IN FUTURE RELEASES.
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use Graph::AdjacencyMap qw(:flags :fields);
  use base 'Graph::AdjacencyMap';
  
  require overload; # for de-overloading
  
  require Data::Dumper;
  
  sub __set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      if (@_ != $m->[ _a ] && !($f & _HYPER)) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Heavy: arguments %d expected %d",
  		      scalar @_, $m->[ _a ]);
      }
      my $p;
      $p = ($f & _HYPER) ?
  	(( $m->[ _s ] ||= [ ] )->[ @_ ] ||= { }) :
  	(  $m->[ _s ]                   ||= { });
      my @p = $p;
      my @k;
      @_ = sort @_ if ($m->[ _f ] & _UNORD);
      while (@_) {
  	my $k = shift;
  	my $q = ref $k && ($f & _REF) && overload::Method($k, '""') ? overload::StrVal($k) : $k;
  	if (@_) {
  	    $p = $p->{ $q } ||= {};
  	    return unless $p;
  	    push @p, $p;
  	}
  	push @k, $q;
      }
      return (\@p, \@k);
  }
  
  sub __set_path_node {
      my ($m, $p, $l) = splice @_, 0, 3;
      my $f = $m->[ _f ] ;
      my $id = pop if ($f & _MULTI);
      unless (exists $p->[-1]->{ $l }) {
  	my $i = $m->_new_node( \$p->[-1]->{ $l }, $id );
  	$m->[ _i ]->{ defined $i ? $i : "" } = [ @_ ];
          return defined $id ? ($id eq _GEN_ID ? $$id : $id) : $i;
      } else {
  	return $m->_inc_node( \$p->[-1]->{ $l }, $id );
      }
  }
  
  sub set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      return if @_ == 0 && !($f & _HYPER);
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      return $m->__set_path_node( $p, $l, @_ );
  }
  
  sub __has_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ != $m->[ _a ] && !($f & _HYPER)) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Heavy: arguments %d expected %d",
  		      scalar @_, $m->[ _a ]);
      }
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my $p = $m->[ _s ];
      return unless defined $p;
      $p = $p->[ @_ ] if ($f & _HYPER);
      return unless defined $p;
      my @p = $p;
      my @k;
      while (@_) {
  	my $k = shift;
  	my $q = ref $k && ($f & _REF) && overload::Method($k, '""') ? overload::StrVal($k) : $k;
  	if (@_) {
  	    $p = $p->{ $q };
  	    return unless defined $p;
  	    push @p, $p;
  	}
  	push @k, $q;
      }
      return (\@p, \@k);
  }
  
  sub has_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($p, $k) = $m->__has_path( @_ );
      return unless defined $p && defined $k;
      return exists $p->[-1]->{ defined $k->[-1] ? $k->[-1] : "" };
  }
  
  sub has_path_by_multi_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop;
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($e, $n) = $m->__get_path_node( @_ );
      return undef unless $e;
      return exists $n->[ _nm ]->{ $id };
  }
  
  sub _get_path_node {
      my $m = shift;
      my $f = $m->[ _f ];
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	return unless exists $m->[ _s ]->{ $_[0] };
  	my $p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
  	my $k = [ $_[0], $_[1] ];
  	my $l = $_[1];
  	return ( exists $p->[-1]->{ $l }, $p->[-1]->{ $l }, $p, $k, $l );
      } else {
  	if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	    if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
  	    else { $m->__arg(\@_) }
  	}
  	$m->__get_path_node( @_ );
      }
  }
  
  sub _get_path_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n);
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	return unless exists $m->[ _s ]->{ $_[0] };
  	my $p = $m->[ _s ]->{ $_[0] };
  	$e = exists $p->{ $_[1] };
  	$n = $p->{ $_[1] };
      } else {
  	($e, $n) = $m->_get_path_node( @_ );
      }
      return undef unless $e;
      return ref $n ? $n->[ _ni ] : $n;
  }
  
  sub _get_path_count {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n) = $m->_get_path_node( @_ );
      return undef unless $e && defined $n;
      return
  	($f & _COUNT) ? $n->[ _nc ] :
  	($f & _MULTI) ? scalar keys %{ $n->[ _nm ] } : 1;
  }
  
  sub __attr {
      my $m = shift;
      if (@_) {
  	if (ref $_[0] && @{ $_[0] }) {
  	    if (@{ $_[0] } != $m->[ _a ]) {
  		require Carp;
  		Carp::confess(sprintf
  			      "Graph::AdjacencyMap::Heavy: arguments %d expected %d\n",
  			      scalar @{ $_[0] }, $m->[ _a ]);
  	    }
  	    my $f = $m->[ _f ];
  	    if (@{ $_[0] } > 1 && ($f & _UNORDUNIQ)) {
  		if (($f & _UNORDUNIQ) == _UNORD && @{ $_[0] } == 2) {
  		    @{ $_[0] } = sort @{ $_[0] }
  		} else { $m->__arg(\@_) }
  	    }
  	}
      }
  }
  
  sub _get_id_path {
      my ($m, $i) = @_;
      my $p = defined $i ? $m->[ _i ]->{ $i } : undef;
      return defined $p ? @$p : ( );
  }
  
  sub del_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      my $c = ($f & _COUNT) ? --$n->[ _nc ] : 0;
      if ($c == 0) {
  	delete $m->[ _i ]->{ ref $n ? $n->[ _ni ] : $n };
  	delete $p->[-1]->{ $l };
  	while (@$p && @$k && keys %{ $p->[-1]->{ $k->[-1] } } == 0) {
  	    delete $p->[-1]->{ $k->[-1] };
  	    pop @$p;
  	    pop @$k;
  	}
      }
      return 1;
  }
  
  sub del_path_by_multi_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop;
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      delete $n->[ _nm ]->{ $id };
      unless (keys %{ $n->[ _nm ] }) {
  	delete $m->[ _i ]->{ $n->[ _ni ] };
  	delete $p->[-1]->{ $l };
  	while (@$p && @$k && keys %{ $p->[-1]->{ $k->[-1] } } == 0) {
  	    delete $p->[-1]->{ $k->[-1] };
  	    pop @$p;
  	    pop @$k;
  	}
      }
      return 1;
  }
  
  sub paths {
      my $m = shift;
      return values %{ $m->[ _i ] } if defined $m->[ _i ];
      wantarray ? ( ) : 0;
  }
  
  1;
  __END__
GRAPH_ADJACENCYMAP_HEAVY

$fatpacked{"Graph/AdjacencyMap/Light.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP_LIGHT';
  package Graph::AdjacencyMap::Light;
  
  # THIS IS INTERNAL IMPLEMENTATION ONLY, NOT TO BE USED DIRECTLY.
  # THE INTERFACE IS HARD TO USE AND GOING TO STAY THAT WAY AND
  # ALMOST GUARANTEED TO CHANGE OR GO AWAY IN FUTURE RELEASES.
  
  use strict;
  
  use Graph::AdjacencyMap qw(:flags :fields);
  use base 'Graph::AdjacencyMap';
  
  use Scalar::Util qw(weaken);
  
  use Graph::AdjacencyMap::Heavy;
  use Graph::AdjacencyMap::Vertex;
  
  sub _V () { 2 } # Graph::_V
  sub _E () { 3 } # Graph::_E
  sub _F () { 0 } # Graph::_F
  
  sub _new {
      my ($class, $graph, $flags, $arity) = @_;
      my $m = bless [ ], $class;
      $m->[ _n ] = 0;
      $m->[ _f ] = $flags | _LIGHT;
      $m->[ _a ] = $arity;
      $m->[ _i ] = { };
      $m->[ _s ] = { };
      $m->[ _p ] = { };
      $m->[ _g ] = $graph;
      weaken $m->[ _g ]; # So that DESTROY finds us earlier.
      return $m;
  }
  
  sub set_path {
      my $m = shift;
      return if @_ == 0 && !($m->[ _f ] & _HYPER);
      my ($n, $f, $a, $i, $s, $p) = @$m;
      if ($a == 2) {
  	@_ = sort @_ if ($f & _UNORD);
      }
      my $e0 = shift;
      if ($a == 2) {
  	my $e1 = shift;
  	unless (exists $s->{ $e0 } && exists $s->{ $e0 }->{ $e1 }) {
  	    $n = $m->[ _n ]++;
  	    $i->{ $n } = [ $e0, $e1 ];
  	    $s->{ $e0 }->{ $e1 } = $n;
  	    $p->{ $e1 }->{ $e0 } = $n;
  	}
      } else {
  	unless (exists $s->{ $e0 }) {
  	    $n = $m->[ _n ]++;
  	    $s->{ $e0 } = $n;
  	    $i->{ $n } = $e0;
  	}
      }
  }
  
  sub has_path {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      return 0 unless $a == @_;
      my $e;
      if ($a == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	$e = shift;
  	return 0 unless exists $s->{ $e };
          $s = $s->{ $e };
      }
      $e = shift;
      exists $s->{ $e };
  }
  
  sub _get_path_id {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      return undef unless $a == @_;
      my $e;
      if ($a == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	$e = shift;
  	return undef unless exists $s->{ $e };
          $s = $s->{ $e };
      }
      $e = shift;
      $s->{ $e };
  }
  
  sub _get_path_count {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      my $e;
      if (@_ == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	$e = shift;
  	return undef unless exists $s->{ $e };
          $s = $s->{ $e };
      }
      $e = shift;
      return exists $s->{ $e } ? 1 : 0;
  }
  
  sub has_paths {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      keys %$s;
  }
  
  sub paths {
      my $m = shift;
      my ($n, $f, $a, $i) = @$m;
      if (defined $i) {
  	my ($k, $v) = each %$i;
  	if (ref $v) {
  	    return values %{ $i };
  	} else {
  	    return map { [ $_ ] } values %{ $i };
  	}
      } else {
  	return ( );
      }
  }
  
  sub _get_id_path {
      my $m = shift;
      my ($n, $f, $a, $i) = @$m;
      my $p = $i->{ $_[ 0 ] };
      defined $p ? ( ref $p eq 'ARRAY' ? @$p : $p ) : ( );
  }
  
  sub del_path {
      my $m = shift;
      my ($n, $f, $a, $i, $s, $p) = @$m;
      if (@_ == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	my $e0 = shift;
  	return 0 unless exists $s->{ $e0 };
  	my $e1 = shift;
  	if (defined($n = $s->{ $e0 }->{ $e1 })) {
  	    delete $i->{ $n };
              delete $s->{ $e0 }->{ $e1 };
              delete $p->{ $e1 }->{ $e0 };
  	    delete $s->{ $e0 } unless keys %{ $s->{ $e0 } };
  	    delete $p->{ $e1 } unless keys %{ $p->{ $e1 } };
  	    return 1;
  	}
      } else {
  	my $e = shift;
  	if (defined($n = $s->{ $e })) {
  	    delete $i->{ $n };
  	    delete $s->{ $e };
  	    return 1;
  	}
      }
      return 0;
  }
  
  sub __successors {
      my $E = shift;
      return wantarray ? () : 0 unless defined $E->[ _s ];
      my $g = shift;
      my $V = $g->[ _V ];
      return wantarray ? () : 0 unless defined $V && defined $V->[ _s ];
      # my $i = $V->_get_path_id( $_[0] );
      my $i =
  	($V->[ _f ] & _LIGHT) ?
  	    $V->[ _s ]->{ $_[0] } :
  	    $V->_get_path_id( $_[0] );
      return wantarray ? () : 0 unless defined $i && defined $E->[ _s ]->{ $i };
      return keys %{ $E->[ _s ]->{ $i } };
  }
  
  sub _successors {
      my $E = shift;
      my $g = shift;
      my @s = $E->__successors($g, @_);
      if (($E->[ _f ] & _UNORD)) {
  	push @s, $E->__predecessors($g, @_);
  	my %s; @s{ @s } = ();
  	@s = keys %s;
      }
      my $V = $g->[ _V ];
      return wantarray ? map { $V->[ _i ]->{ $_ } } @s : @s;
  }
  
  sub __predecessors {
      my $E = shift;
      return wantarray ? () : 0 unless defined $E->[ _p ];
      my $g = shift;
      my $V = $g->[ _V ];
      return wantarray ? () : 0 unless defined $V && defined $V->[ _s ];
      # my $i = $V->_get_path_id( $_[0] );
      my $i =
  	($V->[ _f ] & _LIGHT) ?
  	    $V->[ _s ]->{ $_[0] } :
  	    $V->_get_path_id( $_[0] );
      return wantarray ? () : 0 unless defined $i && defined $E->[ _p ]->{ $i };
      return keys %{ $E->[ _p ]->{ $i } };
  }
  
  sub _predecessors {
      my $E = shift;
      my $g = shift;
      my @p = $E->__predecessors($g, @_);
      if ($E->[ _f ] & _UNORD) {
  	push @p, $E->__successors($g, @_);
  	my %p; @p{ @p } = ();
  	@p = keys %p;
      }
      my $V = $g->[ _V ];
      return wantarray ? map { $V->[ _i ]->{ $_ } } @p : @p;
  }
  
  sub __attr {
      # Major magic takes place here: we rebless the appropriate 'light'
      # map into a more complex map and then redispatch the method.
      my $m = $_[0];
      my ($n, $f, $a, $i, $s, $p, $g) = @$m;
      my ($k, $v) = each %$i;
      my @V = @{ $g->[ _V ] };
      my @E = $g->edges; # TODO: Both these (ZZZ) lines are mysteriously needed!
      # ZZZ: an example of failing tests is t/52_edge_attributes.t.
      if (ref $v eq 'ARRAY') { # Edges, then.
  	# print "Reedging.\n";
  	@E = $g->edges; # TODO: Both these (ZZZ) lines are mysteriously needed!
  	$g->[ _E ] = $m = Graph::AdjacencyMap::Heavy->_new($f, 2);
  	$g->add_edges( @E );
      } else {
  	# print "Revertexing.\n";
  	$m = Graph::AdjacencyMap::Vertex->_new(($f & ~_LIGHT), 1);
  	$m->[ _n ] = $V[ _n ];
  	$m->[ _i ] = $V[ _i ];
  	$m->[ _s ] = $V[ _s ];
  	$m->[ _p ] = $V[ _p ];
  	$g->[ _V ] = $m;
      }
      $_[0] = $m;
      goto &{ ref($m) . "::__attr" }; # Redispatch.
  }
  
  sub _is_COUNT    () { 0 }
  sub _is_MULTI    () { 0 }
  sub _is_HYPER    () { 0 }
  sub _is_UNIQ     () { 0 }
  sub _is_REF      () { 0 }
  
  1;
GRAPH_ADJACENCYMAP_LIGHT

$fatpacked{"Graph/AdjacencyMap/Vertex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP_VERTEX';
  package Graph::AdjacencyMap::Vertex;
  
  # THIS IS INTERNAL IMPLEMENTATION ONLY, NOT TO BE USED DIRECTLY.
  # THE INTERFACE IS HARD TO USE AND GOING TO STAY THAT WAY AND
  # ALMOST GUARANTEED TO CHANGE OR GO AWAY IN FUTURE RELEASES.
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use Graph::AdjacencyMap qw(:flags :fields);
  use base 'Graph::AdjacencyMap';
  
  use Scalar::Util qw(weaken);
  
  sub _new {
      my ($class, $flags, $arity) = @_;
      bless [ 0, $flags, $arity ], $class;
  }
  
  require overload; # for de-overloading
  
  sub __strval {
    my ($k, $f) = @_;
    ref $k && ($f & _REF) &&
      (($f & _STR) ? !overload::Method($k, '""') : overload::Method($k, '""')) ?
  	overload::StrVal($k) : $k;
  }
  
  sub __set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      if (@_ != 1) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Vertex: arguments %d expected 1", scalar @_);
      }
      my $p;
      $p = $m->[ _s ] ||= { };
      my @p = $p;
      my @k;
      my $k = shift;
      my $q = __strval($k, $f);
      push @k, $q;
      return (\@p, \@k);
  }
  
  sub __set_path_node {
      my ($m, $p, $l) = splice @_, 0, 3;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      unless (exists $p->[-1]->{ $l }) {
  	my $i = $m->_new_node( \$p->[-1]->{ $l }, $id );
  	$m->[ _i ]->{ defined $i ? $i : "" } = $_[0];
      } else {
  	$m->_inc_node( \$p->[-1]->{ $l }, $id );
      }
  }
  
  sub set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      my $set = $m->__set_path_node( $p, $l, @_ );
      return $set;
  }
  
  sub __has_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ != 1) {
  	require Carp;
  	Carp::confess(sprintf
  		      "Graph::AdjacencyMap: arguments %d expected 1\n",
  		      scalar @_);
      }
      my $p = $m->[ _s ];
      return unless defined $p;
      my @p = $p;
      my @k;
      my $k = shift;
      my $q = __strval($k, $f);
      push @k, $q;
      return (\@p, \@k);
  }
  
  sub has_path {
      my $m = shift;
      my ($p, $k) = $m->__has_path( @_ );
      return unless defined $p && defined $k;
      return exists $p->[-1]->{ defined $k->[-1] ? $k->[-1] : "" };
  }
  
  sub has_path_by_multi_id {
      my $m = shift;
      my $id = pop;
      my ($e, $n) = $m->__get_path_node( @_ );
      return undef unless $e;
      return exists $n->[ _nm ]->{ $id };
  }
  
  sub _get_path_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n) = $m->__get_path_node( @_ );
      return undef unless $e;
      return ref $n ? $n->[ _ni ] : $n;
  }
  
  sub _get_path_count {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n) = $m->__get_path_node( @_ );
      return 0 unless $e && defined $n;
      return
  	($f & _COUNT) ? $n->[ _nc ] :
  	($f & _MULTI) ? scalar keys %{ $n->[ _nm ] } : 1;
  }
  
  sub __attr {
      my $m = shift;
      if (@_ && ref $_[0] && @{ $_[0] } != $m->[ _a ]) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Vertex: arguments %d expected %d",
  		      scalar @{ $_[0] }, $m->[ _a ]);
      }
  }
  
  sub _get_id_path {
      my ($m, $i) = @_;
      return defined $m->[ _i ] ? $m->[ _i ]->{ $i } : undef;
  }
  
  sub del_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      my $c = ($f & _COUNT) ? --$n->[ _nc ] : 0;
      if ($c == 0) {
  	delete $m->[ _i ]->{ ref $n ? $n->[ _ni ] : $n };
  	delete $p->[ -1 ]->{ $l };
      }
      return 1;
  }
  
  sub del_path_by_multi_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop;
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      delete $n->[ _nm ]->{ $id };
      unless (keys %{ $n->[ _nm ] }) {
  	delete $m->[ _i ]->{ $n->[ _ni ] };
  	delete $p->[-1]->{ $l };
      }
      return 1;
  }
  
  sub paths {
      my $m = shift;
      return map { [ $_ ] } values %{ $m->[ _i ] } if defined $m->[ _i ];
      wantarray ? ( ) : 0;
  }
  
  1;
  =pod
  
  =head1 NAME
  
  Graph::AdjacencyMap - create and a map of graph vertices or edges
  
  =head1 SYNOPSIS
  
      Internal.
  
  =head1 DESCRIPTION
  
  B<This module is meant for internal use by the Graph module.>
  
  =head2 Object Methods
  
  =over 4
  
  =item del_path(@id)
  
  Delete a Map path by ids.
  
  =item del_path_by_multi_id($id)
  
  Delete a Map path by a multi(vertex) id.
  
  =item has_path(@id)
  
  Return true if the Map has the path by ids, false if not.
  
  =item has_path_by_multi_id($id)
  
  Return true ifd the a Map has the path by a multi(vertex) id, false if not.
  
  =item paths
  
  Return all the paths of the Map.
  
  =item set_path(@id)
  
  Set the path by @ids.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_ADJACENCYMAP_VERTEX

$fatpacked{"Graph/AdjacencyMatrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMATRIX';
  package Graph::AdjacencyMatrix;
  
  use strict;
  
  use Graph::BitMatrix;
  use Graph::Matrix;
  
  use base 'Graph::BitMatrix';
  
  use Graph::AdjacencyMap qw(:flags :fields);
  
  sub _V () { 2 } # Graph::_V
  sub _E () { 3 } # Graph::_E
  
  sub new {
      my ($class, $g, %opt) = @_;
      my $n;
      my @V = $g->vertices;
      my $want_distance;
      if (exists $opt{distance_matrix}) {
  	$want_distance = $opt{distance_matrix};
  	delete $opt{distance_matrix};
      }
      my $d = Graph::_defattr();
      if (exists $opt{attribute_name}) {
  	$d = $opt{attribute_name};
  	$want_distance++;
      }
      delete $opt{attribute_name};
      my $want_transitive = 0;
      if (exists $opt{is_transitive}) {
  	$want_transitive = $opt{is_transitive};
  	delete $opt{is_transitive};
      }
      Graph::_opt_unknown(\%opt);
      if ($want_distance) {
  	$n = Graph::Matrix->new($g);
  	for my $v (@V) { $n->set($v, $v, 0) }
      }
      my $m = Graph::BitMatrix->new($g, connect_edges => $want_distance);
      if ($want_distance) {
  	# for my $u (@V) {
  	#     for my $v (@V) {
  	#         if ($g->has_edge($u, $v)) {
  	#             $n->set($u, $v,
  	#                    $g->get_edge_attribute($u, $v, $d));
          #        }
          #     }
          # }
  	my $Vi = $g->[_V]->[_i];
  	my $Ei = $g->[_E]->[_i];
  	my %V; @V{ @V } = 0 .. $#V;
  	my $n0 = $n->[0];
  	my $n1 = $n->[1];
  	if ($g->is_undirected) {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		my $i1 = $V{ $Vi->{ $i0 } };
  		my $j1 = $V{ $Vi->{ $j0 } };
  		my $u = $V[ $i1 ];
  		my $v = $V[ $j1 ];
  		$n0->[ $i1 ]->[ $j1 ] = 
  		    $g->get_edge_attribute($u, $v, $d);
  		$n0->[ $j1 ]->[ $i1 ] =
  		    $g->get_edge_attribute($v, $u, $d);
  	    }
  	} else {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		my $i1 = $V{ $Vi->{ $i0 } };
  		my $j1 = $V{ $Vi->{ $j0 } };
  		my $u = $V[ $i1 ];
  		my $v = $V[ $j1 ];
  		$n0->[ $i1 ]->[ $j1 ] =
  		    $g->get_edge_attribute($u, $v, $d);
  	    }
  	}
      }
      bless [ $m, $n, [ @V ] ], $class;
  }
  
  sub adjacency_matrix {
      my $am = shift;
      $am->[0];
  }
  
  sub distance_matrix {
      my $am = shift;
      $am->[1];
  }
  
  sub vertices {
      my $am = shift;
      @{ $am->[2] };
  }
  
  sub is_adjacent {
      my ($m, $u, $v) = @_;
      $m->[0]->get($u, $v) ? 1 : 0;
  }
  
  sub distance {
      my ($m, $u, $v) = @_;
      defined $m->[1] ? $m->[1]->get($u, $v) : undef;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::AdjacencyMatrix - create and query the adjacency matrix of graph G
  
  =head1 SYNOPSIS
  
      use Graph::AdjacencyMatrix;
      use Graph::Directed; # or Undirected
  
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
  
      my $am = Graph::AdjacencyMatrix->new($g);
      $am->is_adjacent($u, $v)
  
      my $am = Graph::AdjacencyMatrix->new($g, distance_matrix => 1);
      $am->distance($u, $v)
  
      my $am = Graph::AdjacencyMatrix->new($g, attribute_name => 'length');
      $am->distance($u, $v)
  
      my $am = Graph::AdjacencyMatrix->new($g, ...);
      my @V  = $am->vertices();
  
  =head1 DESCRIPTION
  
  You can use C<Graph::AdjacencyMatrix> to compute the adjacency matrix
  and optionally also the distance matrix of a graph, and after that
  query the adjacencyness between vertices by using the C<is_adjacent()>
  method, or query the distance between vertices by using the
  C<distance()> method.
  
  By default the edge attribute used for distance is C<w>, but you
  can change that in new(), see below.
  
  If you modify the graph after creating the adjacency matrix of it,
  the adjacency matrix and the distance matrix may become invalid.
  
  =head1 Methods
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Construct the adjacency matrix of the graph $g.
  
  =item new($g, options)
  
  Construct the adjacency matrix of the graph $g with options as a hash.
  The known options are
  
  =over 8
  
  =item distance_matrix => boolean
  
  By default only the adjacency matrix is computed.  To compute also the
  distance matrix, use the attribute C<distance_matrix> with a true value
  to the new() constructor.
  
  =item attribute_name => attribute_name
  
  By default the edge attribute used for distance is C<w>.  You can
  change that by giving another attribute name with the C<attribute_name>
  attribute to new() constructor.  Using this attribute also implicitly
  causes the distance matrix to be computed.
  
  =back
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item is_adjacent($u, $v)
  
  Return true if the vertex $v is adjacent to vertex $u, or false if not.
  
  =item distance($u, $v)
  
  Return the distance between the vertices $u and $v, or C<undef> if
  the vertices are not adjacent.
  
  =item adjacency_matrix
  
  Return the adjacency matrix itself (a list of bitvector scalars).
  
  =item vertices
  
  Return the list of vertices (useful for indexing the adjacency matrix).
  
  =back
  
  =head1 ALGORITHM
  
  The algorithm used to create the matrix is two nested loops, which is
  O(V**2) in time, and the returned matrices are O(V**2) in space.
  
  =head1 SEE ALSO
  
  L<Graph::TransitiveClosure>, L<Graph::BitMatrix>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_ADJACENCYMATRIX

$fatpacked{"Graph/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ATTRIBUTE';
  package Graph::Attribute;
  
  use strict;
  
  sub _F () { 0 }
  sub _COMPAT02 () { 0x00000001 }
  
  sub import {
      my $package = shift;
      my %attr = @_;
      my $caller = caller(0);
      if (exists $attr{array}) {
  	my $i = $attr{array};
  	no strict 'refs';
  	*{"${caller}::_get_attributes"} = sub { $_[0]->[ $i ] };
  	*{"${caller}::_set_attributes"} =
  	    sub { $_[0]->[ $i ] ||= { };
  		  $_[0]->[ $i ] = $_[1] if @_ == 2;
  		  $_[0]->[ $i ] };
  	*{"${caller}::_has_attributes"} = sub { defined $_[0]->[ $i ] };
  	*{"${caller}::_delete_attributes"} = sub { undef $_[0]->[ $i ]; 1 };
      } elsif (exists $attr{hash}) {
  	my $k = $attr{hash};
  	no strict 'refs';
  	*{"${caller}::_get_attributes"} = sub { $_[0]->{ $k } };
  	*{"${caller}::_set_attributes"} =
  	    sub { $_[0]->{ $k } ||= { };
  		  $_[0]->{ $k } = $_[1] if @_ == 2;
  		  $_[0]->{ $k } };
  	*{"${caller}::_has_attributes"} = sub { defined $_[0]->{ $k } };
  	*{"${caller}::_delete_attributes"} = sub { delete $_[0]->{ $k } };
      } else {
  	die "Graph::Attribute::import($package @_) caller $caller\n";
      }
      my @api = qw(get_attribute
  		 get_attributes
  		 set_attribute
  		 set_attributes
  		 has_attribute
  		 has_attributes
  		 delete_attribute
  		 delete_attributes
  		 get_attribute_names
  		 get_attribute_values);
      if (exists $attr{map}) {
  	my $map = $attr{map};
  	for my $api (@api) {
  	    my ($first, $rest) = ($api =~ /^(\w+?)_(.+)/);
  	    no strict 'refs';
  	    *{"${caller}::${first}_${map}_${rest}"} = \&$api;
  	}
      }
  }
  
  sub set_attribute {
      my $g = shift;
      my $v = pop;
      my $a = pop;
      my $p = $g->_set_attributes;
      $p->{ $a } = $v;
      return 1;
  }
  
  sub set_attributes {
      my $g = shift;
      my $a = pop;
      my $p = $g->_set_attributes( $a );
      return 1;
  }
  
  sub has_attribute {
      my $g = shift;
      my $a = pop;
      my $p = $g->_get_attributes;
      $p ? exists $p->{ $a } : 0;
  }
  
  sub has_attributes {
      my $g = shift;
      $g->_get_attributes ? 1 : 0;
  }
  
  sub get_attribute {
      my $g = shift;
      my $a = pop;
      my $p = $g->_get_attributes;
      $p ? $p->{ $a } : undef;
  }
  
  sub delete_attribute {
      my $g = shift;
      my $a = pop;
      my $p = $g->_get_attributes;
      if (defined $p) {
  	delete $p->{ $a };
  	return 1;
      } else {
  	return 0;
      }
  }
  
  sub delete_attributes {
      my $g = shift;
      if ($g->_has_attributes) {
  	$g->_delete_attributes;
  	return 1;
      } else {
  	return 0;
      }
  }
  
  sub get_attribute_names {
      my $g = shift;
      my $p = $g->_get_attributes;
      defined $p ? keys %{ $p } : ( );
  }
  
  sub get_attribute_values {
      my $g = shift;
      my $p = $g->_get_attributes;
      defined $p ? values %{ $p } : ( );
  }
  
  sub get_attributes {
      my $g = shift;
      my $a = $g->_get_attributes;
      ($g->[ _F ] & _COMPAT02) ? (defined $a ? %{ $a } : ()) : $a;
  }
  
  1;
GRAPH_ATTRIBUTE

$fatpacked{"Graph/BitMatrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_BITMATRIX';
  package Graph::BitMatrix;
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  sub _V () { 2 } # Graph::_V()
  sub _E () { 3 } # Graph::_E()
  sub _i () { 3 } # Index to path.
  sub _s () { 4 } # Successors / Path to Index.
  
  sub new {
      my ($class, $g, %opt) = @_;
      my @V = $g->vertices;
      my $V = @V;
      my $Z = "\0" x (($V + 7) / 8);
      my %V; @V{ @V } = 0 .. $#V;
      my $bm = bless [ [ ( $Z ) x $V ], \%V ], $class;
      my $bm0 = $bm->[0];
      my $connect_edges;
      if (exists $opt{connect_edges}) {
  	$connect_edges = $opt{connect_edges};
  	delete $opt{connect_edges};
      }
      $connect_edges = 1 unless defined $connect_edges;
      Graph::_opt_unknown(\%opt);
      if ($connect_edges) {
  	# for (my $i = 0; $i <= $#V; $i++) {
  	#    my $u = $V[$i];
  	#    for (my $j = 0; $j <= $#V; $j++) {
  	#	vec($bm0->[$i], $j, 1) = 1 if $g->has_edge($u, $V[$j]);
  	#    }
  	# }
  	my $Vi = $g->[_V]->[_i];
  	my $Ei = $g->[_E]->[_i];
  	if ($g->is_undirected) {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		my $i1 = $V{ $Vi->{ $i0 } };
  		my $j1 = $V{ $Vi->{ $j0 } };
  		vec($bm0->[$i1], $j1, 1) = 1;
  		vec($bm0->[$j1], $i1, 1) = 1;
  	    }
  	} else {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		vec($bm0->[$V{ $Vi->{ $i0 } }], $V{ $Vi->{ $j0 } }, 1) = 1;
  	    }
  	}
      }
      return $bm;
  }
  
  sub set {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      vec($m->[0]->[$i], $j, 1) = 1 if defined $i && defined $j;
  }
  
  sub unset {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      vec($m->[0]->[$i], $j, 1) = 0 if defined $i && defined $j;
  }
  
  sub get {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      defined $i && defined $j ? vec($m->[0]->[$i], $j, 1) : undef;
  }
  
  sub set_row {
      my ($m, $u) = splice @_, 0, 2;
      my $m0 = $m->[0];
      my $m1 = $m->[1];
      my $i = $m1->{ $u };
      return unless defined $i;
      for my $v (@_) {
  	my $j = $m1->{ $v };
  	vec($m0->[$i], $j, 1) = 1 if defined $j;
      }
  }
  
  sub unset_row {
      my ($m, $u) = splice @_, 0, 2;
      my $m0 = $m->[0];
      my $m1 = $m->[1];
      my $i = $m1->{ $u };
      return unless defined $i;
      for my $v (@_) {
  	my $j = $m1->{ $v };
  	vec($m0->[$i], $j, 1) = 0 if defined $j;
      }
  }
  
  sub get_row {
      my ($m, $u) = splice @_, 0, 2;
      my $m0 = $m->[0];
      my $m1 = $m->[1];
      my $i = $m1->{ $u };
      return () x @_ unless defined $i;
      my @r;
      for my $v (@_) {
  	my $j = $m1->{ $v };
  	push @r, defined $j ? (vec($m0->[$i], $j, 1) ? 1 : 0) : undef;
      }
      return @r;
  }
  
  sub vertices {
      my ($m, $u, $v) = @_;
      keys %{ $m->[1] };
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::BitMatrix - create and manipulate a V x V bit matrix of graph G
  
  =head1 SYNOPSIS
  
      use Graph::BitMatrix;
      use Graph::Directed;
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
      my $m = Graph::BitMatrix->new($g, %opt);
      $m->get($u, $v)
      $m->set($u, $v)
      $m->unset($u, $v)
      $m->get_row($u, $v1, $v2, ..., $vn)
      $m->set_row($u, $v1, $v2, ..., $vn)
      $m->unset_row($u, $v1, $v2, ..., $vn)
      $a->vertices()
  
  =head1 DESCRIPTION
  
  This class enables creating bit matrices that compactly describe
  the connected of the graphs.
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Create a bit matrix from a Graph $g.  The C<%opt>, if present,
  can have the following options:
  
  =over 8
  
  =item *
  
  connect_edges
  
  If true or if not present, set the bits in the bit matrix that
  correspond to edges.  If false, do not set any bits.  In either
  case the bit matrix of V x V bits is allocated.
  
  =back
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item get($u, $v)
  
  Return true if the bit matrix has a "one bit" between the vertices
  $u and $v; in other words, if there is (at least one) a vertex going from
  $u to $v.  If there is no vertex and therefore a "zero bit", return false.
  
  =item set($u, $v)
  
  Set the bit between the vertices $u and $v; in other words, connect
  the vertices $u and $v by an edge.  The change does not get mirrored
  back to the original graph.  Returns nothing.
  
  =item unset($u, $v)
  
  Unset the bit between the vertices $u and $v; in other words, disconnect
  the vertices $u and $v by an edge.  The change does not get mirrored
  back to the original graph.  Returns nothing.
  
  =item get_row($u, $v1, $v2, ..., $vn)
  
  Test the row at vertex C<u> for the vertices C<v1>, C<v2>, ..., C<vn>
  Returns a list of I<n> truth values.
  
  =item set_row($u, $v1, $v2, ..., $vn)
  
  Sets the row at vertex C<u> for the vertices C<v1>, C<v2>, ..., C<vn>,
  in other words, connects the vertex C<u> to the vertices C<vi>.
  The changes do not get mirrored back to the original graph.
  Returns nothing.
  
  =item unset_row($u, $v1, $v2, ..., $vn)
  
  Unsets the row at vertex C<u> for the vertices C<v1>, C<v2>, ..., C<vn>,
  in other words, disconnects the vertex C<u> from the vertices C<vi>.
  The changes do not get mirrored back to the original graph.
  Returns nothing.
  
  =item vertices
  
  Return the list of vertices in the bit matrix.
  
  =back
  
  =head1 ALGORITHM
  
  The algorithm used to create the matrix is two nested loops, which is
  O(V**2) in time, and the returned matrices are O(V**2) in space.
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_BITMATRIX

$fatpacked{"Graph/Directed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_DIRECTED';
  package Graph::Directed;
  
  use Graph;
  use base 'Graph';
  use strict;
  
  =pod
  
  =head1 NAME
  
  Graph::Directed - directed graphs
  
  =head1 SYNOPSIS
  
      use Graph::Directed;
      my $g = Graph::Directed->new;
  
      # Or alternatively:
  
      use Graph;
      my $g = Graph->new(directed => 1);
      my $g = Graph->new(undirected => 0);
  
  =head1 DESCRIPTION
  
  Graph::Directed allows you to create directed graphs.
  
  For the available methods, see L<Graph>.
  
  =head1 SEE ALSO
  
  L<Graph>, L<Graph::Undirected>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
  
  1;
GRAPH_DIRECTED

$fatpacked{"Graph/MSTHeapElem.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_MSTHEAPELEM';
  package Graph::MSTHeapElem;
  
  use strict;
  use vars qw($VERSION @ISA);
  use Heap071::Elem;
  
  use base 'Heap071::Elem';
  
  sub new {
      my $class = shift;
      bless { u => $_[0], v => $_[1], w => $_[2] }, $class;
  }
  
  sub cmp {
      ($_[0]->{ w } || 0) <=> ($_[1]->{ w } || 0);
  }
  
  sub val {
      @{ $_[0] }{ qw(u v w) };
  }
  
  1;
GRAPH_MSTHEAPELEM

$fatpacked{"Graph/Matrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_MATRIX';
  package Graph::Matrix;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use strict;
  
  sub new {
      my ($class, $g) = @_;
      my @V = $g->vertices;
      my $V = @V;
      my %V; @V{ @V } = 0 .. $#V;
      bless [ [ map { [ ] } 0 .. $#V ], \%V ], $class;
  }
  
  sub set {
      my ($m, $u, $v, $val) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      $m->[0]->[$i]->[$j] = $val;
  }
  
  sub get {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      $m->[0]->[$i]->[$j];
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Matrix - create and manipulate a V x V matrix of graph G
  
  =head1 SYNOPSIS
  
      use Graph::Matrix;
      use Graph::Directed;
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
      my $m = Graph::Matrix->new($g);
      $m->get($u, $v)
      $s->get($u, $v, $val)
  
  =head1 DESCRIPTION
  
  B<This module is meant for internal use by the Graph module.>
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Construct a new Matrix from the Graph $g.
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item get($u, $v)
  
  Return the value at the edge from $u to $v.
  
  =item set($u, $v, $val)
  
  Set the edge from $u to $v to value $val.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_MATRIX

$fatpacked{"Graph/SPTHeapElem.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_SPTHEAPELEM';
  package Graph::SPTHeapElem;
  
  use strict;
  use vars qw($VERSION @ISA);
  use Heap071::Elem;
  
  use base 'Heap071::Elem';
  
  sub new {
      my $class = shift;
      bless { u => $_[0], v => $_[1], w => $_[2] }, $class;
  }
  
  sub cmp {
      ($_[0]->{ w } || 0) <=> ($_[1]->{ w } || 0) ||
      ($_[0]->{ u } cmp $_[1]->{ u }) ||
      ($_[0]->{ u } cmp $_[1]->{ v });
  }
  
  sub val {
      @{ $_[0] }{ qw(u v w) };
  }
  
  1;
GRAPH_SPTHEAPELEM

$fatpacked{"Graph/TransitiveClosure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRANSITIVECLOSURE';
  package Graph::TransitiveClosure;
  
  use strict;
  
  # COMMENT THESE OUT FOR TESTING AND PRODUCTION.
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use base 'Graph';
  use Graph::TransitiveClosure::Matrix;
  
  sub _G () { Graph::_G() }
  
  sub new {
      my ($class, $g, %opt) = @_;
      $g->expect_non_multiedged;
      %opt = (path_vertices => 1) unless %opt;
      my $attr = Graph::_defattr();
      if (exists $opt{ attribute_name }) {
  	$attr = $opt{ attribute_name };
  	# No delete $opt{ attribute_name } since we need to pass it on.
      }
      $opt{ reflexive } = 1 unless exists $opt{ reflexive };
      my $tcm = $g->new( $opt{ reflexive } ?
  		       ( vertices => [ $g->vertices ] ) : ( ) );
      my $tcg = $g->get_graph_attribute('_tcg');
      if (defined $tcg && $tcg->[ 0 ] == $g->[ _G ]) {
  	$tcg = $tcg->[ 1 ];
      } else {
  	$tcg = Graph::TransitiveClosure::Matrix->new($g, %opt);
  	$g->set_graph_attribute('_tcg', [ $g->[ _G ], $tcg ]);
      }
      my $tcg00 = $tcg->[0]->[0];
      my $tcg11 = $tcg->[1]->[1];
      for my $u ($tcg->vertices) {
  	my $tcg00i = $tcg00->[ $tcg11->{ $u } ];
  	for my $v ($tcg->vertices) {
  	    next if $u eq $v && ! $opt{ reflexive };
  	    my $j = $tcg11->{ $v };
  	    if (
  		# $tcg->is_transitive($u, $v)
  		# $tcg->[0]->get($u, $v)
  		vec($tcg00i, $j, 1)
  	       ) {
  		my $val = $g->_get_edge_attribute($u, $v, $attr);
  		$tcm->_set_edge_attribute($u, $v, $attr,
  					  defined $val ? $val :
  					  $u eq $v ?
  					  0 : 1);
  	    }
  	}
      }
      $tcm->set_graph_attribute('_tcm', $tcg);
      bless $tcm, $class;
  }
  
  sub is_transitive {
      my $g = shift;
      $g->expect_no_args(@_);
      Graph::TransitiveClosure::Matrix::is_transitive($g);
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::TransitiveClosure - create and query transitive closure of graph
  
  =head1 SYNOPSIS
  
      use Graph::TransitiveClosure;
      use Graph::Directed; # or Undirected
  
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
  
      # Compute the transitive closure graph.
      my $tcg = Graph::TransitiveClosure->new($g);
      $tcg->is_reachable($u, $v) # Identical to $tcg->has_edge($u, $v)
  
      # Being reflexive is the default, meaning that null transitions
      # (transitions from a vertex to the same vertex) are included.
      my $tcg = Graph::TransitiveClosure->new($g, reflexive => 1);
      my $tcg = Graph::TransitiveClosure->new($g, reflexive => 0);
  
      # is_reachable(u, v) is always reflexive.
      $tcg->is_reachable($u, $v)
  
      # You can check any graph for transitivity.
      $g->is_transitive()
  
      my $tcg = Graph::TransitiveClosure->new($g, path_length => 1);
      $tcg->path_length($u, $v)
  
      # path_vertices is automatically always on so this is a no-op.
      my $tcg = Graph::TransitiveClosure->new($g, path_vertices => 1);
      $tcg->path_vertices($u, $v)
  
      # Both path_length and path_vertices.
      my $tcg = Graph::TransitiveClosure->new($g, path => 1);
      $tcg->path_vertices($u, $v)
      $tcg->length($u, $v)
  
      my $tcg = Graph::TransitiveClosure->new($g, attribute_name => 'length');
      $tcg->path_length($u, $v)
  
  =head1 DESCRIPTION
  
  You can use C<Graph::TransitiveClosure> to compute the transitive
  closure graph of a graph and optionally also the minimum paths
  (lengths and vertices) between vertices, and after that query the
  transitiveness between vertices by using the C<is_reachable()> and
  C<is_transitive()> methods, and the paths by using the
  C<path_length()> and C<path_vertices()> methods.
  
  For further documentation, see the L<Graph::TransitiveClosure::Matrix>.
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g, %opt)
  
  Construct a new transitive closure object.  Note that strictly speaking
  the returned object is not a graph; it is a graph plus other stuff.  But
  you should be able to use it as a graph plus a couple of methods inherited
  from the Graph::TransitiveClosure::Matrix class.
  
  =back
  
  =head2 Object Methods
  
  These are only the methods 'native' to the class: see
  L<Graph::TransitiveClosure::Matrix> for more.
  
  =over 4
  
  =item is_transitive($g)
  
  Return true if the Graph $g is transitive.
  
  =item transitive_closure_matrix
  
  Return the transitive closure matrix of the transitive closure object.
  
  =back
  
  =head2 INTERNALS
  
  The transitive closure matrix is stored as an attribute of the graph
  called C<_tcm>, and any methods not found in the graph class are searched
  in the transitive closure matrix class. 
  
  =cut
GRAPH_TRANSITIVECLOSURE

$fatpacked{"Graph/TransitiveClosure/Matrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRANSITIVECLOSURE_MATRIX';
  package Graph::TransitiveClosure::Matrix;
  
  use strict;
  
  use Graph::AdjacencyMatrix;
  use Graph::Matrix;
  
  sub _new {
      my ($g, $class, $opt, $want_transitive, $want_reflexive, $want_path, $want_path_vertices) = @_;
      my $m = Graph::AdjacencyMatrix->new($g, %$opt);
      my @V = $g->vertices;
      my $am = $m->adjacency_matrix;
      my $dm; # The distance matrix.
      my $pm; # The predecessor matrix.
      my @di;
      my %di; @di{ @V } = 0..$#V;
      my @ai = @{ $am->[0] };
      my %ai = %{ $am->[1] };
      my @pi;
      my %pi;
      unless ($want_transitive) {
  	$dm = $m->distance_matrix;
  	@di = @{ $dm->[0] };
  	%di = %{ $dm->[1] };
  	$pm = Graph::Matrix->new($g);
  	@pi = @{ $pm->[0] };
  	%pi = %{ $pm->[1] };
  	for my $u (@V) {
  	    my $diu = $di{$u};
  	    my $aiu = $ai{$u};
  	    for my $v (@V) {
  		my $div = $di{$v};
  		my $aiv = $ai{$v};
  		next unless
  		    # $am->get($u, $v)
  		    vec($ai[$aiu], $aiv, 1)
  			;
  		# $dm->set($u, $v, $u eq $v ? 0 : 1)
  		$di[$diu]->[$div] = $u eq $v ? 0 : 1
  		    unless
  			defined
  			    # $dm->get($u, $v)
  			    $di[$diu]->[$div]
  			    ;
  		$pi[$diu]->[$div] = $v unless $u eq $v;
  	    }
  	}
      }
      # XXX (see the bits below): sometimes, being nice and clean is the
      # wrong thing to do.  In this case, using the public API for graph
      # transitive matrices and bitmatrices makes things awfully slow.
      # Instead, we go straight for the jugular of the data structures.
      for my $u (@V) {
  	my $diu = $di{$u};
  	my $aiu = $ai{$u};
  	my $didiu = $di[$diu];
  	my $aiaiu = $ai[$aiu];
  	for my $v (@V) {
  	    my $div = $di{$v};
  	    my $aiv = $ai{$v};
  	    my $didiv = $di[$div];
  	    my $aiaiv = $ai[$aiv];
  	    if (
  		# $am->get($v, $u)
  		vec($aiaiv, $aiu, 1)
  		|| ($want_reflexive && $u eq $v)) {
  		my $aivivo = $aiaiv;
  		if ($want_transitive) {
  		    if ($want_reflexive) {
  			for my $w (@V) {
  			    next if $w eq $u;
  			    my $aiw = $ai{$w};
  			    return 0
  				if  vec($aiaiu, $aiw, 1) &&
  				   !vec($aiaiv, $aiw, 1);
  			}
  			# See XXX above.
  			# for my $w (@V) {
  			#    my $aiw = $ai{$w};
  			#    if (
  			#	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#	|| ($u eq $w)) {
  			#	return 0
  			#	    if $u ne $w &&
  			#		# !$am->get($v, $w)
  			#		!vec($aiaiv, $aiw, 1)
  			#		    ;
  			#	# $am->set($v, $w)
  			#	vec($aiaiv, $aiw, 1) = 1
  			#	    ;
  			#     }
  			# }
  		    } else {
  			# See XXX above.
  			# for my $w (@V) {
  			#     my $aiw = $ai{$w};
  			#     if (
  			#	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#       ) {
  			#	return 0
  			#	    if $u ne $w &&
  			#		# !$am->get($v, $w)
  			#		!vec($aiaiv, $aiw, 1)
  			#		    ;
  			# 	# $am->set($v, $w)
  			# 	vec($aiaiv, $aiw, 1) = 1
  			# 	    ;
  			#     }
  			# }
  			$aiaiv |= $aiaiu;
  		    }
  		} else {
  		    if ($want_reflexive) {
  			$aiaiv |= $aiaiu;
  			vec($aiaiv, $aiu, 1) = 1;
  			# See XXX above.
  			# for my $w (@V) {
  			#     my $aiw = $ai{$w};
  			#     if (
  			# 	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#	|| ($u eq $w)) {
  			#	# $am->set($v, $w)
  			#	vec($aiaiv, $aiw, 1) = 1
  			#	    ;
  			#     }
  			# }
  		    } else {
  			$aiaiv |= $aiaiu;
  			# See XXX above.
  			# for my $w (@V) {
  			#    my $aiw = $ai{$w};
  			#    if (
  			#	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#       ) {
  			#	# $am->set($v, $w)
  			#	vec($aiaiv, $aiw, 1) = 1
  			#	    ;
  			#     }
  			# }
  		    }
  		}
  		if ($aiaiv ne $aivivo) {
  		    $ai[$aiv] = $aiaiv;
  		    $aiaiu = $aiaiv if $u eq $v;
  		}
  	    }
  	    if ($want_path && !$want_transitive) {
  		for my $w (@V) {
  		    my $aiw = $ai{$w};
  		    next unless
  			# See XXX above.
  			# $am->get($v, $u)
  			vec($aiaiv, $aiu, 1)
  			    &&
  			# See XXX above.
  			# $am->get($u, $w)
  			vec($aiaiu, $aiw, 1)
  			    ;
  		    my $diw = $di{$w};
  		    my ($d0, $d1a, $d1b);
  		    if (defined $dm) {
  			# See XXX above.
  			# $d0  = $dm->get($v, $w);
  			# $d1a = $dm->get($v, $u) || 1;
  			# $d1b = $dm->get($u, $w) || 1;
  			$d0  = $didiv->[$diw];
  			$d1a = $didiv->[$diu] || 1;
  			$d1b = $didiu->[$diw] || 1;
  		    } else {
  			$d1a = 1;
  			$d1b = 1;
  		    }
  		    my $d1 = $d1a + $d1b;
  		    if (!defined $d0 || ($d1 < $d0)) {
  			# print "d1 = $d1a ($v, $u) + $d1b ($u, $w) = $d1 ($v, $w) (".(defined$d0?$d0:"-").")\n";
  			# See XXX above.
  			# $dm->set($v, $w, $d1);
  			$didiv->[$diw] = $d1;
  			$pi[$div]->[$diw] = $pi[$div]->[$diu]
  			    if $want_path_vertices;
  		    }
  		}
  		# $dm->set($u, $v, 1)
  		$didiu->[$div] = 1
  		    if $u ne $v &&
  		       # $am->get($u, $v)
  		       vec($aiaiu, $aiv, 1)
  			   &&
  		       # !defined $dm->get($u, $v);
  		       !defined $didiu->[$div];
  	    }
  	}
      }
      return 1 if $want_transitive;
      my %V; @V{ @V } = @V;
      $am->[0] = \@ai;
      $am->[1] = \%ai;
      if (defined $dm) {
  	$dm->[0] = \@di;
  	$dm->[1] = \%di;
      }
      if (defined $pm) {
  	$pm->[0] = \@pi;
  	$pm->[1] = \%pi;
      }
      bless [ $am, $dm, $pm, \%V ], $class;
  }
  
  sub new {
      my ($class, $g, %opt) = @_;
      my %am_opt = (distance_matrix => 1);
      if (exists $opt{attribute_name}) {
  	$am_opt{attribute_name} = $opt{attribute_name};
  	delete $opt{attribute_name};
      }
      if ($opt{distance_matrix}) {
  	$am_opt{distance_matrix} = $opt{distance_matrix};
      }
      delete $opt{distance_matrix};
      if (exists $opt{path}) {
  	$opt{path_length}   = $opt{path};
  	$opt{path_vertices} = $opt{path};
  	delete $opt{path};
      }
      my $want_path_length;
      if (exists $opt{path_length}) {
  	$want_path_length = $opt{path_length};
  	delete $opt{path_length};
      }
      my $want_path_vertices;
      if (exists $opt{path_vertices}) {
  	$want_path_vertices = $opt{path_vertices};
  	delete $opt{path_vertices};
      }
      my $want_reflexive;
      if (exists $opt{reflexive}) {
  	$want_reflexive = $opt{reflexive};
  	delete $opt{reflexive};
      }
      my $want_transitive;
      if (exists $opt{is_transitive}) {
  	$want_transitive = $opt{is_transitive};
  	$am_opt{is_transitive} = $want_transitive;
  	delete $opt{is_transitive};
      }
      die "Graph::TransitiveClosure::Matrix::new: Unknown options: @{[map { qq['$_' => $opt{$_}]} keys %opt]}"
  	if keys %opt;
      $want_reflexive = 1 unless defined $want_reflexive;
      my $want_path = $want_path_length || $want_path_vertices;
      # $g->expect_dag if $want_path;
      _new($g, $class,
  	 \%am_opt,
  	 $want_transitive, $want_reflexive,
  	 $want_path, $want_path_vertices);
  }
  
  sub has_vertices {
      my $tc = shift;
      for my $v (@_) {
  	return 0 unless exists $tc->[3]->{ $v };
      }
      return 1;
  }
  
  sub is_reachable {
      my ($tc, $u, $v) = @_;
      return undef unless $tc->has_vertices($u, $v);
      return 1 if $u eq $v;
      $tc->[0]->get($u, $v);
  }
  
  sub is_transitive {
      if (@_ == 1) {	# Any graph.
  	__PACKAGE__->new($_[0], is_transitive => 1);	# Scary.
      } else {		# A TC graph.
  	my ($tc, $u, $v) = @_;
  	return undef unless $tc->has_vertices($u, $v);
  	$tc->[0]->get($u, $v);
      }
  }
  
  sub vertices {
      my $tc = shift;
      values %{ $tc->[3] };
  }
  
  sub path_length {
      my ($tc, $u, $v) = @_;
      return undef unless $tc->has_vertices($u, $v);
      return 0 if $u eq $v;
      $tc->[1]->get($u, $v);
  }
  
  sub path_predecessor {
      my ($tc, $u, $v) = @_;
      return undef if $u eq $v;
      return undef unless $tc->has_vertices($u, $v);
      $tc->[2]->get($u, $v);
  }
  
  sub path_vertices {
      my ($tc, $u, $v) = @_;
      return unless $tc->is_reachable($u, $v);
      return wantarray ? () : 0 if $u eq $v;
      my @v = ( $u );
      while ($u ne $v) {
  	last unless defined($u = $tc->path_predecessor($u, $v));
  	push @v, $u;
      }
      $tc->[2]->set($u, $v, [ @v ]) if @v;
      return @v;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::TransitiveClosure::Matrix - create and query transitive closure of graph
  
  =head1 SYNOPSIS
  
      use Graph::TransitiveClosure::Matrix;
      use Graph::Directed; # or Undirected
  
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
  
      # Compute the transitive closure matrix.
      my $tcm = Graph::TransitiveClosure::Matrix->new($g);
  
      # Being reflexive is the default,
      # meaning that null transitions are included.
      my $tcm = Graph::TransitiveClosure::Matrix->new($g, reflexive => 1);
      $tcm->is_reachable($u, $v)
  
      # is_reachable(u, v) is always reflexive.
      $tcm->is_reachable($u, $v)
  
      # The reflexivity of is_transitive(u, v) depends of the reflexivity
      # of the transitive closure.
      $tcg->is_transitive($u, $v)
  
      my $tcm = Graph::TransitiveClosure::Matrix->new($g, path_length => 1);
      my $n = $tcm->path_length($u, $v)
  
      my $tcm = Graph::TransitiveClosure::Matrix->new($g, path_vertices => 1);
      my @v = $tcm->path_vertices($u, $v)
  
      my $tcm =
          Graph::TransitiveClosure::Matrix->new($g,
                                                attribute_name => 'length');
      my $n = $tcm->path_length($u, $v)
  
      my @v = $tcm->vertices
  
  =head1 DESCRIPTION
  
  You can use C<Graph::TransitiveClosure::Matrix> to compute the
  transitive closure matrix of a graph and optionally also the minimum
  paths (lengths and vertices) between vertices, and after that query
  the transitiveness between vertices by using the C<is_reachable()> and
  C<is_transitive()> methods, and the paths by using the
  C<path_length()> and C<path_vertices()> methods.
  
  If you modify the graph after computing its transitive closure,
  the transitive closure and minimum paths may become invalid.
  
  =head1 Methods
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Construct the transitive closure matrix of the graph $g.
  
  =item new($g, options)
  
  Construct the transitive closure matrix of the graph $g with options
  as a hash. The known options are
  
  =over 8
  
  =item C<attribute_name> => I<attribute_name>
  
  By default the edge attribute used for distance is C<w>.  You can
  change that by giving another attribute name with the C<attribute_name>
  attribute to the new() constructor.
  
  =item reflexive => boolean
  
  By default the transitive closure matrix is not reflexive: that is,
  the adjacency matrix has zeroes on the diagonal.  To have ones on
  the diagonal, use true for the C<reflexive> option.
  
  B<NOTE>: this behaviour has changed from Graph 0.2xxx: transitive
  closure graphs were by default reflexive.
  
  =item path_length => boolean
  
  By default the path lengths are not computed, only the boolean transitivity.
  By using true for C<path_length> also the path lengths will be computed,
  they can be retrieved using the path_length() method.
  
  =item path_vertices => boolean
  
  By default the paths are not computed, only the boolean transitivity.
  By using true for C<path_vertices> also the paths will be computed,
  they can be retrieved using the path_vertices() method.
  
  =back
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item is_reachable($u, $v)
  
  Return true if the vertex $v is reachable from the vertex $u,
  or false if not.
  
  =item path_length($u, $v)
  
  Return the minimum path length from the vertex $u to the vertex $v,
  or undef if there is no such path.
  
  =item path_vertices($u, $v)
  
  Return the minimum path (as a list of vertices) from the vertex $u to
  the vertex $v, or an empty list if there is no such path, OR also return
  an empty list if $u equals $v.
  
  =item has_vertices($u, $v, ...)
  
  Return true if the transitive closure matrix has all the listed vertices,
  false if not.
  
  =item is_transitive($u, $v)
  
  Return true if the vertex $v is transitively reachable from the vertex $u,
  false if not.
  
  =item vertices
  
  Return the list of vertices in the transitive closure matrix.
  
  =item path_predecessor
  
  Return the predecessor of vertex $v in the transitive closure path
  going back to vertex $u.
  
  =back
  
  =head1 RETURN VALUES
  
  For path_length() the return value will be the sum of the appropriate
  attributes on the edges of the path, C<weight> by default.  If no
  attribute has been set, one (1) will be assumed.
  
  If you try to ask about vertices not in the graph, undefs and empty
  lists will be returned.
  
  =head1 ALGORITHM
  
  The transitive closure algorithm used is Warshall and Floyd-Warshall
  for the minimum paths, which is O(V**3) in time, and the returned
  matrices are O(V**2) in space.
  
  =head1 SEE ALSO
  
  L<Graph::AdjacencyMatrix>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_TRANSITIVECLOSURE_MATRIX

$fatpacked{"Graph/Traversal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRAVERSAL';
  package Graph::Traversal;
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  sub DEBUG () { 0 }
  
  sub reset {
      my $self = shift;
      $self->{ unseen } = { map { $_ => $_ } $self->{ graph }->vertices };
      $self->{ seen   } = { };
      $self->{ order     } = [ ];
      $self->{ preorder  } = [ ];
      $self->{ postorder } = [ ];
      $self->{ roots     } = [ ];
      $self->{ tree      } =
  	Graph->new( directed => $self->{ graph }->directed );
      delete $self->{ terminate };
  }
  
  my $see = sub {
      my $self = shift;
      $self->see;
  };
  
  my $see_active = sub {
      my $self = shift;
      delete @{ $self->{ active } }{ $self->see };
  };
  
  sub has_a_cycle {
      my ($u, $v, $t, $s) = @_;
      $s->{ has_a_cycle } = 1;
      $t->terminate;
  }
  
  sub find_a_cycle {
      my ($u, $v, $t, $s) = @_;
      my @cycle = ( $u );
      push @cycle, $v unless $u eq $v;
      my $path  = $t->{ order };
      if (@$path) {
  	my $i = $#$path;
  	while ($i >= 0 && $path->[ $i ] ne $v) { $i-- }
  	if ($i >= 0) {
  	    unshift @cycle, @{ $path }[ $i+1 .. $#$path ];
  	}
      }
      $s->{ a_cycle } = \@cycle;
      $t->terminate;
  }
  
  sub configure {
      my ($self, %attr) = @_;
      $self->{ pre  } = $attr{ pre }  if exists $attr{ pre  };
      $self->{ post } = $attr{ post } if exists $attr{ post };
      $self->{ pre_vertex  } = $attr{ pre_vertex }  if exists $attr{ pre_vertex  };
      $self->{ post_vertex } = $attr{ post_vertex } if exists $attr{ post_vertex };
      $self->{ pre_edge  } = $attr{ pre_edge  } if exists $attr{ pre_edge  };
      $self->{ post_edge } = $attr{ post_edge } if exists $attr{ post_edge };
      if (exists $attr{ successor }) { # Graph 0.201 compatibility.
  	$self->{ tree_edge } = $self->{ non_tree_edge } = $attr{ successor };
      }
      if (exists $attr{ unseen_successor }) {
  	if (exists $self->{ tree_edge }) { # Graph 0.201 compatibility.
  	    my $old_tree_edge = $self->{ tree_edge };
  	    $self->{ tree_edge } = sub {
  		$old_tree_edge->( @_ );
  		$attr{ unseen_successor }->( @_ );
  	    };
  	} else {
  	    $self->{ tree_edge } = $attr{ unseen_successor };
  	}
      }
      if ($self->graph->multiedged || $self->graph->countedged) {
  	$self->{ seen_edge } = $attr{ seen_edge } if exists $attr{ seen_edge };
  	if (exists $attr{ seen_successor }) { # Graph 0.201 compatibility.
  	    $self->{ seen_edge } = $attr{ seen_edge };
  	}
      }
      $self->{ non_tree_edge } = $attr{ non_tree_edge } if exists $attr{ non_tree_edge };
      $self->{ pre_edge  } = $attr{ tree_edge } if exists $attr{ tree_edge };
      $self->{ back_edge } = $attr{ back_edge } if exists $attr{ back_edge };
      $self->{ down_edge } = $attr{ down_edge } if exists $attr{ down_edge };
      $self->{ cross_edge } = $attr{ cross_edge } if exists $attr{ cross_edge };
      if (exists $attr{ start }) {
  	$attr{ first_root } = $attr{ start };
  	$attr{ next_root  } = undef;
      }
      if (exists $attr{ get_next_root }) {
  	$attr{ next_root  } = $attr{ get_next_root }; # Graph 0.201 compat.
      }
      $self->{ next_root } =
  	exists $attr{ next_root } ?
  	    $attr{ next_root } :
  		$attr{ next_alphabetic } ?
  		    \&Graph::_next_alphabetic :
  			$attr{ next_numeric } ?
  			    \&Graph::_next_numeric :
  				\&Graph::_next_random;
      $self->{ first_root } =
  	exists $attr{ first_root } ?
  	    $attr{ first_root } :
  		exists $attr{ next_root } ?
  		    $attr{ next_root } :
  			$attr{ next_alphabetic } ?
  			    \&Graph::_next_alphabetic :
  				$attr{ next_numeric } ?
  				    \&Graph::_next_numeric :
  					\&Graph::_next_random;
      $self->{ next_successor } =
  	exists $attr{ next_successor } ?
  	    $attr{ next_successor } :
  		$attr{ next_alphabetic } ?
  		    \&Graph::_next_alphabetic :
  			$attr{ next_numeric } ?
  			    \&Graph::_next_numeric :
  				\&Graph::_next_random;
      if (exists $attr{ has_a_cycle }) {
  	my $has_a_cycle =
  	    ref $attr{ has_a_cycle } eq 'CODE' ?
  		$attr{ has_a_cycle } : \&has_a_cycle;
  	$self->{ back_edge } = $has_a_cycle;
  	if ($self->{ graph }->is_undirected) {
  	    $self->{ down_edge } = $has_a_cycle;
  	}
      }
      if (exists $attr{ find_a_cycle }) {
  	my $find_a_cycle =
  	    ref $attr{ find_a_cycle } eq 'CODE' ?
  		$attr{ find_a_cycle } : \&find_a_cycle;
  	$self->{ back_edge } = $find_a_cycle;
  	if ($self->{ graph }->is_undirected) {
  	    $self->{ down_edge } = $find_a_cycle;
  	}
      }
      $self->{ add } = \&add_order;
      $self->{ see } = $see;
      delete @attr{ qw(
  		     pre post pre_edge post_edge
  		     successor unseen_successor seen_successor
  		     tree_edge non_tree_edge
  		     back_edge down_edge cross_edge seen_edge
  		     start get_next_root
  		     next_root next_alphabetic next_numeric next_random next_successor
  		     first_root
  		     has_a_cycle find_a_cycle
  		    ) };
      if (keys %attr) {
  	require Carp;
  	my @attr = sort keys %attr;
  	Carp::croak(sprintf "Graph::Traversal: unknown attribute%s @{[map { qq['$_'] } @attr]}\n", @attr == 1 ? '' : 's');
      }
  }
  
  sub new {
      my $class = shift;
      my $g = shift;
      unless (ref $g && $g->isa('Graph')) {
  	require Carp;
  	Carp::croak("Graph::Traversal: first argument is not a Graph");
      }
      my $self = { graph => $g, state => { } };
      bless $self, $class;
      $self->reset;
      $self->configure( @_ );
      return $self;
  }
  
  sub terminate {
      my $self = shift;
      $self->{ terminate } = 1;
  }
  
  sub add_order {
      my ($self, @next) = @_;
      push @{ $self->{ order } }, @next;
  }
  
  sub visit {
      my ($self, @next) = @_;
      delete @{ $self->{ unseen } }{ @next };
      print "unseen = @{[sort keys %{$self->{unseen}}]}\n" if DEBUG;
      @{ $self->{ seen } }{ @next } = @next;
      print "seen = @{[sort keys %{$self->{seen}}]}\n" if DEBUG;
      $self->{ add }->( $self, @next );
      print "order = @{$self->{order}}\n" if DEBUG;
      if (exists $self->{ pre }) {
  	my $p = $self->{ pre };
  	for my $v (@next) {
  	    $p->( $v, $self );
  	}
      }
  }
  
  sub visit_preorder {
      my ($self, @next) = @_;
      push @{ $self->{ preorder } }, @next;
      for my $v (@next) {
  	$self->{ preordern }->{ $v } = $self->{ preorderi }++;
      }
      print "preorder = @{$self->{preorder}}\n" if DEBUG;
      $self->visit( @next );
  }
  
  sub visit_postorder {
      my ($self) = @_;
      my @post = reverse $self->{ see }->( $self );
      push @{ $self->{ postorder } }, @post;
      for my $v (@post) {
  	$self->{ postordern }->{ $v } = $self->{ postorderi }++;
      }
      print "postorder = @{$self->{postorder}}\n" if DEBUG;
      if (exists $self->{ post }) {
  	my $p = $self->{ post };
  	for my $v (@post) {
  	    $p->( $v, $self ) ;
  	}
      }
      if (exists $self->{ post_edge }) {
  	my $p = $self->{ post_edge };
  	my $u = $self->current;
  	if (defined $u) {
  	    for my $v (@post) {
  		$p->( $u, $v, $self, $self->{ state });
  	    }
  	}
      }
  }
  
  sub _callbacks {
      my ($self, $current, @all) = @_;
      return unless @all;
      my $nontree  = $self->{ non_tree_edge };
      my $back     = $self->{ back_edge };
      my $down     = $self->{ down_edge };
      my $cross    = $self->{ cross_edge };
      my $seen     = $self->{ seen_edge };
      my $bdc = defined $back || defined $down || defined $cross;
      if (defined $nontree || $bdc || defined $seen) {
  	my $u = $current;
  	my $preu  = $self->{ preordern  }->{ $u };
  	my $postu = $self->{ postordern }->{ $u };
  	for my $v ( @all ) {
  	    my $e = $self->{ tree }->has_edge( $u, $v );
  	    if ( !$e && (defined $nontree || $bdc) ) {
  		if ( exists $self->{ seen }->{ $v }) {
  		    $nontree->( $u, $v, $self, $self->{ state })
  			if $nontree;
  		    if ($bdc) {
  			my $postv = $self->{ postordern }->{ $v };
  			if ($back &&
  			    (!defined $postv || $postv >= $postu)) {
  			    $back ->( $u, $v, $self, $self->{ state });
  			} else {
  			    my $prev = $self->{ preordern }->{ $v };
  			    if ($down && $prev > $preu) {
  				$down ->( $u, $v, $self, $self->{ state });
  			    } elsif ($cross && $prev < $preu) {
  				$cross->( $u, $v, $self, $self->{ state });
  			    }
  			}
  		    }
  		}
  	    }
  	    if ($seen) {
  		my $c = $self->graph->get_edge_count($u, $v);
  		while ($c-- > 1) {
  		    $seen->( $u, $v, $self, $self->{ state } );
  		}
  	    }
  	}
      }
  }
  
  sub next {
      my $self = shift;
      return undef if $self->{ terminate };
      my @next;
      while ($self->seeing) {
  	my $current = $self->current;
  	print "current = $current\n" if DEBUG;
  	@next = $self->{ graph }->successors( $current );
  	print "next.0 - @next\n" if DEBUG;
  	my %next; @next{ @next } = @next;
  	print "next.1 - @next\n" if DEBUG;
  	@next = values %next;
  	my @all = @next;
  	print "all = @all\n" if DEBUG;
  	for my $s (keys %next) {
  	    delete $next{$s} if exists $self->{seen}->{$s};
  	}
  	@next = values %next;
  	print "next.2 - @next\n" if DEBUG;
  	if (@next) {
  	    @next = $self->{ next_successor }->( $self, \%next );
  	    print "next.3 - @next\n" if DEBUG;
  	    for my $v (@next) {
  		$self->{ tree }->add_edge( $current, $v );
  	    }
  	    if (exists $self->{ pre_edge }) {
  		my $p = $self->{ pre_edge };
  		my $u = $self->current;
  		for my $v (@next) {
  		    $p->( $u, $v, $self, $self->{ state });
  		}
  	    }
  	    last;
  	} else {
  	    $self->visit_postorder;
  	}
  	return undef if $self->{ terminate };
  	$self->_callbacks($current, @all);
      }
      print "next.4 - @next\n" if DEBUG;
      unless (@next) {
  	unless ( @{ $self->{ roots } } ) {
  	    my $first = $self->{ first_root };
  	    if (defined $first) {
  		@next =
  		    ref $first eq 'CODE' ? 
  			$self->{ first_root }->( $self, $self->{ unseen } ) :
  			$first;
  		return unless @next;
  	    }
  	}
  	unless (@next) {
  	    return unless defined $self->{ next_root };
  	    return unless @next =
  		$self->{ next_root }->( $self, $self->{ unseen } );
  	}
  	return if exists $self->{ seen }->{ $next[0] }; # Sanity check.
  	print "next.5 - @next\n" if DEBUG;
  	push @{ $self->{ roots } }, $next[0];
      }
      print "next.6 - @next\n" if DEBUG;
      if (@next) {
  	$self->visit_preorder( @next );
      }
      return $next[0];
  }
  
  sub _order {
      my ($self, $order) = @_;
      1 while defined $self->next;
      my $wantarray = wantarray;
      if ($wantarray) {
  	@{ $self->{ $order } };
      } elsif (defined $wantarray) {
  	shift @{ $self->{ $order } };
      }
  }
  
  sub preorder {
      my $self = shift;
      $self->_order( 'preorder' );
  }
  
  sub postorder {
      my $self = shift;
      $self->_order( 'postorder' );
  }
  
  sub unseen {
      my $self = shift;
      values %{ $self->{ unseen } };
  }
  
  sub seen {
      my $self = shift;
      values %{ $self->{ seen } };
  }
  
  sub seeing {
      my $self = shift;
      @{ $self->{ order } };
  }
  
  sub roots {
      my $self = shift;
      @{ $self->{ roots } };
  }
  
  sub is_root {
      my ($self, $v) = @_;
      for my $u (@{ $self->{ roots } }) {
  	return 1 if $u eq $v;
      }
      return 0;
  }
  
  sub tree {
      my $self = shift;
      $self->{ tree };
  }
  
  sub graph {
      my $self = shift;
      $self->{ graph };
  }
  
  sub vertex_by_postorder {
      my ($self, $i) = @_;
      exists $self->{ postorder } && $self->{ postorder }->[ $i ];
  }
  
  sub postorder_by_vertex {
      my ($self, $v) = @_;
      exists $self->{ postordern } && $self->{ postordern }->{ $v };
  }
  
  sub postorder_vertices {
      my ($self, $v) = @_;
      exists $self->{ postordern } ? %{ $self->{ postordern } } : ();
  }
  
  sub vertex_by_preorder {
      my ($self, $i) = @_;
      exists $self->{ preorder } && $self->{ preorder }->[ $i ];
  }
  
  sub preorder_by_vertex {
      my ($self, $v) = @_;
      exists $self->{ preordern } && $self->{ preordern }->{ $v };
  }
  
  sub preorder_vertices {
      my ($self, $v) = @_;
      exists $self->{ preordern } ? %{ $self->{ preordern } } : ();
  }
  
  sub has_state {
      my ($self, $var) = @_;
      exists $self->{ state } && exists $self->{ state }->{ $var };
  }
  
  sub get_state {
      my ($self, $var) = @_;
      exists $self->{ state } ? $self->{ state }->{ $var } : undef;
  }
  
  sub set_state {
      my ($self, $var, $val) = @_;
      $self->{ state }->{ $var } = $val;
      return 1;
  }
  
  sub delete_state {
      my ($self, $var) = @_;
      delete $self->{ state }->{ $var };
      delete $self->{ state } unless keys %{ $self->{ state } };
      return 1;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Traversal - traverse graphs
  
  =head1 SYNOPSIS
  
  Don't use Graph::Traversal directly, use Graph::Traversal::DFS
  or Graph::Traversal::BFS instead.
  
      use Graph;
      my $g = Graph->new;
      $g->add_edge(...);
      use Graph::Traversal::...;
      my $t = Graph::Traversal::...->new($g, %opt);
      $t->...
  
  =head1 DESCRIPTION
  
  You can control how the graph is traversed by the various callback
  parameters in the C<%opt>.  In the parameters descriptions below the
  $u and $v are vertices, and the $self is the traversal object itself.
  
  =head2 Callback parameters
  
  The following callback parameters are available:
  
  =over 4
  
  =item tree_edge
  
  Called when traversing an edge that belongs to the traversal tree.
  Called with arguments ($u, $v, $self).
  
  =item non_tree_edge
  
  Called when an edge is met which either leads back to the traversal tree
  (either a C<back_edge>, a C<down_edge>, or a C<cross_edge>).
  Called with arguments ($u, $v, $self).
  
  =item pre_edge
  
  Called for edges in preorder.
  Called with arguments ($u, $v, $self).
  
  =item post_edge
  
  Called for edges in postorder.
  Called with arguments ($u, $v, $self).
  
  =item back_edge
  
  Called for back edges.
  Called with arguments ($u, $v, $self).
  
  =item down_edge
  
  Called for down edges.
  Called with arguments ($u, $v, $self).
  
  =item cross_edge
  
  Called for cross edges.
  Called with arguments ($u, $v, $self).
  
  =item pre
  
  =item pre_vertex
  
  Called for vertices in preorder.
  Called with arguments ($v, $self).
  
  =item post
  
  =item post_vertex
  
  Called for vertices in postorder.
  Called with arguments ($v, $self).
  
  =item first_root
  
  Called when choosing the first root (start) vertex for traversal.
  Called with arguments ($self, $unseen) where $unseen is a hash
  reference with the unseen vertices as keys.
  
  =item next_root
  
  Called when choosing the next root (after the first one) vertex for
  traversal (useful when the graph is not connected).  Called with
  arguments ($self, $unseen) where $unseen is a hash reference with
  the unseen vertices as keys.  If you want only the first reachable
  subgraph to be processed, set the next_root to C<undef>.
  
  =item start
  
  Identical to defining C<first_root> and undefining C<next_root>.
  
  =item next_alphabetic
  
  Set this to true if you want the vertices to be processed in
  alphabetic order (and leave first_root/next_root undefined).
  
  =item next_numeric
  
  Set this to true if you want the vertices to be processed in
  numeric order (and leave first_root/next_root undefined).
  
  =item next_successor
  
  Called when choosing the next vertex to visit.  Called with arguments
  ($self, $next) where $next is a hash reference with the possible
  next vertices as keys.  Use this to provide a custom ordering for
  choosing vertices, as opposed to C<next_numeric> or C<next_alphabetic>.
  
  =back
  
  The parameters C<first_root> and C<next_successor> have a 'hierarchy'
  of how they are determined: if they have been explicitly defined, use
  that value.  If not, use the value of C<next_alphabetic>, if that has
  been defined.  If not, use the value of C<next_numeric>, if that has
  been defined.  If not, the next vertex to be visited is chose randomly.
  
  =head2 Methods
  
  The following methods are available:
  
  =over 4
  
  =item unseen
  
  Return the unseen vertices in random order.
  
  =item seen
  
  Return the seen vertices in random order.
  
  =item seeing
  
  Return the active fringe vertices in random order.
  
  =item preorder
  
  Return the vertices in preorder traversal order.
  
  =item postorder
  
  Return the vertices in postorder traversal order.
  
  =item vertex_by_preorder
  
      $v = $t->vertex_by_preorder($i)
  
  Return the ith (0..$V-1) vertex by preorder.
  
  =item preorder_by_vertex
  
      $i = $t->preorder_by_vertex($v)
  
  Return the preorder index (0..$V-1) by vertex.
  
  =item vertex_by_postorder
  
      $v = $t->vertex_by_postorder($i)
  
  Return the ith (0..$V-1) vertex by postorder.
  
  =item postorder_by_vertex
  
      $i = $t->postorder_by_vertex($v)
  
  Return the postorder index (0..$V-1) by vertex.
  
  =item preorder_vertices
  
  Return a hash with the vertices as the keys and their preorder indices
  as the values.
  
  =item postorder_vertices
  
  Return a hash with the vertices as the keys and their postorder
  indices as the values.
  
  =item tree
  
  Return the traversal tree as a graph.
  
  =item has_state
  
      $t->has_state('s')
  
  Test whether the traversal has state 's' attached to it.
  
  =item get_state
  
      $t->get_state('s')
  
  Get the state 's' attached to the traversal (C<undef> if none).
  
  =item set_state
  
      $t->set_state('s', $s)
  
  Set the state 's' attached to the traversal.
  
  =item delete_state
  
      $t->delete_state('s')
  
  Delete the state 's' from the traversal.
  
  =back
  
  =head2 Backward compatibility
  
  The following parameters are for backward compatibility to Graph 0.2xx:
  
  =over 4
  
  =item get_next_root
  
  Like C<next_root>.
  
  =item successor
  
  Identical to having C<tree_edge> both C<non_tree_edge> defined
  to be the same.
  
  =item unseen_successor
  
  Like C<tree_edge>.
  
  =item seen_successor
  
  Like C<seed_edge>.
  
  =back
  
  =head2 Special callbacks
  
  If in a callback you call the special C<terminate> method,
  the traversal is terminated, no more vertices are traversed.
  
  =head1 SEE ALSO
  
  L<Graph::Traversal::DFS>, L<Graph::Traversal::BFS>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_TRAVERSAL

$fatpacked{"Graph/Traversal/BFS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRAVERSAL_BFS';
  package Graph::Traversal::BFS;
  
  use strict;
  
  use Graph::Traversal;
  use base 'Graph::Traversal';
  
  sub current {
      my $self = shift;
      $self->{ order }->[ 0 ];
  }
  
  sub see {
      my $self = shift;
      shift @{ $self->{ order } };
  }
  
  *bfs = \&Graph::Traversal::postorder;
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Traversal::BFS - breadth-first traversal of graphs
  
  =head1 SYNOPSIS
  
      use Graph;
      my $g = Graph->new;
      $g->add_edge(...);
      use Graph::Traversal::BFS;
      my $b = Graph::Traversal::BFS->new($g, %opt);
      $b->bfs; # Do the traversal.
  
  =head1 DESCRIPTION
  
  With this class one can traverse a Graph in breadth-first order.
  
  The callback parameters %opt are explained in L<Graph::Traversal>.
  
  =head2 Methods
  
  The following methods are available:
  
  =over 4
  
  =item bfs
  
  Traverse the graph in breadth-first order.  Returns all vertices
  traversed in post-order.
  
  =back
  
  =head1 SEE ALSO
  
  L<Graph::Traversal>, L<Graph::Traversal::DFS>, L<Graph>.
  
  =cut
GRAPH_TRAVERSAL_BFS

$fatpacked{"Graph/Traversal/DFS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRAVERSAL_DFS';
  package Graph::Traversal::DFS;
  
  use strict;
  
  use Graph::Traversal;
  use base 'Graph::Traversal';
  
  sub current {
      my $self = shift;
      $self->{ order }->[ -1 ];
  }
  
  sub see {
      my $self = shift;
      pop @{ $self->{ order } };
  }
  
  *dfs = \&Graph::Traversal::postorder;
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Traversal::DFS - depth-first traversal of graphs
  
  =head1 SYNOPSIS
  
      use Graph;
      my $g = Graph->new;
      $g->add_edge(...);
      use Graph::Traversal::DFS;
      my $d = Graph::Traversal::DFS->new($g, %opt);
      $d->dfs; # Do the traversal.
  
  =head1 DESCRIPTION
  
  With this class one can traverse a Graph in depth-first order.
  
  The callback parameters %opt are explained in L<Graph::Traversal>.
  
  =head2 Methods
  
  The following methods are available:
  
  =over 4
  
  =item dfs
  
  Traverse the graph in depth-first order.  Returns all vertices
  traversed in post-order.
  
  =back
  
  =head1 SEE ALSO
  
  L<Graph::Traversal>, L<Graph::Traversal::BFS>, L<Graph>.
  
  =cut
GRAPH_TRAVERSAL_DFS

$fatpacked{"Graph/Undirected.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_UNDIRECTED';
  package Graph::Undirected;
  
  use Graph;
  use base 'Graph';
  use strict;
  
  =pod
  
  =head1 NAME
  
  Graph::Undirected - undirected graphs
  
  =head1 SYNOPSIS
  
      use Graph::Undirected;
      my $g = Graph::Undirected->new;
  
      # Or alternatively:
  
      use Graph;
      my $g = Graph->new(undirected => 1);
      my $g = Graph->new(directed => 0);
  
  =head1 DESCRIPTION
  
  Graph::Undirected allows you to create undirected graphs.
  
  For the available methods, see L<Graph>.
  
  =head1 SEE ALSO
  
  L<Graph>, L<Graph::Directed>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
  
  sub new {
      my $class = shift;
      bless Graph->new(undirected => 1, @_), ref $class || $class;
  }
  
  1;
GRAPH_UNDIRECTED

$fatpacked{"Graph/UnionFind.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_UNIONFIND';
  package Graph::UnionFind;
  
  use strict;
  
  sub _PARENT  () { 0 }
  sub _RANK    () { 1 }
  
  sub new {
      my $class = shift;
      bless { }, $class;
  }
  
  sub add {
      my ($self, $elem) = @_;
      $self->{ $elem } = [ $elem, 0 ] unless defined $self->{$elem};
  }
  
  sub has {
      my ($self, $elem) = @_;
      exists $self->{ $elem };
  }
  
  sub _parent {
      return undef unless defined $_[1];
      if (@_ == 2) {
  	exists $_[0]->{ $_[ 1 ] } ? $_[0]->{ $_[1] }->[ _PARENT ] : undef;
      } elsif (@_ == 3) {
  	$_[0]->{ $_[1] }->[ _PARENT ] = $_[2];
      } else {
  	require Carp;
  	Carp::croak(__PACKAGE__ . "::_parent: bad arity");
      }
  }
  
  sub _rank {
      return unless defined $_[1];
      if (@_ == 2) {
  	exists $_[0]->{ $_[1] } ? $_[0]->{ $_[1] }->[ _RANK ] : undef;
      } elsif (@_ == 3) {
  	$_[0]->{ $_[1] }->[ _RANK ] = $_[2];
      } else {
  	require Carp;
  	Carp::croak(__PACKAGE__ . "::_rank: bad arity");
      }
  }
  
  sub find {
      my ($self, $x) = @_;
      my $px = $self->_parent( $x );
      return unless defined $px;
      $self->_parent( $x, $self->find( $px ) ) if $px ne $x;
      $self->_parent( $x );
  }
  
  sub union {
      my ($self, $x, $y) = @_;
      $self->add($x) unless $self->has($x);
      $self->add($y) unless $self->has($y);
      my $px = $self->find( $x );
      my $py = $self->find( $y );
      return if $px eq $py;
      my $rx = $self->_rank( $px );
      my $ry = $self->_rank( $py );
      # print "union($x, $y): px = $px, py = $py, rx = $rx, ry = $ry\n";
      if ( $rx > $ry ) {
  	$self->_parent( $py, $px );
      } else {
  	$self->_parent( $px, $py );
  	$self->_rank( $py, $ry + 1 ) if $rx == $ry;
      }
  }
  
  sub same {
      my ($uf, $u, $v) = @_;
      my $fu = $uf->find($u);
      return undef unless defined $fu;
      my $fv = $uf->find($v);
      return undef unless defined $fv;
      $fu eq $fv;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::UnionFind - union-find data structures
  
  =head1 SYNOPSIS
  
      use Graph::UnionFind;
      my $uf = Graph::UnionFind->new;
  
      # Add the vertices to the data structure.
      $uf->add($u);
      $uf->add($v);
  
      # Join the partitions of the vertices.
      $uf->union( $u, $v );
  
      # Find the partitions the vertices belong to
      # in the union-find data structure.  If they
      # are equal, they are in the same partition.
      # If the vertex has not been seen,
      # undef is returned.
      my $pu = $uf->find( $u );
      my $pv = $uf->find( $v );
      $uf->same($u, $v) # Equal to $pu eq $pv. 
  
      # Has the union-find seen this vertex?
      $uf->has( $v )
  
  =head1 DESCRIPTION
  
  I<Union-find> is a special data structure that can be used to track the
  partitioning of a set into subsets (a problem known also as I<disjoint sets>).
  
  Graph::UnionFind() is used for Graph::connected_components(),
  Graph::connected_component(), and Graph::same_connected_components()
  if you specify a true C<union_find> parameter when you create an undirected
  graph.
  
  Note that union-find is one way: you cannot (easily) 'ununion'
  vertices once you have 'unioned' them.  This means that if you
  delete edges from a C<union_find> graph, you will get wrong results
  from the Graph::connected_components(), Graph::connected_component(),
  and Graph::same_connected_components().
  
  =head2 API
  
  =over 4
  
  =item add
  
      $uf->add($v)
  
  Add the vertex v to the union-find.
  
  =item union
  
      $uf->union($u, $v)
  
  Add the edge u-v to the union-find.  Also implicitly adds the vertices.
  
  =item has
  
      $uf->has($v)
  
  Return true if the vertex v has been added to the union-find, false otherwise.
  
  =item find
  
      $uf->find($v)
  
  Return the union-find partition the vertex v belongs to,
  or C<undef> if it has not been added.
  
  =item new
  
      $uf = Graph::UnionFind->new()
  
  The constructor.
  
  =item same
  
      $uf->same($u, $v)
  
  Return true of the vertices belong to the same union-find partition
  the vertex v belongs to, false otherwise.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
  
GRAPH_UNIONFIND

$fatpacked{"Heap071/Elem.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HEAP071_ELEM';
  package Heap071::Elem;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  require Exporter;
  require AutoLoader;
  
  @ISA = qw(Exporter AutoLoader);
  
  # No names exported.
  # No names available for export.
  
  @EXPORT = ( );
  
  # Preloaded methods go here.
  
  # new will usually be superceded by child,
  # but provide an empty hash as default and
  # accept any provided filling for it.
  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
  
      return bless { heap=>undef, @_ }, $class;
  }
  
  sub heap {
      my $self = shift;
      @_ ? ($self->{heap} = shift) : $self->{heap};
  }
  
  sub cmp {
      die "This cmp method must be superceded by one that knows how to compare elements."
  }
  
  # Autoload methods go after =cut, and are processed by the autosplit program.
  
  1;
  __END__
  # Below is the stub of documentation for your module. You better edit it!
  
  =head1 NAME
  
  Heap::Elem - Perl extension for elements to be put in Heaps
  
  =head1 SYNOPSIS
  
    use Heap::Elem::SomeInheritor;
  
    use Heap::SomeHeapClass;
  
    $elem = Heap::Elem::SomeInheritor->new( $value );
    $heap = Heap::SomeHeapClass->new;
  
    $heap->add($elem);
  
  =head1 DESCRIPTION
  
  This is an inheritable class for Heap Elements.  It provides
  the interface documentation and some inheritable methods.
  Only a child classes can be used - this class is not complete.
  
  =head1 METHODS
  
  =over 4
  
  =item $elem = Heap::Elem::SomeInheritor->new( [args] );
  
  Creates a new Elem.
  
  =item $elem->heap( $val ); $elem->heap;
  
  Provides a method for use by the Heap processing routines.
  If a value argument is provided, it will be saved.  The
  new saved value is always returned.  If no value argument
  is provided, the old saved value is returned.
  
  The Heap processing routines use this method to map an element
  into its internal structure.  This is needed to support the
  Heap methods that affect elements that are not are the top
  of the heap - I<decrease_key> and I<delete>.
  
  The Heap processing routines will ensure that this value is
  undef when this elem is removed from a heap, and is not undef
  after it is inserted into a heap.  This means that you can
  check whether an element is currently contained within a heap
  or not.  (It cannot be used to determine which heap an element
  is contained in, if you have multiple heaps.  Keeping that
  information accurate would make the operation of merging two
  heaps into a single one take longer - it would have to traverse
  all of the elements in the merged heap to update them; for
  Binomial and Fibonacci heaps that would turn an O(1) operation
  into an O(n) one.)
  
  =item $elem1->cmp($elem2)
  
  A routine to compare two elements.  It must return a negative
  value if this element should go higher on the heap than I<$elem2>,
  0 if they are equal, or a positive value if this element should
  go lower on the heap than I<$elem2>.  Just as with sort, the
  Perl operators <=> and cmp cause the smaller value to be returned
  first; similarly you can negate the meaning to reverse the order
  - causing the heap to always return the largest element instead
  of the smallest.
  
  =back
  
  =head1 INHERITING
  
  This class can be inherited to provide an oject with the
  ability to be heaped.  If the object is implemented as
  a hash, and if it can deal with a key of I<heap>, leaving
  it unchanged for use by the heap routines, then the following
  implementation will work.
  
    package myObject;
  
    require Exporter;
  
    @ISA = qw(Heap::Elem);
  
    sub new {
        my $self = shift;
        my $class = ref($self) || $self;
  
        my $self = SUPER::new($class);
  
        # set $self->{key} = $value;
    }
  
    sub cmp {
        my $self = shift;
        my $other = shift;
  
        $self->{key} cmp $other->{key};
    }
  
    # other methods for the rest of myObject's functionality
  
  =head1 AUTHOR
  
  John Macdonald, jmm@perlwolf.com
  
  =head1 COPYRIGHT
  
  Copyright 1998-2003, O'Reilly & Associates.
  
  This code is distributed under the same copyright terms as perl itself.
  
  =head1 SEE ALSO
  
  Heap(3), Heap::Elem::Num(3), Heap::Elem::NumRev(3),
  Heap::Elem::Str(3), Heap::Elem::StrRev(3).
  
  =cut
HEAP071_ELEM

$fatpacked{"Heap071/Fibonacci.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HEAP071_FIBONACCI';
  package Heap071::Fibonacci;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  require Exporter;
  require AutoLoader;
  
  @ISA = qw(Exporter AutoLoader);
  
  # No names exported.
  # No names available for export.
  @EXPORT = ( );
  
  # Preloaded methods go here.
  
  # common names
  #	h	- heap head
  #	el	- linkable element, contains user-provided value
  #	v	- user-provided value
  
  ################################################# debugging control
  
  my $debug = 0;
  my $validate = 0;
  
  # enable/disable debugging output
  sub debug {
      @_ ? ($debug = shift) : $debug;
  }
  
  # enable/disable validation checks on values
  sub validate {
      @_ ? ($validate = shift) : $validate;
  }
  
  my $width = 3;
  my $bar = ' | ';
  my $corner = ' +-';
  my $vfmt = "%3d";
  
  sub set_width {
      $width = shift;
      $width = 2 if $width < 2;
  
      $vfmt = "%${width}d";
      $bar = $corner = ' ' x $width;
      substr($bar,-2,1) = '|';
      substr($corner,-2,2) = '+-';
  }
  
  sub hdump;
  
  sub hdump {
      my $el = shift;
      my $l1 = shift;
      my $b = shift;
  
      my $ch;
      my $ch1;
  
      unless( $el ) {
  	print $l1, "\n";
  	return;
      }
  
      hdump $ch1 = $el->{child},
  	$l1 . sprintf( $vfmt, $el->{val}->val),
  	$b . $bar;
  
      if( $ch1 ) {
  	for( $ch = $ch1->{right}; $ch != $ch1; $ch = $ch->{right} ) {
  	    hdump $ch, $b . $corner, $b . $bar;
  	}
      }
  }
  
  sub heapdump {
      my $h;
  
      while( $h = shift ) {
  	my $top = $$h or last;
  	my $el = $top;
  
  	do {
  	    hdump $el, sprintf( "%02d: ", $el->{degree}), '    ';
  	    $el = $el->{right};
  	} until $el == $top;
  	print "\n";
      }
  }
  
  sub bhcheck;
  
  sub bhcheck {
      my $el = shift;
      my $p = shift;
  
      my $cur = $el;
      my $prev;
      my $ch;
      do {
  	$prev = $cur;
  	$cur = $cur->{right};
  	die "bad back link" unless $cur->{left} == $prev;
  	die "bad parent link"
  	    unless (defined $p && defined $cur->{p} && $cur->{p} == $p)
  		|| (!defined $p && !defined $cur->{p});
  	die "bad degree( $cur->{degree} > $p->{degree} )"
  	    if $p && $p->{degree} <= $cur->{degree};
  	die "not heap ordered"
  	    if $p && $p->{val}->cmp($cur->{val}) > 0;
  	$ch = $cur->{child} and bhcheck $ch, $cur;
      } until $cur == $el;
  }
  
  
  sub heapcheck {
      my $h;
      my $el;
      while( $h = shift ) {
  	heapdump $h if $validate >= 2;
  	$el = $$h and bhcheck $el, undef;
      }
  }
  
  
  ################################################# forward declarations
  
  sub ascending_cut;
  sub elem;
  sub elem_DESTROY;
  sub link_to_left_of;
  
  ################################################# heap methods
  
  # Cormen et al. use two values for the heap, a pointer to an element in the
  # list at the top, and a count of the number of elements.  The count is only
  # used to determine the size of array required to hold log(count) pointers,
  # but perl can set array sizes as needed and doesn't need to know their size
  # when they are created, so we're not maintaining that field.
  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
      my $h = undef;
      bless \$h, $class;
  }
  
  sub DESTROY {
      my $h = shift;
  
      elem_DESTROY $$h;
  }
  
  sub add {
      my $h = shift;
      my $v = shift;
      $validate && do {
  	die "Method 'heap' required for element on heap"
  	    unless $v->can('heap');
  	die "Method 'cmp' required for element on heap"
  	    unless $v->can('cmp');
      };
      my $el = elem $v;
      my $top;
      if( !($top = $$h) ) {
  	$$h = $el;
      } else {
  	link_to_left_of $top->{left}, $el ;
  	link_to_left_of $el,$top;
  	$$h = $el if $v->cmp($top->{val}) < 0;
      }
  }
  
  sub top {
      my $h = shift;
      $$h && $$h->{val};
  }
  
  *minimum = \&top;
  
  sub extract_top {
      my $h = shift;
      my $el = $$h or return undef;
      my $ltop = $el->{left};
      my $cur;
      my $next;
  
      # $el is the heap with the lowest value on it
      # move all of $el's children (if any) to the top list (between
      # $ltop and $el)
      if( $cur = $el->{child} ) {
  	# remember the beginning of the list of children
  	my $first = $cur;
  	do {
  	    # the children are moving to the top, clear the p
  	    # pointer for all of them
  	    $cur->{p} = undef;
  	} until ($cur = $cur->{right}) == $first;
  
  	# remember the end of the list
  	$cur = $cur->{left};
  	link_to_left_of $ltop, $first;
  	link_to_left_of $cur, $el;
      }
  
      if( $el->{right} == $el ) {
  	# $el had no siblings or children, the top only contains $el
  	# and $el is being removed
  	$$h = undef;
      } else {
  	link_to_left_of $el->{left}, $$h = $el->{right};
  	# now all those loose ends have to be merged together as we
  	# search for the
  	# new smallest element
  	$h->consolidate;
      }
  
      # extract the actual value and return that, $el is no longer used
      # but break all of its links so that it won't be pointed to...
      my $top = $el->{val};
      $top->heap(undef);
      $el->{left} = $el->{right} = $el->{p} = $el->{child} = $el->{val} =
  	undef;
      $top;
  }
  
  *extract_minimum = \&extract_top;
  
  sub absorb {
      my $h = shift;
      my $h2 = shift;
  
      my $el = $$h;
      unless( $el ) {
  	$$h = $$h2;
  	$$h2 = undef;
  	return $h;
      }
  
      my $el2 = $$h2 or return $h;
  
      # add $el2 and its siblings to the head list for $h
      # at start, $ell -> $el -> ... -> $ell is on $h (where $ell is
      #				$el->{left})
      #           $el2l -> $el2 -> ... -> $el2l are on $h2
      # at end, $ell -> $el2l -> ... -> $el2 -> $el -> ... -> $ell are
      #				all on $h
      my $el2l = $el2->{left};
      link_to_left_of $el->{left}, $el2;
      link_to_left_of $el2l, $el;
  
      # change the top link if needed
      $$h = $el2 if $el->{val}->cmp( $el2->{val} ) > 0;
  
      # clean out $h2
      $$h2 = undef;
  
      # return the heap
      $h;
  }
  
  # a key has been decreased, it may have to percolate up in its heap
  sub decrease_key {
      my $h = shift;
      my $top = $$h;
      my $v = shift;
      my $el = $v->heap or return undef;
      my $p;
  
      # first, link $h to $el if it is now the smallest (we will
      # soon link $el to $top to properly put it up to the top list,
      # if it isn't already there)
      $$h = $el if $top->{val}->cmp( $v ) > 0;
  
      if( $p = $el->{p} and $v->cmp($p->{val}) < 0 ) {
  	# remove $el from its parent's list - it is now smaller
  
  	ascending_cut $top, $p, $el;
      }
  
      $v;
  }
  
  
  # to delete an item, we bubble it to the top of its heap (as if its key
  # had been decreased to -infinity), and then remove it (as in extract_top)
  sub delete {
      my $h = shift;
      my $v = shift;
      my $el = $v->heap or return undef;
  
      # if there is a parent, cut $el to the top (as if it had just had its
      # key decreased to a smaller value than $p's value
      my $p;
      $p = $el->{p} and ascending_cut $$h, $p, $el;
  
      # $el is in the top list now, make it look like the smallest and
      # remove it
      $$h = $el;
      $h->extract_top;
  }
  
  
  ################################################# internal utility functions
  
  sub elem {
      my $v = shift;
      my $el = undef;
      $el = {
  	p	=>	undef,
  	degree	=>	0,
  	mark	=>	0,
  	child	=>	undef,
  	val	=>	$v,
  	left	=>	undef,
  	right	=>	undef,
      };
      $el->{left} = $el->{right} = $el;
      $v->heap($el);
      $el;
  }
  
  sub elem_DESTROY {
      my $el = shift;
      my $ch;
      my $next;
      $el->{left}->{right} = undef;
  
      while( $el ) {
  	$ch = $el->{child} and elem_DESTROY $ch;
  	$next = $el->{right};
  
  	defined $el->{val} and $el->{val}->heap(undef);
  	$el->{child} = $el->{right} = $el->{left} = $el->{p} = $el->{val}
  	    = undef;
  	$el = $next;
      }
  }
  
  sub link_to_left_of {
      my $l = shift;
      my $r = shift;
  
      $l->{right} = $r;
      $r->{left} = $l;
  }
  
  sub link_as_parent_of {
      my $p = shift;
      my $c = shift;
  
      my $pc;
  
      if( $pc = $p->{child} ) {
  	link_to_left_of $pc->{left}, $c;
  	link_to_left_of $c, $pc;
      } else {
  	link_to_left_of $c, $c;
      }
      $p->{child} = $c;
      $c->{p} = $p;
      $p->{degree}++;
      $c->{mark} = 0;
      $p;
  }
  
  sub consolidate {
      my $h = shift;
  
      my $cur;
      my $this;
      my $next = $$h;
      my $last = $next->{left};
      my @a;
      do {
  	# examine next item on top list
  	$this = $cur = $next;
  	$next = $cur->{right};
  	my $d = $cur->{degree};
  	my $alt;
  	while( $alt = $a[$d] ) {
  	    # we already saw another item of the same degree,
  	    # put the larger valued one under the smaller valued
  	    # one - switch $cur and $alt if necessary so that $cur
  	    # is the smaller
  	    ($cur,$alt) = ($alt,$cur)
  		if $cur->{val}->cmp( $alt->{val} ) > 0;
  	    # remove $alt from the top list
  	    link_to_left_of $alt->{left}, $alt->{right};
  	    # and put it under $cur
  	    link_as_parent_of $cur, $alt;
  	    # make sure that $h still points to a node at the top
  	    $$h = $cur;
  	    # we've removed the old $d degree entry
  	    $a[$d] = undef;
  	    # and we now have a $d+1 degree entry to try to insert
  	    # into @a
  	    ++$d;
  	}
  	# found a previously unused degree
  	$a[$d] = $cur;
      } until $this == $last;
      $cur = $$h;
      for $cur (grep defined, @a) {
  	$$h = $cur if $$h->{val}->cmp( $cur->{val} ) > 0;
      }
  }
  
  sub ascending_cut {
      my $top = shift;
      my $p = shift;
      my $el = shift;
  
      while( 1 ) {
  	if( --$p->{degree} ) {
  	    # there are still other children below $p
  	    my $l = $el->{left};
  	    $p->{child} = $l;
  	    link_to_left_of $l, $el->{right};
  	} else {
  	    # $el was the only child of $p
  	    $p->{child} = undef;
  	}
  	link_to_left_of $top->{left}, $el;
  	link_to_left_of $el, $top;
  	$el->{p} = undef;
  	$el->{mark} = 0;
  
  	# propagate up the list
  	$el = $p;
  
  	# quit at the top
  	last unless $p = $el->{p};
  
  	# quit if we can mark $el
  	$el->{mark} = 1, last unless $el->{mark};
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Heap::Fibonacci - a Perl extension for keeping data partially sorted
  
  =head1 SYNOPSIS
  
    use Heap::Fibonacci;
  
    $heap = Heap::Fibonacci->new;
    # see Heap(3) for usage
  
  =head1 DESCRIPTION
  
  Keeps elements in heap order using a linked list of Fibonacci trees.
  The I<heap> method of an element is used to store a reference to
  the node in the list that refers to the element.
  
  See L<Heap> for details on using this module.
  
  =head1 AUTHOR
  
  John Macdonald, jmm@perlwolf.com
  
  =head1 COPYRIGHT
  
  Copyright 1998-2003, O'Reilly & Associates.
  
  This code is distributed under the same copyright terms as perl itself.
  
  =head1 SEE ALSO
  
  Heap(3), Heap::Elem(3).
  
  =cut
HEAP071_FIBONACCI

$fatpacked{"Igor/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_CLI';
  package Igor::CLI;
  
  use warnings;
  use strict;
  
  use Const::Fast;
  use Data::Dumper;
  use Getopt::Long::Subcommand;
  use Igor::Config;
  use Igor::Repository;
  use Igor::Package;
  use Igor::Util qw(colored);
  use Try::Tiny;
  use Pod::Usage;
  
  use sort 'stable';
  
  # Configure Logging
  use Log::ger::Output Composite => (
  	outputs => {
  		Screen => [
  			{
  				level => ['trace', 'info'],
  				conf  => { stderr => 0
  				         , use_color => 0},
  			},
  			{
  				level => 'warn',
  				conf  => { stderr => 1
  				         , use_color => -t STDERR},
  			},
  		],
  	}
  );
  use Log::ger;
  use Log::ger::Util;
  
  # Emit usage
  sub usage {
  	# -verbosity == 99: Only print sections in -section
  	pod2usage( -verbose  => 99
  	         , -exitval  => 'NOEXIT'
  	         , -sections => 'SYNOPSIS'
  	         );
  }
  
  sub usage_full {
  	# -verbose > 2: Print all sections
  	pod2usage( -verbose  => 42
  	         , -exitval  => 'NOEXIT'
  	         );
  
  }
  
  # Find out which task to run based on the --task variable or the system hostname
  sub find_task {
  	my ($opts, $cfgs) = @_;
  
  	my $task = $opts->{task};
  	return $task if defined $task;
  
  	my $identifier = Igor::Util::guess_identifier;
  	my @tasks = grep {
  		my $re = $cfgs->{$_}->{pattern} // $_;
  		$identifier =~ /$re/
  	} sort keys %$cfgs;
  
  	die "Automatic task selection using identifier '$identifier' not unique: " . @tasks if @tasks > 1;
  	die "Task selection using identifier '$identifier' machted no configurations" unless @tasks;
  
  	return $tasks[0];
  }
  
  sub parse_commandline {
  	local @ARGV = @_;
  
  	# Setup the defaults
  	my %opts = (
  		configfile => './config.toml',
  		verbositylevel  => 0,
  		help => 0,
  
  	);
  
  	my $res = GetOptions(
  		summary => 'Frankensteins configuration management',
  
  		# common options recognized by all subcommands
  		options => {
  			'help|h|?+' => {
  				summary => 'Display help message',
  				handler => \$opts{help}
  			},
  			'config|c=s' => {
  				summary => 'Specified config',
  				handler => \$opts{configfile}
  			},
  			'verbose|v+' => {
  				summary => 'Verbosity level',
  				handler => \$opts{verbositylevel}
  			},
  			'task=s' => {
  				summary => 'Task to execute',
  				handler => \$opts{task}
  			},
  		},
  
  		subcommands => {
  			apply => {
  				summary => 'Apply a given configuration',
  				options => {
  					'dry-run' => {
  						summary => 'Only simulate the operations',
  						handler => \$opts{dryrun}
  					},
  				}
  			},
  			gc => {
  				summary => 'List obsolete files'
  			},
  			diff => {
  				summary => 'Show the difference between applied and configured states'
  			},
  		},
  	);
  
  	# Display help on illegal input
  	unless ($res->{success} && ($opts{help} || @{$res->{subcommand}})) {
  		print STDERR "Parsing of commandline options failed.\n";
  		usage();
  		exit(-1);
  	}
  
  	# Emit a help message
  	if ($opts{help}) {
  		# For a specific subcommand
  		if (@{$res->{subcommand}}) {
  			pod2usage( -verbose  => 99
  					 , -sections => "SUBCOMMANDS/@{$res->{subcommand}}"
  					 , -exitval  => 0
  					 );
  		} else {
  			# General help
  			if ($opts{help} >= 2) {
  				usage_full();
  			} else {
  				usage();
  			}
  			exit(0);
  		}
  	}
  
  	# Assert: only one subcommand given
  	if (@{$res->{subcommand}} != 1) {
  		die "Igor expectes just one subcommand, but received @{[scalar(@{$res->{subcommand}})]}:"
  		  . " @{$res->{subcommand}}";
  	}
  
  	$opts{subcommand} = $res->{subcommand};
  
  	return \%opts;
  }
  
  # Parse and dispatch the commands
  sub main {
  	my $opts = parse_commandline(@_);
  
  	# Set log level based on verbosity
  	# 4 = loglevel "info"
  	my $loglevel = 4 + $opts->{verbositylevel};
  	# Log::ger is a bit weird, I found no documentation on it, but numeric
  	# levels seem to need a scaling factor of 10
  	Log::ger::Util::set_level($loglevel * 10);
  	# I want log_warn to be red (also undocumented behaviour)
  	$Log::ger::Output::Screen::colors{20} = "\e[0;31m";
  
  	# Parse the configfile
  	my $config = Igor::Config::from_file($opts->{configfile});
  
  	# Determine the task to run
  	my $task = find_task($opts, $config->configurations);
  	log_info colored(['bold'], "Running task @{[colored(['bold blue'], $task)]}");
  
  	# Layer the dependencies of the task and merge their configurations
  	my $effective_configuration = $config->determine_effective_configuration($task);
  	log_trace "Effective configuration:\n" . Dumper($effective_configuration);
  
  	# Determine which packages need to be installed
  	# FIXME: Run factors before expanding perl-based packages.
  	my @packages = $config->expand_packages( $effective_configuration->{repositories}
  	                                       , $effective_configuration->{packages}
  	                                       , $effective_configuration
  	                                       );
  	log_debug "Packages to be installed: @{[map {$_->qname} @packages]}";
  	log_trace "Packages to be installed:\n" . Dumper(\@packages);
  
  	# Now dispatch the subcommands
  	my ($subcommand) = @{$opts->{subcommand}};
  	log_info colored(['bold'], "Running subcommand @{[colored(['bold blue'], $subcommand)]}");
  
  	# Get the transactions required for our packages
  	my @transactions = map { $_->to_transactions } @packages;
  
  	if      (("apply" eq $subcommand) || ("diff" eq $subcommand)) {
  		# We now make three passes through the transactions:
  		#   prepare (this will run sideeffect preparations like expanding templates, etc.)
  		#   check   (this checks for file-conflicts etc as far as possible)
  		# And depending on dry-run mode:
  		#   apply   (acutally perform the operations)
  		# or
  		#   log     (only print what would be done)
  		# or
  		#   diff    (show differences between repository- and filesystem-state
  
  		# Build the context and create the "EmitCollection" transactions for the collections
  		my ($ctx, $colltrans) = $config->build_collection_context($effective_configuration);
  		push @transactions, @$colltrans;
  		$ctx->{$_} = $effective_configuration->{$_} for qw(facts packages);
  
  
  		my @files = map {
  			$_->get_files()
  		} @packages;
  		my %uniq;
  		for my $f (@files) {
  			if ($uniq{$f}++) {
  				die "Multiple packages produce file '$f' which is not an collection";
  			}
  		}
  
  
  		# Run the factors defined in the configuration
  		push @transactions, @{$config->build_factor_transactions($effective_configuration->{factors})};
  
  		# Make sure they are ordered correctly:
  		@transactions = sort {$a->order cmp $b->order} @transactions;
  
  		# Wrapper for safely executing actions
  		my $run = sub {
  			my ($code, $transactions) = @_;
  
  			for my $trans (@$transactions) {
  				try {
  					$code->($trans);
  				} catch {
  					my $id;
  					if (defined($trans->package)) {
  						$id = "package @{[$trans->package->qname]}";
  					} else {
  						$id = "toplevel or automatic transaction";
  					}
  					log_error("Error occured when processing $id:");
  					log_error($_);
  					die "Got a terminal failure for $id";
  				}
  			}
  		};
  
  		log_info colored(['bold'], "Running stage \"prepare\":");
  		$run->(sub { $_[0]->prepare($ctx) }, \@transactions);
  		log_info colored(['bold'], "Running stage \"check\":");
  		$run->(sub { $_[0]->check($ctx) }, \@transactions);
  
  		if    ("apply" eq $subcommand) {
  			if ($opts->{dryrun}) {
  				log_info colored(['bold'], "Running stage \"log\":");
  				$run->(sub { $_[0]->log($ctx) }, \@transactions);
  			} else {
  				log_info colored(['bold'], "Running stage \"apply\":");
  				$run->(sub { $_[0]->apply($ctx) }, \@transactions);
  			}
  		} elsif ("diff"  eq $subcommand) {
  			log_info colored(['bold'], "Running stage \"diff\":");
  			$run->(sub { print $_[0]->diff($ctx) }, \@transactions);
  		} else {
  			die "Internal: wrong subcommand $subcommand";
  		}
  	} elsif ("gc"    eq $subcommand) {
  		# Show artifacts that exist in the filesystem which stem from
  		# absent packages
  		my @blacklist = map {
  			$_->gc()
  		} $config->complement_packages(\@packages);
  
  		# Remove duplicates
  		my %uniq;
  		$uniq{$_} = 1 for @blacklist;
  
  		# Remove files created by installed packages
  		# (e.g.: two packages provide ~/config/tmux.conf, one of which is installed)
  		my @whitelist = map {
  			$_->get_files()
  		} @packages;
  		delete $uniq{$_} for @whitelist;
  
  		# Rewrite urls to use ~ for $HOME if possible
  		if (defined($ENV{HOME})) {
  			@blacklist = map { $_ =~ s/^\Q$ENV{HOME}\E/~/; $_ } keys %uniq;
  		} else {
  			@blacklist = keys %uniq;
  		}
  
  		print $_ . "\n" for sort @blacklist;
  	} else {
  		die "Internal: Unknown subcommand $subcommand";
  	}
  }
  
  1;
IGOR_CLI

$fatpacked{"Igor/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_CONFIG';
  package Igor::Config;
  use strict;
  use warnings;
  
  use Class::Tiny qw(file configurations), {
     	defaults     => {},
     	repositories => {},
  	packagedb    => undef,
  };
  
  use Data::Dumper;
  use Data::Diver;
  use Graph;
  use Igor::Merge;
  use Igor::Repository;
  use Igor::Util;
  use List::Util qw(reduce);
  use Log::ger;
  use Path::Tiny;
  use Try::Tiny;
  use Types::Standard qw(Any ArrayRef Dict HashRef Map Optional Str);
  use Storable qw(dclone);
  
  # Config file Schemata for TOML validation
  my $packageschema = Str;
  my $collectionschema = Dict[
  	destination => Str,
  	merger      => Optional[Str],
  	perm        => Optional[Str],
  ];
  my $repositoryschema = Dict[
  	path => Str,
  ];
  my $factorschema = Dict [
  	path => Str,
  	type => Optional[Str],
  ];
  my $mergers = Map[Str, Str];
  my $configurationschema = Dict[
  	mergers      => Optional[$mergers],
  	mergeconfig  => Optional[HashRef],
  	dependencies => Optional[ArrayRef[Str]],
  	packages     => Optional[ArrayRef[$packageschema]],
  	repositories => Optional[HashRef[$repositoryschema]],
  	facts        => Optional[Any],
  	factors      => Optional[ArrayRef[$factorschema]],
  	collections  => Optional[HashRef[$collectionschema]],
  	pattern      => Optional[Str],
  ];
  my $configschema = Dict[
  	defaults       => Optional[$configurationschema],
  	configurations => HashRef[$configurationschema],
  ];
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	# Merge configurations can only be applied configured in the defaults configuration
  	for my $key (keys %{$args->{configurations}}) {
  		if (exists($args->{configurations}->{$key}->{mergeconfig})) {
  			die "Syntax error for configuration $key: mergeconfigs may only be applied in the defaults section";
  		}
  	}
  
  	# Build Path::Tiny objects
  	for my $cfg (values %{$args->{configurations}}, $args->{defaults}) {
  		$cfg //= {};
  		$cfg->{repositories} //= {};
  		my $base = $args->{file}->parent;
  		my $make_abs = sub {
  			my $path = path($_[0]);
  			if ($path->is_relative) {
  				# Resolve relative paths in relation to the config file
  				$path = path("$base/$path");
  			}
  			$path
  		};
  		for my $factor (@{$cfg->{factors}}) {
  			if (exists $factor->{path}) {
  				$factor->{path} = $make_abs->($factor->{path});
  			}
  		}
  		for my $repokey (keys %{$cfg->{repositories}}) {
  			my $repo = $cfg->{repositories}->{$repokey};
  			if (exists $repo->{path}) {
  				$repo->{path} = $make_abs->($repo->{path});
  			}
  		}
  		$cfg->{collections} //= {};
  		for my $collkey (keys %{$cfg->{collections}}) {
  			my $coll = $cfg->{collections}->{$collkey};
  			$coll->{destination} = path($coll->{destination}) if exists $coll->{destination};
  		}
  		$cfg->{mergers} //= {};
  		for my $merger (keys %{$cfg->{mergers}}) {
  			$cfg->{mergers}->{$merger} = $make_abs->($cfg->{mergers}->{$merger});
  		}
  	}
  }
  
  sub from_file {
  	my ($filepath) = @_;
  
  	# Parse and read the config file
  	my $conf = Igor::Util::read_toml($filepath);
  	log_debug "Parsed configuration at '$filepath':\n" . Dumper($conf);
  
  	try {
  		# Validate the config
  		$configschema->($conf);
  	} catch {
  		die "Validating $filepath failed:\n$_";
  	};
  
  	return Igor::Config->new(file => path($filepath), %{$conf});
  }
  
  sub expand_dependencies {
  	my ($cfgs, $root) = @_;
  
  	# Expand the configuration dependencies by depth first search
  	return Igor::Util::toposort_dependencies($cfgs, $root, sub { $_[0]->{dependencies} });
  }
  
  sub determine_effective_configuration {
  	my ($self, $root) = @_;
  
  	die "No such configuration: $root" unless defined $self->configurations->{$root};
  
  	my @cfgnames = expand_dependencies($self->configurations, $root);
  	log_debug "Topological sort of dependencies: @cfgnames";
  
  	# Merge in reverse topological order
  	my @cfgs     = map {
  		my $cfg = $self->configurations->{$_};
  		die "No such configuration: $_" unless defined ($cfg);
  		$cfg;
  	} reverse @cfgnames;
  
  	my $configmergers = {
  		factors      => \&Igor::Merge::list_concat,
  		packages     => \&Igor::Merge::uniq_list_merge,
  		dependencies => \&Igor::Merge::uniq_list_merge,
  		# repositories and collections use the default hash merger, same for facts
  	};
  	my $mergers = $self->defaults->{mergers} // {};
  	my $cm = Igor::Util::traverse_nested_hash($self->defaults->{mergeconfig} // {}, sub {
  			my ($name, $bc) = @_;
  			unless(exists $mergers->{$name}) {
  				die "Configured merger '$name' for path @{$bc} is not defined";
  			}
  			Igor::Util::file_to_coderef($mergers->{$name});
  		});
  	$configmergers->{$_} = $cm->{$_} for (keys %$cm);
  
  	my $merger = Igor::Merge->new(
  		mergers => $configmergers,
  	);
  
  	# Prepend the defaults to the cfg list
  	unshift @cfgs, $self->defaults;
  
  	# Now merge the configurations, with entries of the later ones overlaying old values
  	my $effective = reduce { $merger->merge($a, $b) } @cfgs;
  	log_trace "Merged configuration: " . Dumper($effective);
  
  	return $effective;
  }
  
  sub resolve_package {
  	my ($packagename, $repositories, $packagedb) = @_;
  
  	# Packagenames can optionally be qualified "repo/packagename" or
  	# unqualified "packagename" Unqualified packagenames have to be unique
  	# among all repositories
  
  	# Step one: determine $repo and $pkgname
  	my ($reponame, $pkgname);
  
  	my @fragments = split /\//,$packagename,2;
  	if (@fragments == 2) {
  		# Qualified name, resolve repo -> package
  		my ($parent, $packagename) = @fragments;
  		$reponame = $parent;
  		$pkgname  = $packagename;
  	} elsif (@fragments == 1) {
  		# Unqualified name: search packagedb
  		my $alternatives = $packagedb->{$packagename};
  
  		# Do we have at least one packages?
  		die "No repository provides a package '$packagename': "
  		  . "Searched repositories: @{[sort keys %$repositories]}"
  		  unless defined($alternatives) &&  (@$alternatives);
  
  		# Do we have more than one alternative -> Qualification needed
  		die "Ambiguous packagename '$packagename': Instances include @$alternatives"
  			unless (@$alternatives == 1);
  
  		# We have exactly one instance for the package
  		$reponame = $alternatives->[0];
  		$pkgname  = $packagename;
  	} else {
  		# This should be unreachable
  		die "Internal: Invalid packagename $packagename\n";
  	}
  
  	# Actually lookup the package
  	my $repo = $repositories->{$reponame};
  	die "Unable to resolve qualified packagename '$packagename':"
  	  . " No such repository: $reponame" unless defined $repo;
  
  	return  $repo->resolve_package($pkgname);
  }
  
  # Given a list of packages and a list repositories, first resolve all
  # packages in the given repositories and build the dependency-graph
  #
  # Returns all packages that need to be installed
  sub expand_packages {
  	my ($self, $repositories, $packages, $config) = @_;
  
  	# This sets $self->repositories and $self->packagedb
  	$self->build_package_db($repositories, $config);
  
  	# Resolve all packages to qnames
  	my @resolved = map {
  			resolve_package( $_
  						   , $self->repositories
  						   , $self->packagedb)->qname
  		} @$packages;
  
  	# Now build the dependency graph
  	my $g = Graph::Directed->new;
  	for my $reponame (sort keys %{$self->repositories}) {
  		my $repo = $self->repositories->{$reponame};
  		# Subgraph for the repo
  		my $rg = $repo->dependency_graph;
  		# Merge it with the global graph, prefixing all vertexes
  		$g->add_vertex($_) for map { "$reponame/$_" } @{[$rg->vertices]};
  		for my $edge (@{[$rg->edges]}) {
  			my ($x,$y) = @{$edge};
  			$g->add_edge("$reponame/$x", "$reponame/$y");
  		}
  	}
  
  	# Now add a virtual 'start' and link it to all requested packages
  	$g->add_vertex("start");
  	for my $res (@resolved) {
  		$g->add_edge('start', $res);
  	}
  
  	my @packages = sort $g->all_reachable("start");
  	return map {
  		resolve_package( $_
  		               , $self->repositories
  		               , $self->packagedb)
  		} @packages;
  }
  
  # Given a list of packages (as Igor::Package) get all inactive packages
  sub complement_packages {
  	my ($self, $packages) = @_;
  
  	my %blacklist;
  	$blacklist{$_->id} = 1 for (@$packages);
  
  	my @complement;
  	my $packagedb = $self->packagedb;
  	my $repos     = $self->repositories;
  	for my $name (keys %$packagedb) {
  		next if $blacklist{$name};
  		for my $repo (@{$packagedb->{$name}}) {
  			$repo = $repos->{$repo};
  
  			push @complement, $repo->resolve_package($name);
  		}
  	}
  
  	return @complement;
  }
  
  sub build_package_db {
  	my ($self, $repositories, $config) = @_;
  
  	log_debug "Building packagedb";
  
  	my %repos     = ();
  	my %packagedb = ();
  
  	for my $name (sort keys %$repositories) {
  		my $repo = Igor::Repository->new(id => $name, directory => $repositories->{$name}->{path}, config => $config);
  		$repos{$name} = $repo;
  
  		for my $pkg (keys %{$repo->packagedb}) {
  			push(@{$packagedb{$pkg}}, $name);
  		}
  	}
  
  	log_trace "Build packagedb:\n" . Dumper(\%packagedb);
  
  	$self->repositories(\%repos);
  	$self->packagedb(\%packagedb);
  
  	return \%packagedb;
  }
  
  sub build_collection_context {
  	my ($self, $configuration) = @_;
  	my $collections = $configuration->{collections};
  
  	my @transactions;
  	my $ctx = { collections => {} };
  
  	for my $coll (keys %$collections) {
  		$ctx->{collections}->{$coll} = {};
  		my $pkg = Igor::Package->new(basedir => $self->file, repository => undef, id => "collection_$coll");
  		my $merger;
  		if (defined $collections->{$coll}->{merger}) {
  			my $mergerid   = $collections->{$coll}->{merger};
  			my $mergerfile = $configuration->{mergers}->{$mergerid};
  			die "No such merger defined: $mergerid" unless defined $mergerfile;
  			try {
  				$merger = Igor::Util::file_to_coderef($mergerfile);
  			} catch {
  				die "Error while processing collection '$coll': cannot create merger from $mergerfile: $_";
  			}
  		} else {
  			$merger = sub { my $hash = shift;
  				my @keys = sort { $a cmp $b } keys %$hash;
  				join('', map {$hash->{$_}} @keys)
  			};
  		}
  		push @transactions, Igor::Operation::EmitCollection->new(
  			collection => $coll,
  			merger => $merger,
  			sink => Igor::Sink::File->new( path => $collections->{$coll}->{destination}
  				                         , id => $pkg
  				                         , perm => $collections->{$coll}->{perm}
  									     ),
  			package => $pkg,
  			order   => 50,
  		);
  	}
  
  	return ($ctx, \@transactions);
  }
  
  sub build_factor_transactions {
  	my ($self, $factors) = @_;
  
  	my @transactions;
  	for my $factor (@$factors) {
  		push @transactions, Igor::Operation::RunFactor->new(%$factor, order => 1);
  	}
  
  	return \@transactions;
  }
  
  1;
  
  __END__
IGOR_CONFIG

$fatpacked{"Igor/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_DIFF';
  package Igor::Diff;
  use Exporter 'import';
  @EXPORT = qw(diff);
  
  use warnings;
  use strict;
  
  { package Igor::Colordiff;
  	use warnings;
  	use strict;
  
  	use Igor::Util qw(colored);
  	use Text::Diff;
  	our @ISA = qw(Text::Diff::Unified);
  
  	sub file_header {
  		my $self = shift;
  		colored(['bold bright_yellow'], $self->SUPER::file_header(@_));
  	}
  
  	sub hunk_header {
  		my $self = shift;
  		colored(['bold bright_magenta'], $self->SUPER::hunk_header(@_));
  	}
  
  	sub hunk {
  		my $self = shift;
  		my (undef, undef, $ops, undef) = @_;
  		my @lines = split /\n/, $self->SUPER::hunk(@_), -1;
  		my %ops2col = ( "+" => "bold bright_green"
  		              , " " => ""
  		              , "-" => "bold bright_red");
  		use Data::Dumper;
  		@lines = map {
  			my $color = $ops2col{$ops->[$_]->[2] // " "};
  			if ($color) {
  				colored([$color], $lines[$_]);
  			} else {
  				$lines[$_];
  			}
  		} 0 .. $#lines;
  		return join "\n", @lines;
  	}
  }
  
  sub diff {
  	my ($x, $y, $opts) = @_;
  
  	# Set style, allowing overrides
  	$opts->{STYLE} //= 'Igor::Colordiff';
  
  	return Text::Diff::diff($x, $y, $opts);
  }
IGOR_DIFF

$fatpacked{"Igor/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_MERGE';
  package Igor::Merge;
  use warnings;
  use strict;
  
  use Class::Tiny {
  	mergers => {},
  	clone   => 1,
  };
  
  use Log::ger;
  use Data::Diver qw(Dive);
  use Storable qw(dclone);
  
  sub select_merger {
  	my ($self) = @_;
  
  	my $merger = Dive($self->mergers, @{$self->{breadcrumb}});
  
  	return undef unless ref($merger) eq 'CODE';
  	return $merger;
  }
  
  # Implementation strongly influenced by Hash::Merge and Hash::Merge::Simple,
  # which in turn borrowed from Catalyst::Utils... thanks!
  sub _merge {
  	my ($self, $left, $right) = @_;
  
  	for my $key (keys %$right) {
  		my ($er, $el) = map { exists $_->{$key} } $right, $left;
  
  		# We only have to merge duplicate keys
  		if ($er and not $el) {
  			# copy keys that don't exist in $right to $left
  			$left->{$key} = $right->{$key};
  			next;
  		} elsif (not $er) {
  			# Key only in right
  			next;
  		}
  
  		push @{$self->{breadcrumb}}, $key;
  		my $merger = $self->select_merger;
  
  		if (defined $merger) {
  			log_trace "Running a custom merger on @{$self->{breadcrumb}}";
  			# A custom merger was defined for this value
  			$left->{$key} = $merger->($left->{$key}, $right->{$key}, $self->{breadcrumb});
  		} else {
  			my ($hr, $hl) = map { ref $_->{$key} eq 'HASH' } $right, $left;
  			if ($hr and $hl) {
  				log_trace "Running hash-merge on @{$self->{breadcrumb}}";
  				# Both are hashes: Recurse
  				$left->{$key} = $self->_merge($left->{$key}, $right->{$key});
  			} else {
  				log_trace "Copying $key at @{$self->{breadcrumb}}";
  				# Mixed types or non HASH types: Overlay wins
  				$left->{$key} = $right->{$key};
  			}
  		}
  		pop @{$self->{breadcrumb}};
  	}
  
  	return $left;
  }
  
  sub merge {
  	my ($self, $left, $right) = @_;
  
  	# optionally deeply duplicate the hashes before merging
  	if ($self->clone) {
  		$left  = dclone($left);
  		$right = dclone($right);
  	}
  
  	return $self->_merge($left, $right);
  }
  
  sub list_concat {
  	my ($lista, $listb, $breadcrumbs) = @_;
  
  	log_trace "Running list_concat on @{$breadcrumbs}";
  
  	push @$lista, @$listb;
  
  	return $lista;
  }
  
  # Merges two lists, while eliminating duplicates in the latter list
  sub uniq_list_merge {
  	my ($lista, $listb, $breadcrumbs) = @_;
  
  	log_trace "Running uniq_list_merge on @{$breadcrumbs}";
  
  	# We want to do the removal of duplicates in a stable fashion...
  	my @uniqs;
  	for my $i (@$listb) {
  		push @uniqs, $i unless grep /^$i$/, @$lista;
  	}
  	push @$lista, @uniqs;
  
  	return $lista;
  }
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	$self->{breadcrumb} //= [];
  }
  
  1;
IGOR_MERGE

$fatpacked{"Igor/Operation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_OPERATION';
  package Igor::Operation;
  use strict;
  use warnings;
  
  use Class::Tiny qw(package order);
  use Data::Dumper;
  use Igor::Sink;
  
  sub prepare { die 'Not implemented'; }
  sub check   { die 'Not implemented'; }
  sub apply   { die 'Not implemented'; }
  sub diff    { die 'Not implemented'; }
  sub log     { die 'Not implemented'; }
  
  sub select_backend {
  	my ($self, $sink) = @_;
  
  	for my $backend (@{$sink->requires}) {
  		return $backend if grep {$_ == $backend} @{$self->backends};
  	}
  
  	die "No matching backend between @{[ref($self)]} and sink @{[ref($sink)]}";
  }
  
  sub prepare_file_for_backend {
  	my ($self, $file, $backend) = @_;
  
  	if ($backend == Igor::Pipeline::Type::FILE) {
  		# File backend: Simply pass the file
  		return $file->absolute;
  	} elsif ($backend == Igor::Pipeline::Type::TEXT) {
  		# Text backend: Pass by content
  		die "@{[$file->stringify]}: Is no regular file\n" .
  		    "Only operation 'symlink' with regular file targets (no collections)" unless -f $file;
  		return $file->slurp_utf8;
  	}
  
  	die "Internal: Unknown backend: $backend";
  }
  
  
  package Igor::Operation::Template;
  use strict;
  use warnings;
  
  use Igor::Sink;
  
  use Class::Tiny qw(template sink), {
  	content  => undef,
  	delimiters => undef,
  	backends => [Igor::Pipeline::Type::TEXT]
  };
  use parent 'Igor::Operation';
  
  use Const::Fast;
  use Data::Dumper;
  use Log::ger;
  use Safe;
  use Scalar::Util qw(reftype);
  use Text::Template;
  use Time::localtime;
  
  =begin
  Generate variable declarations for C<Text::Template>'s C<HASH> parameter when used in
  conjunction with C<use strict>.
  
  Params:
  	datahash - the HASH parameter passed to C<Text::Template>
  
  Returns:
  	Multiple C<use> declarations that predeclare the variables that will be autogenerated
  	by C<Text::Template>.
  
  	Supported Referencetypes are:
  	- plain strings and numbers
  	- HASH
  	- ARRAY
  	- SCALAR
  	- REF
  
  Exceptions:
  	Dies on unknown reftypes
  =cut
  sub gen_template_variable_declarations {
  	my ($datahash) = @_;
  
  	# For use strict to work, we have predeclare the relevant variables
  	# and therefore mangle accordingly.
  	my @variables;
  	for my $key (sort keys %$datahash) {
  		my $value = $datahash->{$key};
  		# Mangling is described in
  		# https://metacpan.org/pod/Text::Template#PREPEND-feature-and-using-strict-in-templates
  
  		if (not defined $value) {
  			# "If the value is undef, then any variables named $key, @key,
  			#  %key, etc., are undefined."
  			push @variables, ("\$$key", "\%$key", "\@$key");
  			next;
  		}
  
  		my $type = reftype($value) // '';
  		if ($type eq '') {
  			# If the value is a string or a number, then $key is set to
  			# that value in the template. For anything else, you must pass a
  			# reference."
  			push @variables, "\$$key";
  		} elsif ($type eq 'ARRAY') {
  			# If the value is a reference to an array, then @key is set to that
  			# array.
  			push @variables, "\@$key";
  		} elsif ($type eq 'HASH') {
  			# If the value is a reference to a hash, then %key is set to that
  			# hash.
  			push @variables, "\%$key";
  		} elsif ($type eq 'SCALAR' || $type eq 'REF') {
  			# Similarly if value is any other kind of reference. This means that
  			#
  			#   var => "foo" and var => \"foo"
  			#
  			# have almost exactly the same effect. (The difference is that in
  			# the former case, the value is copied, and in the latter case it is
  			# aliased.)
  			push @variables, "\$$key";
  		} else {
  			log_error "Unexpected reference type '$type' passed to template";
  			die "Unexpected reference type '$type' passed to template";
  		}
  	}
  	my $decl = join('', map { "our $_;" } @variables);
  	log_trace "gen_template_variable_declaration: $decl";
  	return $decl;
  }
  
  sub prepare {
  	my ($self, $ctx) = @_;
  
  	my $facts     = $ctx->{facts};
  	my $packages  = $ctx->{packages};
  	my $automatic = $ctx->{automatic};
  	my $srcfile   = $self->template;
  
  	die "Template $srcfile is not a regular file" unless -f $srcfile;
  
  	log_debug "Preparing Template: $srcfile";
  
  	# Hash for passing gathered facts and installed packages into templates
  	const my $data => {
  		facts     => $facts,
  		packages  => $packages,
  		automatic => $automatic,
  	};
  
  	# Use stricts requires that we predeclare those variables
  	my $decls = gen_template_variable_declarations($data);
  
  	# Create a Safe compartment for evaluation, with the opcodes
  	# in :default being whitelisted:
  	#   https://metacpan.org/pod/Opcode#Predefined-Opcode-Tags
  	my $compartment = Safe->new();
  
  	my %templateconfig = (
  		TYPE => 'FILE',
  		SOURCE => $srcfile,
  		PREPEND => q{use warnings; use strict;} . $decls,
  		SAFE => $compartment,
  		BROKEN => sub { my %data = @_;
  			die "Error encountered for $srcfile:$data{lineno}: $data{error}";
  		},
  	);
  
  	# Optionally enable custom delimiters
  	if (defined($self->delimiters)) {
  		$templateconfig{DELIMITERS} = [$self->delimiters->{open}, $self->delimiters->{close}];
  	}
  
  	# Build the actual template
  	my $template = Text::Template->new(
  		%templateconfig
  	) or die "Couldn't create template from '$srcfile': $Text::Template::ERROR";
  
  	log_trace "Evaluating Template: $srcfile over:\n" . Dumper($data);
  	my $content = $template->fill_in(HASH => $data);
  	unless (defined $content) {
  		die "Error while filling in template '$srcfile': $Text::Template::ERROR";
  	}
  	$self->content($content);
  
  	log_trace "Result:\n" . Dumper($self->content);
  
  	return $self->content;
  }
  
  sub apply {
  	my ($self, $ctx) = @_;
  
  	# Write $content to outfile or collection...
  	unless (defined $self->content) {
  		log_warn "@{[ref($self)]}: prepare not called for template @{[$self->template]} when applying";
  		$self->prepare($ctx);
  	}
  
  	return $self->sink->emit(Igor::Pipeline::Type::TEXT, $self->content, $ctx);
  }
  
  sub log {
  	my ($self) = @_;
  
  	log_info "Applying  @{[$self->template]} to '@{[$self->sink->stringify]}'";
  }
  
  sub check {
  	my ($self, $ctx) = @_;
  
  	unless (defined $self->content) {
  		log_warn "@{[ref($self)]}: prepare not called for template @{[$self->template]} when checking\n";
  	}
  
  	return $self->sink->check(Igor::Pipeline::Type::TEXT, $self->content, $ctx);
  }
  
  sub diff {
  	my ($self, $ctx) = @_;
  
  	unless (defined $self->content) {
  		log_warn "@{[ref($self)]}: prepare not called for template @{[$self->template]} when diffing\n";
  	}
  
  	return $self->sink->diff( Igor::Pipeline::Type::TEXT, $self->content, $ctx
  	                        , FILENAME_A => $self->template
  							, MTIME_A => $self->template->stat->mtime());
  }
  
  package Igor::Operation::FileTransfer;
  use strict;
  use warnings;
  
  use Igor::Sink;
  
  use Class::Tiny qw(source sink), {
  	backends => [Igor::Pipeline::Type::FILE, Igor::Pipeline::Type::TEXT],
  	data => undef,
  	backend => undef,
  };
  use parent 'Igor::Operation';
  
  use Log::ger;
  use Time::localtime;
  
  sub prepare {
  	my ($self) = @_;
  
  	my $backend = $self->select_backend($self->sink);
  	$self->backend($backend);
  	$self->data($self->prepare_file_for_backend($self->source, $backend));
  }
  
  sub check   {
  	my ($self, $ctx) = @_;
  
  	return $self->sink->check($self->backend, $self->data, $ctx);
  }
  
  sub apply   {
  	my ($self, $ctx) = @_;
  
  	my $backend = $self->backend;
  	my $data    = $self->data;
  
  	log_trace "Filetransfer: @{[$self->sink->stringify]} with $data";
  	# Symlink the two files...
  	return $self->sink->emit($backend, $data, $ctx);
  }
  
  sub diff {
  	my ($self, $ctx) = @_;
  
  	my $backend = $self->backend;
  	my $data    = $self->data;
  
  	return $self->sink->diff( $backend, $data, $ctx
  	                        , FILENAME_A => $self->source
  	                        , MTIME_A => $self->source->stat->mtime);
  }
  
  sub log {
  	my ($self) = @_;
  
  	log_info "Linking   '@{[$self->source]}' to '@{[$self->sink->stringify]}'";
  }
  
  
  package Igor::Operation::EmitCollection;
  use strict;
  use warnings;
  
  use parent 'Igor::Operation';
  use Class::Tiny qw(collection merger sink), {
  	data => undef,
  };
  
  use Log::ger;
  use Data::Dumper;
  
  sub prepare {
  	my ($self, $ctx) = @_;
  
  	my $collection = $ctx->{collections}->{$self->collection};
  	die "Unknown collection '@{[$self->collection]}'" unless defined $collection;
  
  	return 1;
  }
  
  sub check   {
  	my ($self, $ctx) = @_;
  
  	my $collection = $ctx->{collections}->{$self->collection};
  	my $data = $self->merger->($collection, $self->collection);
  	log_trace "Merged collection '@{[$self->collection]}': $data";
  	$self->data($data);
  
  	return $self->sink->check(Igor::Pipeline::Type::TEXT, $self->data, $ctx);
  }
  
  sub apply   {
  	my ($self, $ctx) = @_;
  
  	log_trace "Emitting collection '@{[$self->sink->path]}': @{[$self->data]}";
  	return $self->sink->emit(Igor::Pipeline::Type::TEXT, $self->data, $ctx);
  }
  
  sub diff {
  	my ($self, $ctx) = @_;
  
  	return $self->sink->diff( Igor::Pipeline::Type::TEXT, $self->data, $ctx
  	                        , FILENAME_A => "Collection " . $self->collection
  	                        , MTIME_A    => time());
  }
  
  sub log {
  	my ($self) = @_;
  
  	log_info "Emitting  collection '@{[$self->sink->stringify]}'";
  }
  
  package Igor::Operation::RunCommand;
  use strict;
  use warnings;
  
  use Igor::Sink;
  
  use Class::Tiny qw(command), {
  	basedir  => "",
  	backends => [],
  };
  use parent 'Igor::Operation';
  
  use Cwd;
  use Log::ger;
  use File::pushd;
  use File::Which;
  
  sub prepare { 1; } # No preparation needed
  
  sub check   {
  	my ($self) = @_;
  
  	# If we execute a proper command (vs relying on sh),
  	# we can actually check whether the binary exists...
  	if (ref($self->command) eq 'ARRAY') {
  		my $binary = File::Which::which($self->command->[0]);
  		log_debug "Resolved @{[$self->command->[0]]} to @{[$binary // 'undef']}";
  		return defined($binary);
  	}
  
  	log_trace "Cannot check shell expression @{[$self->command]}";
  	1;
  }
  
  sub apply {
  	my ($self) = @_;
  
  	# If possible, we run the commands from the package directory
  	my $basedir = $self->basedir;
  	unless ($basedir) {
  		$basedir = getcwd;
  	}
  	my $dir = pushd($basedir);
  
  	# Execute
  	my $retval;
  	my $strcmd;
  	if (ref($self->command) eq 'ARRAY') {
  		$retval = system(@{$self->command});
  		$strcmd = join(' ', @{$self->command});
  	} else {
  		$retval = system($self->command);
  		$strcmd = $self->command;
  	}
  
  	$retval == 0 or die "system($strcmd) in @{[$self->basedir]} failed with exitcode: $?";
  	1;
  }
  
  sub log {
  	my ($self) = @_;
  
  	if (ref($self->command) eq 'ARRAY') {
  		log_info "Executing (safe)   system('@{[@{$self->command}]}')"
  	} else {
  		log_info "Executing (unsafe) system('@{[$self->command]}')"
  	}
  	1;
  }
  
  sub diff {
  	my ($self) = @_;
  
  	return '';
  }
  
  package Igor::Operation::RunFactor;
  use strict;
  use warnings;
  
  use Class::Tiny qw(path), {
  	type  => "perl",
  };
  use parent 'Igor::Operation';
  
  use Igor::Merge;
  use String::ShellQuote;
  use TOML;
  use TOML::Parser;
  use Try::Tiny;
  use Log::ger;
  
  sub prepare {
  	my ($self, $ctx) = @_;
  
  	my $facts;
  	if ($self->type eq 'perl') {
  		log_debug "Executing file '@{[$self->path]}' as perl-factor";
  		my $factor = Igor::Util::file_to_coderef($self->path);
  		$facts = $factor->();
  	} elsif ($self->type eq 'script') {
  		log_debug "Executing file '@{[$self->path]}' as script-factor";
  		local $TOML::PARSER = TOML::Parser->new(
  			inflate_boolean => sub { $_[0] eq 'true' ? \1 : \0 },
  		);
  		my $cmd = shell_quote($self->path);
  		my $output = `$cmd`;
  		if ($? == -1) {
  			die "Failed to execute factor $cmd: $!\n";
  		} elsif ($? & 127) {
  			die "Factor '$cmd' died with signal @{[($? & 127)]}\n";
  		} elsif (($? >> 8) != 0) {
  			die "Factor '$cmd' failed: Factor exited with @{[$? >> 8]}\n";
  		}
  
  		if (!defined($output)) {
  			die "Failed to run factor command: '$cmd'";
  		}
  
  		try {
  			$facts = from_toml($output);
  		} catch {
  			die "Factor '$cmd' failed: Invalid TOML produces:\n$_";
  		}
  	} else {
  		die "Unknown factor type: @{[$self->type]}";
  	}
  
  	# Use the HashMerger to merge the automatic variables
  	my $auto = $ctx->{automatic} // {};
  	my $merger = Igor::Merge->new();
  	$ctx->{automatic} = $merger->merge($auto, $facts);
  	1;
  }
  
  sub check   {
  	1;
  }
  
  sub apply {
  	1;
  }
  
  sub log {
  	my ($self) = @_;
  	log_info "Already executed factor '@{[$self->path]}' of type @{[$self->type]}";
  	1;
  }
  
  sub diff {
  	my ($self) = @_;
  	return '';
  }
  
  1;
  __END__
IGOR_OPERATION

$fatpacked{"Igor/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_PACKAGE';
  package Igor::Package;
  use strict;
  use warnings;
  
  use Class::Tiny qw(basedir repository id), {
  	dependencies => [],
  	files        => [],
  	precmds      => [],
  	postcmds     => [],
  	templates    => [],
  	artifacts    => [],
  };
  
  use Data::Dumper;
  use Path::Tiny;
  use Try::Tiny;
  use Type::Tiny;
  use Types::Standard qw(Any ArrayRef Dict HashRef Optional Str);
  
  use Igor::Operation;
  use Igor::Util;
  
  # Config file Schemata for TOML validation
  my $commandschema  = Str | ArrayRef[Str];
  my $fileschema     = Dict[
  	source     => Str,
  	collection => Str,
  ] | Dict[
  	source     => Str,
  	dest       => Str,
  	perm       => Optional[Str],
  	operation  => Optional[Str]
  ];
  # Dependencies are files with a special preprocessingstep...
  my $templatedelimiter = Dict[
  	open  => Str,
  	close => Str,
  ];
  my $templateschema = Dict[
  	source     => Str,
  	collection => Str,
  	delimiters => Optional[$templatedelimiter],
  ] | Dict[
  	source     => Str,
  	dest       => Str,
  	delimiters => Optional[$templatedelimiter],
  	perm       => Optional[Str],
  ];
  my $dependencyschema = Str;
  my $globschema = Str;
  
  my $packageschema = Dict[
  	dependencies => Optional[ArrayRef[$dependencyschema]],
  	files        => Optional[ArrayRef[$fileschema]],
  	templates    => Optional[ArrayRef[$templateschema]],
  	precmds      => Optional[ArrayRef[$commandschema]],
  	postcmds     => Optional[ArrayRef[$commandschema]],
  	artifacts    => Optional[ArrayRef[$globschema]],
  ];
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	# Build Path::Tiny objects for all filepaths
  	for my $ent (@{$args->{templates}}, @{$args->{files}}) {
  		for my $key (qw(source dest)) {
  			$ent->{$key} = path($ent->{$key}) if exists $ent->{$key};
  		}
  	}
  }
  
  sub from_file {
  	my ($filepath, $repository) = @_;
  
  	# Parse and read the config file
  	my $conf = Igor::Util::read_toml($filepath);
  	my $packagedir = path($filepath)->parent;
  
  	return from_hash($conf, $packagedir, $repository);
  }
  
  sub from_perl_file {
  	my ($filepath, $repository, $config) = @_;
  
  	my $packagesub = Igor::Util::file_to_coderef($filepath);
  	my $conf = $packagesub->($config);
  	my $packagedir = path($filepath)->parent;
  
  	return from_hash($conf, $packagedir, $repository);
  }
  
  sub from_hash {
  	my ($conf, $basedir, $repository) = @_;
  	try {
  		# Validate the config
  		$packageschema->($conf);
  	} catch {
  		die "Validating package-configuration at $basedir failed:\n$_";
  	};
  
  	return Igor::Package->new(basedir => $basedir
  		, repository => $repository
  		, id => $basedir->basename
  		, %{$conf});
  }
  
  sub qname {
  	my ($self) = @_;
  
  	my @segments;
  	if (defined $self->repository) {
  		push @segments, $self->repository->id;
  	}
  	push @segments, $self->id;
  
  	return join('/', @segments);
  }
  
  sub determine_sink {
  	 my ($file, $id) = @_;
  
  	if (defined($file->{dest})) {
  		return Igor::Sink::File->new(path => $file->{dest}, id => $id, perm => $file->{perm}, operation => $file->{operation});
  	} elsif (defined($file->{collection})) {
  		return Igor::Sink::Collection->new(collection => $file->{collection}, id => $id);
  	} else {
  		die "Failed to determine sink for file: " . Dumper($file);
  	}
  }
  
  sub to_transactions {
  	my ($self) = @_;
  	my @transactions;
  
  	# Run precommands
  	for my $cmd (@{$self->precmds}) {
  		push @transactions, Igor::Operation::RunCommand->new(
  			package => $self,
  			command => $cmd,
  			basedir => $self->basedir,
  			order   => 10,
  		);
  	}
  
  	# Symlink and create files
  	for my $file (@{$self->files}) {
  		my $source = path("@{[$self->basedir]}/$file->{source}");
  		# File mode bits: 07777 -> parts to copy
  		$file->{perm} //= $source->stat->mode & 07777;
  		push @transactions, Igor::Operation::FileTransfer->new(
  			package => $self,
  			source  => $source,
  			sink    => determine_sink($file, $self->qname),
  			order   => 20,
  		);
  	}
  
  	# Run the templates
  	for my $tmpl (@{$self->templates}) {
  		push @transactions, Igor::Operation::Template->new(
  			package    => $self,
  			template   => path("@{[$self->basedir]}/$tmpl->{source}"),
  			sink       => determine_sink($tmpl, $self->qname),
  			delimiters => $tmpl->{delimiters},
  			order      => 30,
  		);
  	}
  
  	# Now run the postcommands
  	for my $cmd (@{$self->postcmds}) {
  		push @transactions, Igor::Operation::RunCommand->new(
  			package => $self,
  			command => $cmd,
  			basedir => $self->basedir,
  			order   => 90,
  		);
  	}
  
  	@transactions;
  }
  
  sub get_files {
  	my ($self) = @_;
  
  	my @files     = map { $_->{dest} } @{$self->files}, @{$self->templates};
  	return map {
  		my $file = $_;
  		try {
  			$file = path($file)->realpath->stringify
  		} catch {
  			# Nonexistent file -> realpath does not work
  			$file = path($file)->absolute->stringify
  		};
  		$file
  	} grep { defined($_) } @files;
  }
  
  sub gc {
  	my ($self) = @_;
  
  	my @files     = map { $_->{dest} } @{$self->files}, @{$self->templates};
  	my @artifacts = map { Igor::Util::glob($_) } @{$self->artifacts};
  
  	return map {
  		path($_)->realpath->stringify
  	} grep { defined($_) } @files, @artifacts;
  }
  
  1;
  
  __END__
IGOR_PACKAGE

$fatpacked{"Igor/Repository.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_REPOSITORY';
  package Igor::Repository;
  use strict;
  use warnings;
  
  use Class::Tiny qw(id directory), {
  	packagedb => {}
  };
  
  use Igor::Package;
  use Igor::Util;
  use Path::Tiny;
  use Data::Dumper;
  use Log::ger;
  
  # Collect the packages contained in this repository from the filesystem at
  # C<dir> with effective configuration C<conf>
  sub collect_packages {
  	my ($self, $dir, $conf) = @_;
  
  	# Sanity check
  	die "Configured Repository at $dir is not an directory" unless $dir->is_dir;
  
  	# Visit all subdirectories, and create a package for it if there is a package.toml file
  	my $packages = $dir->visit(
  		sub {
  			my ($path, $state) = @_;
  
  			my $package;
  			if ((my $packagedesc = $path->child("package.toml"))->is_file) {
  				$package = Igor::Package::from_file($packagedesc, $self);
  			} elsif ((my $packagedescpl = $path->child("package.pl"))->is_file) {
  				$package = Igor::Package::from_perl_file($packagedescpl, $self, $conf);
  				log_debug ("Evaluated @{[$packagedescpl->stringify]}: " . Dumper($package));
  			}
  			return unless defined($package);
  
  			$state->{$path->basename} = $package;
  		}
  	);
  
  	return $packages;
  }
  
  sub dependency_graph {
  	my ($self) = @_;
  
  	my $g = Igor::Util::build_graph($self->packagedb, sub {
  			$_[0]->dependencies;
  		});
  
  	return $g;
  }
  
  sub resolve_package {
  	my ($self, $package) = @_;
  
  	my $resolved = $self->packagedb->{$package};
  
  	die "No such package '$package' in repository '$self->id'" unless defined $resolved;
  
  	return $resolved;
  }
  
  sub BUILD {
  	my ($self, $args) = @_;
  
  	# Make sure we've got a Path::Tiny object
  	# Dynamic typing IS funny :D
  	unless (ref($self->directory) eq 'Path::Tiny') {
  		$self->directory(path($self->directory));
  	}
  
  	$self->packagedb($self->collect_packages($self->directory, $args->{config}));
  }
  
  1;
  
  __END__
IGOR_REPOSITORY

$fatpacked{"Igor/Sink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_SINK';
  use strict;
  
  package Igor::Sink {
  use strict;
  use warnings;
  
  use Class::Tiny;
  
  sub requires { die "Not implemented"; }
  sub check    { die "Not implemented"; }
  sub emit     { die "Not implemented"; }
  sub diff     { die "Not implemented"; }
  
  }
  
  
  package Igor::Pipeline::Type {
  use strict;
  
  use constant {
  	TEXT => 0,
  	FILE => 1,
  };
  
  use constant {
  	CHANGED   => 0,
  	UNCHANGED => 1,
  };
  }
  
  package Igor::Sink::File {
  use strict;
  use warnings;
  
  use parent 'Igor::Sink';
  use Class::Tiny qw(path), {
  	perm => undef,
  	operation => undef,
  };
  
  use Const::Fast;
  use Data::Dumper;
  use Log::ger;
  use Igor::Diff ();
  use Try::Tiny;
  use Fcntl ':mode';
  
  const my @REQUIRES => (Igor::Pipeline::Type::FILE, Igor::Pipeline::Type::TEXT);
  
  sub BUILD {
  	my ($self, $args) = @_;
  	$args->{operation} //= 'symlink';
  
  	unless (grep { /^\Q$args->{operation}\E$/ } qw(symlink copy)) {
  		die "Illegal file operation specified for @{[$args->{path}]}: $args->{operation}";
  	}
  }
  
  sub requires { return \@REQUIRES; }
  
  sub prepare_for_copy {
  	my ($self, $typeref, $dataref) = @_;
  
  	if (defined $self->operation && $self->operation eq "copy") {
  		$$typeref = Igor::Pipeline::Type::TEXT;
  		# Text backend: Pass by content
  		die "@{[$$dataref->stringify]}: Is no regular file\n" .
  		    "Only operation 'symlink' with regular file targets (no collections) are supported for directories" unless -f $$dataref;
  		$$dataref = $$dataref->slurp_utf8();
  	}
  }
  
  sub check {
  	my ($self, $type, $data) = @_;
  
  	my $changeneeded = 0;
  
  	prepare_for_copy($self, \$type, \$data);
  
  	if ($type == Igor::Pipeline::Type::TEXT) {
  		try {
  			$changeneeded = $self->path->slurp_utf8() ne $data;
  		} catch {
  			$changeneeded = 1;
  		}
  	} elsif ($type == Igor::Pipeline::Type::FILE) {
  		try {
  			$changeneeded = not (S_ISLNK($self->path->lstat->mode) && ($self->path->realpath eq $data->realpath));
  		} catch {
  			$changeneeded = 1;
  		}
  	} else {
  		die "Unsupported type \"$type\" at \"@{[ __PACKAGE__ ]}\" when checking file @{[$self->path]}";
  	}
  
  	return $changeneeded;
  }
  
  sub emit {
  	my ($self, $type, $data) = @_;
  
  	return Igor::Pipeline::Type::UNCHANGED unless $self->check($type, $data);
  
  	prepare_for_copy($self, \$type, \$data);
  
  	# Create directory if the target directory does not exist
  	unless ($self->path->parent->is_dir) {
  		$self->path->parent->mkpath;
  	}
  
  	if ($type == Igor::Pipeline::Type::TEXT) {
  		log_trace "spew(@{[$self->path]}, " . Dumper($data) . ")";
  
  		# write the data
  		$self->path->spew_utf8($data);
  
  		# Fix permissions if requested
  		if (defined $self->perm) {
  			$self->path->chmod($self->perm);
  		}
  	} elsif ($type == Igor::Pipeline::Type::FILE) {
  		my $dest = $self->path->absolute;
  
  		# Remove the link if it exists
  		unlink $dest if -l $dest;
  
  		# symlink
  		symlink $data,$dest or die "Failed to symlink: $dest -> $data: $!";
  	} else {
  		die "Unsupported type \"$type\" at \"" . __PACKAGE__ . "\" when emitting file @{[$self->path]}";
  	}
  
  	return Igor::Pipeline::Type::CHANGED;
  }
  
  sub diff {
  	my ($self, $type, $data, undef, %opts) = @_;
  
  	prepare_for_copy($self, \$type, \$data);
  
  	my $diff;
  	if ($type == Igor::Pipeline::Type::TEXT) {
  		try {
  			$diff = Igor::Diff::diff \$data, $self->path->stringify, \%opts;
  		} catch {
  			$diff = $_;
  		}
  	} elsif ($type == Igor::Pipeline::Type::FILE) {
  		try {
  			$diff = Igor::Diff::diff $data->stringify, $self->path->stringify, \%opts;
  		} catch {
  			$diff = $_;
  		}
  	} else {
  		die "Unsupported type \"$type\" at \"" . __PACKAGE__ . "\" when checking file $self->path";
  	}
  
  	return $diff;
  }
  
  sub stringify {
  	my ($self) = @_;
  
  	my $name = $self->path->stringify;
  	if(defined $self->perm) {
  		my $perm = sprintf("%o", $self->perm);
  		$name .= " (chmod $perm)";
  	}
  
  	return $name;
  }
  }
  
  package Igor::Sink::Collection {
  use strict;
  use warnings;
  
  # Collection sinks are a bit of a hack: They simply export to a context, which
  # will later be used to fuse the collection. Therefore check, emit and diff
  # are subs, only crating a suitable ctx for the actual ops.
  
  use parent 'Igor::Sink';
  use Class::Tiny qw(collection id), {
  	checked => 0,
  };
  
  use Const::Fast;
  use Data::Dumper;
  use Log::ger;
  use Text::Diff ();
  
  const my @REQUIRES => (Igor::Pipeline::Type::TEXT);
  
  sub requires { \@REQUIRES }
  
  sub check {
  	my ($self, $type, $data, $ctx) = @_;
  
  	# Only build the context once
  	return 1 if $self->checked;
  
  	# Sanity-check: Input type
  	die   "Unsupported type \"$type\" at \"@{[__PACKAGE__]}\" "
  	    . "when emitting to collection @{[$self->collection]} for @{[$self->id]}" if Igor::Pipeline::Type::TEXT != $type;
  
  	# Ensure that collection exists
  	die "Unknown collection '@{[$self->collection]}' for package '@{[$self->id]}'"
  		unless exists $ctx->{collections}->{$self->collection};
  	my $collection = $ctx->{collections}->{$self->collection};
  
  	# Ensure that a package only writes to the context once
  	die "Duplicate entry for @{[$self->id]} in collection @{[$self->collection]}" if (exists $collection->{$self->id});
  
  	# Write to the context
  	$collection->{$self->id} = $data;
  
  	# Check has run
  	$self->checked(1);
  
  	return 1;
  }
  
  sub emit {
  	my ($self, $type, $data, $ctx) = @_;
  
  	# Sets $ctx
  	$self->check($type, $data, $ctx);
  
  	return Igor::Pipeline::Type::UNCHANGED;
  }
  
  sub diff {
  	my ($self, $type, $data, $ctx) = @_;
  
  	# Diff happens in a dedicated operation, based on $ctx
  	# Sets $ctx
  	$self->check($type, $data, $ctx);
  
  	return '';
  }
  
  sub stringify {
  	my ($self) = @_;
  
  	my $name = "collection(@{[$self->collection]})";
  	return $name;
  }
  }
  
  1;
  
  __END__
IGOR_SINK

$fatpacked{"Igor/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_TYPES';
  package Igor::Types;
  use warnings;
  use strict;
  
  use Type::Library -base;
  use Type::Utils -all;
  
  use Path::Tiny;
  
  BEGIN { extends "Types::Standard" };
  
  
  our $PathTiny = class_type "PathTiny", { class => "Path::Tiny" };
  coerce "PathTiny",
  	from "Str", via { Path::Tiny->new($_) };
  1;
  
  __END__
IGOR_TYPES

$fatpacked{"Igor/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IGOR_UTIL';
  package Igor::Util;
  use Exporter 'import';
  @EXPORT_OK = qw(colored);
  
  use strict;
  use warnings;
  use feature 'state';
  
  use Data::Diver qw(DiveRef);
  use Data::Dumper;
  use File::Glob ':bsd_glob';
  use Graph;
  use Graph::Directed;
  use Log::ger;
  use Net::Domain;
  use Path::Tiny;
  use Scalar::Util qw(reftype);
  use Sys::Hostname;
  use Term::ANSIColor ();
  use TOML;
  use TOML::Parser;
  
  sub read_toml {
  	my ($filepath) = @_;
  
  	state $parser = TOML::Parser->new(
  		inflate_boolean => sub { $_[0] eq 'true' ? \1 : \0 },
  	);
  	my ($conf, $err) = $parser->parse_file($filepath);
  	unless ($conf) {
  		log_error "Parsing of $filepath failed: $err";
  		die $err;
  	}
  
  	return $conf;
  }
  
  sub build_graph {
  	my ($hash, $lambda_deps) = @_;
  
  	# Build the graph
  	my $g = Graph::Directed->new;
  
  	for my $key (sort keys %$hash) {
  		$g->add_vertex($key);
  		my $deps = $lambda_deps->($hash->{$key});
  		next unless defined($deps);
  		for my $child (@$deps) {
  			$g->add_edge($key, $child);
  		}
  	}
  
  	return $g;
  }
  
  sub toposort_dependencies {
  	my ($hash, $root, $lambda_deps) = @_;
  
  	my $g = build_graph($hash, $lambda_deps);
  	$g->add_vertex($root);
  
  	log_trace "Dependency graph: $g\n";
  
  	# Do a topological sort
  	my @ts = $g->topological_sort;
  
  	# Now restrict that to the nodes reachable from the root
  	my %r = ($root => 1);
  	$r{$_}=1 for ($g->all_reachable($root));
  
  	my @order = grep { $r{$_} } @ts;
  	return @order;
  }
  
  # Tries to determine an identifier for the current computer from the following sources:
  #    - fully qualified domain name (via Net::Domain)
  #    - hostname (via Sys::Hostname)
  # In the following order, this sources are probed, the first successful entry is returned
  sub guess_identifier {
  	# Try fqdn
  	my $fqdn = Net::Domain::hostfqdn;
  	return $fqdn if defined $fqdn;
  
  	# Try hostname
  	return Sys::Hostname::hostname; # Croaks on error
  }
  
  sub colored {
  	if (-t STDOUT) { # outputting to terminal
  		return Term::ANSIColor::colored(@_);
  	} else {
  		# Colored has two calling modes:
  		#   colored(STRING, ATTR[, ATTR ...])
  		#   colored(ATTR-REF, STRING[, STRING...])
  
  		unless (ref($_[0])) { # Called as option one
  			return $_;
  		} else { # Called as option two
  			shift;
  			return @_;
  		}
  	}
  }
  
  sub glob {
  	my ($pattern) = @_;
  
  	return bsd_glob($pattern, GLOB_BRACE | GLOB_MARK | GLOB_NOSORT | GLOB_QUOTE | GLOB_TILDE);
  }
  
  # Read a file (as Path::Tiny instances) containing a sub and return the correspoding coderef
  sub file_to_coderef {
  	my ($path) = @_;
  	my $source = $path->slurp;
  	log_trace "Executing @{[$path]}:\n$source";
  	my $coderef = eval { eval($source) };
  	die "Failure while evaluating the coderef at @{[$path]}: $@\n" if not defined $coderef;
  	return $coderef;
  }
  
  # Traversal for HASH of HASH of HASH ... calls the callback with the value and current list of breadcrumbs
  # i.e.: [key1, innerkey2, innermostkey3]
  sub traverse_nested_hash {
  	my ($hash, $cb) = @_;
  
  	my @worklist = ({
  		breadcrumbs => [],
  		data => $hash,
  	});
  
  	my %result;
  
  	while(@worklist) {
  		my $ctx = pop @worklist;
  		my @breadcrumbs = @{$ctx->{breadcrumbs}};
  		my $d = $ctx->{data};
  		if (reftype($d) // '' eq 'HASH') {
  			for my $k (keys %$d) {
  				my $bc = [@breadcrumbs, $k];
  				push @worklist, { breadcrumbs => $bc, data => $d->{$k}};
  			}
  		} else {
  			my $ref = DiveRef(\%result, @breadcrumbs);
  			$$ref = $cb->($d, \@breadcrumbs);
  		}
  	}
  
  	return \%result;
  }
  
  1;
  
  __END__
IGOR_UTIL

$fatpacked{"Log/ger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER';
  package Log::ger;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  our $re_addr = qr/\(0x([0-9a-f]+)/o;
  
  our %Levels = (
      fatal   => 10,
      error   => 20,
      warn    => 30,
      info    => 40,
      debug   => 50,
      trace   => 60,
  );
  
  our %Level_Aliases = (
      off     => 0,
      warning => 30,
  );
  
  our $Current_Level = 30;
  
  our $Caller_Depth_Offset = 0;
  
  # a flag that can be used by null output to skip using formatter
  our $_logger_is_null;
  
  our $_dumper;
  
  our %Global_Hooks;
  
  # in Log/ger/Heavy.pm
  # our %Default_Hooks = (
  
  our %Package_Targets; # key = package name, value = \%init_args
  our %Per_Package_Hooks; # key = package name, value = { phase => hooks, ... }
  
  our %Hash_Targets; # key = hash address, value = [$hashref, \%init_args]
  our %Per_Hash_Hooks; # key = hash address, value = { phase => hooks, ... }
  
  our %Object_Targets; # key = object address, value = [$obj, \%init_args]
  our %Per_Object_Hooks; # key = object address, value = { phase => hooks, ... }
  
  my $sub0 = sub {0};
  my $sub1 = sub {1};
  my $default_null_routines;
  
  sub install_routines {
      my ($target, $target_arg, $routines) = @_;
  
      if ($target eq 'package') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              #print "D:installing $name to package $target_arg\n";
              *{"$target_arg\::$name"} = $code;
          }
      } elsif ($target eq 'object') {
  #IFUNBUILT
  #         no strict 'refs';
  #         no warnings 'redefine';
  #END IFUNBUILT
          my $pkg = ref $target_arg;
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_method\z/;
              *{"$pkg\::$name"} = $code;
          }
      } elsif ($target eq 'hash') {
          for my $r (@$routines) {
              my ($code, $name, $lnum, $type) = @$r;
              next unless $type =~ /_sub\z/;
              $target_arg->{$name} = $code;
          }
      }
  }
  
  sub add_target {
      my ($target, $target_arg, $args, $replace) = @_;
      $replace = 1 unless defined $replace;
  
      if ($target eq 'package') {
          unless ($replace) { return if $Package_Targets{$target_arg} }
          $Package_Targets{$target_arg} = $args;
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Object_Targets{$addr} }
          $Object_Targets{$addr} = [$target_arg, $args];
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unless ($replace) { return if $Hash_Targets{$addr} }
          $Hash_Targets{$addr} = [$target_arg, $args];
      }
  }
  
  sub _set_default_null_routines {
      $default_null_routines ||= [
          (map {(
              [$sub0, "log_$_", $Levels{$_}, 'log_sub'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "log_is_$_", $Levels{$_}, 'is_sub'],
              [$sub0, $_, $Levels{$_}, 'log_method'],
              [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "is_$_", $Levels{$_}, 'is_method'],
          )} keys %Levels),
      ];
  }
  
  sub get_logger {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      my $obj = []; $obj =~ $re_addr;
      my $pkg = "Log::ger::Obj$1"; bless $obj, $pkg;
      add_target(object => $obj, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(object => $obj, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(object => $obj, $default_null_routines);
      }
      $obj; # XXX add DESTROY to remove from list of targets
  }
  
  sub import {
      my ($package, %args) = @_;
  
      my $caller = caller(0);
      $args{category} = $caller if !defined($args{category});
      add_target(package => $caller, \%args);
      if (keys %Global_Hooks) {
          require Log::ger::Heavy;
          init_target(package => $caller, \%args);
      } else {
          # if we haven't added any hooks etc, skip init_target() process and use
          # this preconstructed routines as shortcut, to save startup overhead
          _set_default_null_routines();
          install_routines(package => $caller, $default_null_routines);
      }
  }
  
  1;
  # ABSTRACT: A lightweight, flexible logging framework
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger - A lightweight, flexible logging framework
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  In your module (producer):
  
   package Foo;
   use Log::ger; # will import some logging methods e.g. log_warn, log_error
  
   sub foo {
       ...
       # produce some logs
       log_error "an error occurred: %03d - %s", $errcode, $errmsg;
       ...
       log_debug "http response: %s", $http; # automatic dumping of data
   }
   1;
  
  In your application (consumer/listener):
  
   use Foo;
   use Log::ger::Output 'Screen';
  
   foo();
  
  =head1 DESCRIPTION
  
  Log::ger is yet another logging framework with the following features:
  
  =over
  
  =item * Separation of producers and consumers/listeners
  
  Like L<Log::Any>, this offers a very easy way for modules to produce some logs
  without having to configure anything. Configuring output, level, etc can be done
  in the application as log consumers/listeners. To read more about this, see the
  documentation of L<Log::Any> or L<Log::ger::Manual> (but nevertheless see
  L<Log::ger::Manual> on why you might prefer Log::ger to Log::Any).
  
  =item * Lightweight and fast
  
  B<Slim distribution.> No non-core dependencies, extra functionalities are
  provided in separate distributions to be pulled as needed.
  
  B<Low startup overhead.> Only ~0.5-1ms. For comparison, L<strict> ~0.2-0.5ms,
  L<warnings> ~2ms, L<Log::Any> 0.15 ~2-3ms, Log::Any 1.049 ~8-10ms,
  L<Log::Log4perl> ~35ms. This is measured on a 2014-2015 PC and before doing any
  output configuration. For more benchmarks, see L<Bencher::Scenarios::LogGer> or
  try yourself e.g. with L<bencher-code>:
  
   % bencher-code 'use Log::ger' 'use Log::Any' --startup
  
  B<Fast>. Low null-/stealth-logging overhead, about 1.5x faster than Log::Any, 3x
  faster than Log4perl, and 5x faster than L<Log::Fast>.
  
  B<Conditional compilation.> There is a plugin to optimize away unneeded logging
  statements, like assertion/conditional compilation, so they have zero runtime
  performance cost. See L<Log::ger::Plugin::OptAway>.
  
  Being lightweight means the module can be used more universally, from CLI to
  long-running daemons to inside routines with tight loops.
  
  =item * Flexible
  
  B<Customizable levels and routine/method names.> Can be used in a procedural or
  OO style. Log::ger can mimic the interface of L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, or some other popular logging frameworks, to ease migration or
  adjust with your personal style.
  
  B<Per-package settings.> Each importer package can use its own format/layout,
  output. For example, some modules that are migrated from Log::Any uses
  Log::Any-style logging, while another uses native Log::ger style, and yet some
  other uses block formatting like Log::Contextual. This eases code migration and
  teamwork. Each module author can preserve her own logging style, if wanted, and
  all the modules still use the same framework.
  
  B<Dynamic.> Outputs and levels can be changed anytime during run-time and
  logging routines will be updated automatically. This is useful in situation like
  a long-running server application: you can turn on tracing logs temporarily to
  debug problems, then turn them off again, without restarting your server.
  
  B<Interoperability.> There are modules to interop with Log::Any, either consume
  Log::Any logs (see L<Log::Any::Adapter::LogGer>) or produce logs to be consumed
  by Log::Any (see L<Log::ger::Output::LogAny>).
  
  B<Many output modules and plugins.> See C<Log::ger::Output::*>,
  C<Log::ger::Format::*>, C<Log::ger::Layout::*>, C<Log::ger::Plugin::*>. Writing
  an output module in Log::ger is easier than writing a Log::Any::Adapter::*.
  
  =back
  
  For more documentation, start with L<Log::ger::Manual>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  Some other popular logging frameworks: L<Log::Any>, L<Log::Contextual>,
  L<Log::Log4perl>, L<Log::Dispatch>, L<Log::Dispatchouli>.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER

$fatpacked{"Log/ger/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT';
  package Log::ger::Format;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  sub _import_sets_for_current_package { 1 }
  
  1;
  # ABSTRACT: Use a format plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format - Use a format plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set for current package only:
  
   use Log::ger::Format 'Block';
  
  or:
  
   use Log::ger::Format;
   Log::ger::Format->set_for_current_package('Block');
  
  To set globally:
  
   use Log::ger::Format;
   Log::ger::Format->set('Block');
  
  =head1 DESCRIPTION
  
  Note: Since format plugins affect log-producing code, the import syntax defaults
  to setting for current package instead of globally.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT

$fatpacked{"Log/ger/Format/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_FORMAT_NONE';
  package Log::ger::Format::None;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_formatter => [
              __PACKAGE__, 50,
              sub {
                  [sub {shift}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Perform no formatting on the message
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Format::None - Perform no formatting on the message
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Format 'None';
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_FORMAT_NONE

$fatpacked{"Log/ger/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_HEAVY';
  package Log::ger::Heavy;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  #IFUNBUILT
  # use strict;
  # use warnings;
  #END IFUNBUILT
  
  package
      Log::ger;
  
  #IFUNBUILT
  # use vars qw(
  #                $re_addr
  #                %Levels
  #                %Level_Aliases
  #                $Current_Level
  #                $Caller_Depth_Offset
  #                $_logger_is_null
  #                $_dumper
  #                %Global_Hooks
  #                %Package_Targets
  #                %Per_Package_Hooks
  #                %Hash_Targets
  #                %Per_Hash_Hooks
  #                %Object_Targets
  #                %Per_Object_Hooks
  #        );
  #END IFUNBUILT
  
  # key = phase, value = [ [key, prio, coderef], ... ]
  our %Default_Hooks = (
      create_formatter => [
          [__PACKAGE__, 90,
           # the default formatter is sprintf-style that dumps data structures
           # arguments as well as undef as '<undef>'.
           sub {
               my %args = @_;
  
               my $formatter = sub {
                   return $_[0] if @_ < 2;
                   my $fmt = shift;
                   my @args;
                   for (@_) {
                       if (!defined($_)) {
                           push @args, '<undef>';
                       } elsif (ref $_) {
                           require Log::ger::Util unless $_dumper;
                           push @args, Log::ger::Util::_dump($_);
                       } else {
                           push @args, $_;
                       }
                   }
                   sprintf $fmt, @args;
               };
               [$formatter];
           }],
      ],
  
      create_layouter => [],
  
      create_routine_names => [
          [__PACKAGE__, 90,
           # the default names are log_LEVEL() and log_is_LEVEL() for subroutine
           # names, or LEVEL() and is_LEVEL() for method names
           sub {
               my %args = @_;
  
               my $levels = [keys %Levels];
  
               return [{
                   log_subs    => [map { ["log_$_", $_]    } @$levels],
                   is_subs     => [map { ["log_is_$_", $_] } @$levels],
                   # used when installing to hash or object
                   log_methods => [map { ["$_", $_]        } @$levels],
                   is_methods  => [map { ["is_$_", $_]     } @$levels],
               }, 1];
           }],
      ],
  
      create_log_routine => [
          [__PACKAGE__, 10,
           # the default behavior is to create a null routine for levels that are
           # too high than the global level ($Current_Level). since we run at high
           # priority (10), this block typical output plugins at normal priority
           # (50). this is a convenience so normally a plugin does not have to
           # deal with level checking.
           sub {
               my %args = @_;
               my $level = $args{level};
               if (defined($level) && (
                   $Current_Level < $level ||
                       # there's only us
                       @{ $Global_Hooks{create_log_routine} } == 1)
               ) {
                   $_logger_is_null = 1;
                   return [sub {0}];
               }
               [undef]; # decline
           }],
      ],
  
      create_logml_routine => [],
  
      create_is_routine => [
          [__PACKAGE__, 90,
           # the default behavior is to compare to global level. normally this
           # behavior suffices. we run at low priority (90) so normal plugins
           # which typically use priority 50 can override us.
           sub {
               my %args = @_;
               my $level = $args{level};
               [sub { $Current_Level >= $level }];
           }],
      ],
  
      before_install_routines => [],
  
      after_install_routines => [],
  );
  
  for my $phase (keys %Default_Hooks) {
      $Global_Hooks{$phase} = [@{ $Default_Hooks{$phase} }];
  }
  
  # if flow_control is 1, stops after the first hook that gives non-undef result.
  # flow_control can also be a coderef that will be called after each hook with
  # ($hook, $hook_res) and can return 1 to mean stop.
  sub run_hooks {
      my ($phase, $hook_args, $flow_control,
          $target, $target_arg) = @_;
      #print "D: running hooks for phase $phase\n";
  
      $Global_Hooks{$phase} or die "Unknown phase '$phase'";
      my @hooks = @{ $Global_Hooks{$phase} };
  
      if ($target eq 'package') {
          unshift @hooks, @{ $Per_Package_Hooks{$target_arg}{$phase} || [] };
      } elsif ($target eq 'hash') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Hash_Hooks{$addr}{$phase} || [] };
      } elsif ($target eq 'object') {
          my ($addr) = "$target_arg" =~ $re_addr;
          unshift @hooks, @{ $Per_Object_Hooks{$addr}{$phase} || [] };
      }
  
      my $res;
      for my $hook (sort {$a->[1] <=> $b->[1]} @hooks)  {
          my $hook_res = $hook->[2]->(%$hook_args);
          if (defined $hook_res->[0]) {
              $res = $hook_res->[0];
              #print "D:   got result from hook $res\n";
              if (ref $flow_control eq 'CODE') {
                  last if $flow_control->($hook, $hook_res);
              } else {
                  last if $flow_control;
              }
          }
          last if $hook_res->[1];
      }
      return $res;
  }
  
  sub init_target {
      my ($target, $target_arg, $init_args) = @_;
  
      #print "D:init_target($target, $target_arg, ...)\n";
      my %hook_args = (
          target     => $target,
          target_arg => $target_arg,
          init_args  => $init_args,
      );
  
      my %formatters;
      run_hooks(
          'create_formatter', \%hook_args,
          # collect formatters, until a hook instructs to stop
          sub {
              my ($hook, $hook_res) = @_;
              my ($formatter, $flow_control, $fmtname) = @$hook_res;
              $fmtname = 'default' if !defined($fmtname);
              $formatters{$fmtname} ||= $formatter;
              $flow_control;
          },
          $target, $target_arg);
  
      my $layouter =
          run_hooks('create_layouter', \%hook_args, 1, $target, $target_arg);
  
      my $routine_names = {};
      run_hooks(
          'create_routine_names', \%hook_args,
          # collect routine names, until a hook instructs to stop.
          sub {
              my ($hook, $hook_res) = @_;
              my ($rn, $flow_control) = @$hook_res;
              $rn or return;
              for (keys %$rn) {
                  push @{ $routine_names->{$_} }, @{ $rn->{$_} };
              }
              $flow_control;
          },
          $target, $target_arg);
  
      my @routines;
      my $object = $target eq 'object';
  
    CREATE_LOG_ROUTINES:
      {
          my @rn;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{log_subs} || [] };
              push @rn, @{ $routine_names->{logml_subs} || [] };
          } else {
              push @rn, @{ $routine_names->{log_methods} || [] };
              push @rn, @{ $routine_names->{logml_methods} || [] };
          }
          my $mllogger0;
          for my $rn (@rn) {
              my ($rname, $lname, $fmtname) = @$rn;
              my $lnum; $lnum = $Levels{$lname} if defined $lname;
              my $routine_name_is_ml = !defined($lname);
              $fmtname = 'default' if !defined($fmtname);
  
              my $logger;
              my ($logger0, $logger0_is_ml);
              $_logger_is_null = 0;
              for my $phase (qw/create_logml_routine create_log_routine/) {
                  local $hook_args{name} = $rname;
                  local $hook_args{level} = $lnum;
                  local $hook_args{str_level} = $lname;
                  $logger0_is_ml = $phase eq 'create_logml_routine';
                  if ($mllogger0) {
                      # we reuse the same multilevel logger0 for all log routines,
                      # since it can handle different levels
                      $logger0 = $mllogger0;
                      last;
                  }
                  $logger0 = run_hooks(
                      $phase, \%hook_args, 1, $target, $target_arg)
                      or next;
                  if ($logger0_is_ml) {
                      $mllogger0 = $logger0;
                  }
                  last;
              }
              # this can happen if there is no create_logml_routine hook but
              # routine name is a logml routine
              unless ($logger0) {
                  $_logger_is_null = 1;
                  $logger0 = sub {0};
              }
  
              require Log::ger::Util if !$logger0_is_ml && $routine_name_is_ml;
  
              {
                  if ($_logger_is_null) {
                      # if logger is a null logger (sub {0}) we don't need to
                      # format message, layout message, or care about the logger
                      # being a subroutine/object
                      $logger = $logger0;
                      last;
                  }
  
                  my $formatter = $formatters{$fmtname}
                      or die "Formatter named '$fmtname' not available";
                  if ($formatter) {
                      if ($layouter) {
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
                                                                                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
                                  } else {       $logger = sub {                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
                              }
                          }
                      } else { # no layouter
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              } else { # routine name not multiple-level
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                    $formatter->(@_)                            ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
                              }
                          }
                      }
                  } else { # no formatter
                      { # no layouter, just to align
                          if ($logger0_is_ml) {
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) }; }
                              } else { # routine name not multiple-lvl
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,                          @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args, $lnum,                          @_                             ) }; }
                              }
                          } else { # logger0 not multiple-level
                              if ($routine_name_is_ml) {
                                  if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
                                                                                        $logger0->($init_args,                                 @_                             ) }; }
                              } else {
                                  if ($object) { $logger = sub { shift;                 $logger0->($init_args,                                 @_                             ) };
                                  } else {       $logger = sub {                        $logger0->($init_args,                                 @_                             ) }; }
                              }
                          }
                      }
                  }
              }
            L1:
              my $type = $routine_name_is_ml ?
                  ($object ? 'logml_method' : 'logml_sub') :
                  ($object ? 'log_method' : 'log_sub');
              push @routines, [$logger, $rname, $lnum, $type];
          }
      }
    CREATE_IS_ROUTINES:
      {
          my @rn;
          my $type;
          if ($target eq 'package') {
              push @rn, @{ $routine_names->{is_subs} || [] };
              $type = 'is_sub';
          } else {
              push @rn, @{ $routine_names->{is_methods} || [] };
              $type = 'is_method';
          }
          for my $rn (@rn) {
              my ($rname, $lname) = @$rn;
              my $lnum = $Levels{$lname};
  
              local $hook_args{name} = $rname;
              local $hook_args{level} = $lnum;
              local $hook_args{str_level} = $lname;
  
              my $code_is =
                  run_hooks('create_is_routine', \%hook_args, 1,
                            $target, $target_arg);
              next unless $code_is;
              push @routines, [$code_is, $rname, $lnum, $type];
          }
      }
  
      {
          local $hook_args{routines} = \@routines;
          local $hook_args{formatters} = \%formatters;
          local $hook_args{layouter} = $layouter;
          run_hooks('before_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  
      install_routines($target, $target_arg, \@routines);
  
      {
          local $hook_args{routines} = \@routines;
          run_hooks('after_install_routines', \%hook_args, 0,
                    $target, $target_arg);
      }
  }
  
  1;
  # ABSTRACT: The bulk of the implementation of Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Heavy - The bulk of the implementation of Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This module contains the bulk of the implementation of Log::ger, to keep
  Log::ger superslim.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_HEAVY

$fatpacked{"Log/ger/Layout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_LAYOUT';
  package Log::ger::Layout;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent qw(Log::ger::Plugin);
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Layout::/ }
  
  1;
  # ABSTRACT: Use a layout plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Layout - Use a layout plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Layout;
   Log::ger::Layout->set('Pattern');
  
  or:
  
   use Log::ger::Layout 'Pattern';
  
  To set for current package only:
  
   use Log::ger::Layout;
   Log::ger::Layout->set_for_current_package('Pattern');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Output>
  
  L<Log::ger::Plugin>
  
  L<Log::ger::Format>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_LAYOUT

$fatpacked{"Log/ger/Output.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT';
  package Log::ger::Output;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use parent 'Log::ger::Plugin';
  
  # we only use one output, so set() should replace all hooks from previously set
  # plugin package
  sub _replace_package_regex { qr/\ALog::ger::Output::/ }
  
  1;
  # ABSTRACT: Set logging output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output - Set logging output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Output;
   Log::ger::Output->set(Screen => (
       use_color => 1,
       ...
   );
  
  or:
  
   use Log::ger::Output 'Screen', (
       use_color=>1,
       ...
   );
  
  To set for current package only:
  
   use Log::ger::Output;
   Log::ger::Output->set_for_current_package(Screen => (
       use_color => 1,
       ...
   );
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Plugin>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT

$fatpacked{"Log/ger/Output/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAY';
  package Log::ger::Output::Array;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
  
                  my $logger = sub {
                      my ($ctx, $msg) = @_;
                      push @{$conf{array}}, $msg;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Array - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output Array => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAY

$fatpacked{"Log/ger/Output/ArrayML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_ARRAYML';
  package Log::ger::Output::ArrayML;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{array} or die "Please specify array";
  
      return {
          create_logml_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $logger = sub {
                      my $level = Log::ger::Util::numeric_level($_[1]);
                      return if $level > $Log::ger::Current_Level;
                      push @{$conf{array}}, $_[2];
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Log to array
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::ArrayML - Log to array
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Output ArrayML => (
       array         => $ary,
   );
  
  =head1 DESCRIPTION
  
  Mainly for testing only.
  
  This output is just like L<Log::ger::Output::Array> except that it provides a
  C<create_logml_routine> hook instead of C<create_log_routine>.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 array => arrayref
  
  Required.
  
  =head1 SEE ALSO
  
  L<Log::ger>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_ARRAYML

$fatpacked{"Log/ger/Output/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_COMPOSITE';
  package Log::ger::Output::Composite;
  
  our $DATE = '2017-07-02'; # DATE
  our $VERSION = '0.007'; # VERSION
  
  use strict;
  use warnings;
  
  sub _get_min_max_level {
      my $level = shift;
      my ($min, $max);
      if (defined $level) {
          if (ref $level eq 'ARRAY') {
              $min = Log::ger::Util::numeric_level($level->[0]);
              $max = Log::ger::Util::numeric_level($level->[1]);
              ($min, $max) = ($max, $min) if $min > $max;
          } else {
              $min = 0;
              $max = Log::ger::Util::numeric_level($level);
          }
      }
      ($min, $max);
  }
  
  sub get_hooks {
      my %conf = @_;
  
      my @ospecs;
      {
          my $outputs = $conf{outputs};
          for my $oname (sort keys %$outputs) {
              my $ospec0 = $outputs->{$oname};
              my @ospecs0;
              if (ref $ospec0 eq 'ARRAY') {
                  @ospecs0 = map { +{ %{$_} } } @$ospec0;
              } else {
                  @ospecs0 = (+{ %{ $ospec0 } });
              }
  
              die "Invalid output name '$oname'"
                  unless $oname =~ /\A\w+(::\w+)*\z/;
              my $mod = "Log::ger::Output::$oname";
              (my $mod_pm = "$mod.pm") =~ s!::!/!g;
              require $mod_pm;
              for my $ospec (@ospecs0) {
                  $ospec->{_name} = $oname;
                  $ospec->{_mod} = $mod;
                  push @ospecs, $ospec;
              }
          }
      }
  
      return {
          'create_logml_routine' => [
              __PACKAGE__, 50,
              sub {
                  no strict 'refs';
                  require Data::Dmp;
  
                  my %args = @_;
  
                  my $target = $args{target};
                  my $target_arg = $args{target_arg};
  
                  my $loggers = [];
                  my $logger_is_ml = [];
                  my $layouters = [];
                  for my $ospec (@ospecs) {
                      my $oname = $ospec->{_name};
                      my $mod = "Log::ger::Output::$oname";
                      my $hooks = &{"$mod\::get_hooks"}(%{ $ospec->{conf} || {} })
                          or die "Output module $mod does not return any hooks";
                      my @hook_args = (
                          target => $args{target},
                          target_arg => $args{target_arg},
                          init_args => $args{init_args},
                      );
                      my $res;
                      {
                          if ($hooks->{create_logml_routine}) {
                              $res = $hooks->{create_logml_routine}->[2]->(
                                  @hook_args);
                              if ($res->[0]) {
                                  push @$loggers, $res->[0];
                                  push @$logger_is_ml, 1;
                                  last;
                              }
                          }
                          push @hook_args, (level => 6, str_level => 'trace');
                          if ($hooks->{create_log_routine}) {
                              $res = $hooks->{create_log_routine}->[2]->(
                                  @hook_args);
                              if ($res->[0]) {
                                  push @$loggers, $res->[0];
                                  push @$logger_is_ml, 0;
                                  last;
                              }
                          }
                          die "Output module $mod does not produce logger in ".
                              "its create_logml_routine nor create_log_routine ".
                                  "hook";
                      }
                      if ($ospec->{layout}) {
                          my $lname = $ospec->{layout}[0];
                          my $lconf = $ospec->{layout}[1] || {};
                          my $lmod  = "Log::ger::Layout::$lname";
                          (my $lmod_pm = "$lmod.pm") =~ s!::!/!g;
                          require $lmod_pm;
                          my $lhooks = &{"$lmod\::get_hooks"}(%$lconf)
                              or die "Layout module $lmod does not return ".
                              "any hooks";
                          $lhooks->{create_layouter}
                              or die "Layout module $mod does not declare ".
                              "layouter";
                          my @lhook_args = (
                              target => $args{target},
                              target_arg => $args{target_arg},
                              init_args => $args{init_args},
                          );
                          my $lres = $lhooks->{create_layouter}->[2]->(
                              @lhook_args) or die "Hook from layout module ".
                                  "$lmod does not produce layout routine";
                          ref $lres->[0] eq 'CODE'
                              or die "Layouter from layout module $lmod ".
                              "is not a coderef";
                          push @$layouters, $lres->[0];
                      } else {
                          push @$layouters, undef;
                      }
                  }
                  unless (@$loggers) {
                      $Log::err::_logger_is_null = 1;
                      return [sub {0}];
                  }
  
                  # put the data that are mentioned in string-eval'ed code in a
                  # package so they are addressable
                  my $varname = do {
                      my $suffix;
                      if ($args{target} eq 'package') {
                          $suffix = $args{target_arg};
                      } else {
                          ($suffix) = "$args{target_arg}" =~ /\(0x(\w+)/;
                      }
                      "Log::ger::Stash::OComposite_$suffix";
                  };
                  {
                      no strict 'refs';
                      ${$varname} = [];
                      ${$varname}->[0] = $loggers;
                      ${$varname}->[1] = $layouters;
                      ${$varname}->[2] = $args{init_args};
                  }
  
                  # generate our logger routine
                  my $logger;
                  {
                      my @src;
                      push @src, "sub {\n";
                      push @src, "  my (\$ctx, \$lvl, \$msg) = \@_;\n";
  
                      for my $i (0..$#ospecs) {
                          my $ospec = $ospecs[$i];
                          push @src, "  # output #$i: $ospec->{_name}\n";
                          push @src, "  {\n";
  
                          # filter by output's category_level and category-level
                          if ($ospec->{category_level} || $conf{category_level}) {
                              push @src, "    my \$cat = \$ctx->{category} || ".
                                  "'';\n";
  
                              my @cats;
                              if ($ospec->{category_level}) {
                                  for my $cat (keys %{$ospec->{category_level}}) {
                                      my $clevel = $ospec->{category_level}{$cat};
                                      push @cats, [$cat, 1, $clevel];
                                  }
                              }
                              if ($conf{category_level}) {
                                  for my $cat (keys %{$conf{category_level}}) {
                                      my $clevel = $conf{category_level}{$cat};
                                      push @cats, [$cat, 2, $clevel];
                                  }
                              }
  
                              for my $cat (sort {
                                  length($b->[0]) <=> length($a->[0]) ||
                                      $a->[0] cmp $b->[0] ||
                                          $a->[1] <=> $b->[1]} @cats) {
                                  push @src, "    if (\$cat eq ".Data::Dmp::dmp($cat->[0])." || index(\$cat, ".Data::Dmp::dmp("$cat->[0]\::").") == 0) { ";
                                  my ($min_level, $max_level) =
                                      _get_min_max_level($cat->[2]);
                                  push @src, "if (\$lvl >= $min_level && ".
                                      "\$lvl <= $max_level) { goto L } else { last }";
                                  push @src, " }\n";
                              }
                              push @src, "\n";
                          }
  
                          # filter by output level
                          my ($min_level, $max_level) = _get_min_max_level(
                              $ospec->{level});
                          if (defined $min_level) {
                              push @src, "    if (\$lvl >= $min_level && ".
                                  "\$lvl <= $max_level) { goto L } else { last }\n";
                          }
  
                          # filter by general level
                          push @src, "    if (\$Log::ger::Current_Level >= \$lvl) { goto L } else { last }\n";
  
                          # run output's log routine
                          if ($logger_is_ml->[$i]) {
                              push @src, "    L: if (\$$varname\->[1][$i]) { \$$varname\->[0][$i]->(\$ctx, \$lvl, \$$varname\->[1][$i]->(\$msg, \$$varname\->[2], \$lvl, Log::ger::Util::string_level(\$lvl))) } else { \$$varname\->[0][$i]->(\$ctx, \$lvl, \$msg) }\n";
                          } else {
                              push @src, "    L: if (\$$varname\->[1][$i]) { \$$varname\->[0][$i]->(\$ctx,        \$$varname\->[1][$i]->(\$msg, \$$varname\->[2], \$lvl, Log::ger::Util::string_level(\$lvl))) } else { \$$varname\->[0][$i]->(\$ctx,        \$msg) }\n";
                          }
                          push @src, "  }\n";
                          push @src, "  # end output #$i\n\n";
                      } # for ospec
  
                      push @src, "};\n";
                      my $src = join("", @src);
                      #print "D: logger source code: <<$src>>\n";
  
                      $logger = eval $src;
                  }
                  [$logger];
              }]
      };
  }
  
  1;
  # ABSTRACT: Composite output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Composite - Composite output
  
  =head1 VERSION
  
  version 0.007
  
  =head1 SYNOPSIS
  
   use Log::ger::Output Composite => (
       outputs => {
           # single screen output
           Screen => {
               conf   => { use_color=>1 },                        # output config, optional.
               level  => 'info',                                  # set per-output level. optional.
               layout => [Pattern => {format=>'%d (%F:%L)> %m'}], # add per-output layout, optional.
           },
           # multiple file outputs
           File => [
               {
                   conf  => { path=>'/var/log/myapp.log' },
                   level => 'warn',
                   category_level => {                            # set per-category, per-output level. optional.
                       # don't log MyApp::Security messages to this file
                       'MyApp::Security' => 'off',
                       ...
                   },
               },
               {
                   conf => { path => '/var/log/myapp-security.log' },
                   level => 'warn',
                   category_level => {
                       # only MyApp::Security messages go to this file
                       'MyApp::Security' => 'warn',
                       ...
                   },
               },
           ],
       },
       category_level => {                                        # set per-category level. optional.
  
          'MyApp::SubModule1' => 'info',
          'MyApp::SubModule2' => 'debug',
          ...
       },
   );
   use Log::ger;
  
   log_warn "blah...";
  
  =head1 DESCRIPTION
  
  This is a L<Log::ger> output that can multiplex output to several outputs and do
  filtering on the basis of per-category level, per-output level, or per-output
  per-category level. It can also apply per-output layout.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 outputs => hash
  
  Specify outputs. It's a hash with output name as keys and output specification
  as values.
  
  Output name is the name of output module without the C<Log::ger::Output::>
  prefix, e.g. L<Screen|Log::ger::Output::Screen> or
  L<File|Log::ger::Output::File>.
  
  Output specification is either a hashref or arrayref of hashrefs to specify
  multiple outputs per type (e.g. if you want to output to two File's). Known
  hashref keys:
  
  =over
  
  =item * conf => hashref
  
  Specify output configuration. Optional. See each output documentation for the
  list of available configuration parameters.
  
  =item * level => str|int|[min, max]
  
  Specify per-output level. Optional. If specified, logging will be done at this
  level instead of the general level. For example, if this is set to C<debug> then
  debug messages and higher will be sent to output even though the general level
  is C<warn>. Vice versa, if this is set to C<error> then even though the general
  level is C<warn>, warning messages won't be sent to this output; only C<error>
  messages and higher will be sent.
  
  You can specify a single level (e.g. 1 or "trace") or a two-element array to
  specify minimum and maximum level (e.g. C<<["trace", "info"]>>). If you
  accidentally mix up minimum and maximum, this module will helpfully fix it for
  you.
  
  =item * category_level => hash
  
  Specify per-output per-category level. Optional. Hash key is category name,
  value is level (which can be a string/numeric level or a two-element array
  containing minimum and maximum level).
  
  =item * layout => [Name => {conf1=>..., conf2=>..., ...}]
  
  Specify per-output layout. Optional. Value is two-element array containing
  layout name (without the C<Log::ger::Layout::> prefix, e.g.
  L<Pattern|Log::ger::Layout::Pattern>) and configuration hash. See each layout
  module documentation for the list of available configuration parameters.
  
  Note that if you also use a layout module outside of Composite configuration,
  e.g.:
  
   use Log::ger::Output Composite => (...);
   use Log::ger::Layout Pattern => (format => '...');
  
  then both layouts will be applied, the general layout will be applied before the
  per-output layout.
  
  =back
  
  =head2 category_level => hash
  
  Specify per-category level. Optional. Hash key is category name, value is level
  (which can be a string/numeric level or a two-element array containing minimum
  and maximum level).
  
  =head1 ENVIRONMENT
  
  =head1 SEE ALSO
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_COMPOSITE

$fatpacked{"Log/ger/Output/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_NULL';
  package Log::ger::Output::Null;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  sub get_hooks {
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  $Log::ger::_logger_is_null = 1;
                  [sub {0}];
              }],
      };
  }
  
  1;
  # ABSTRACT: Null output
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Null - Null output
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger;
   use Log::ger::Output 'Null';
  
   log_warn "blah...";
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_NULL

$fatpacked{"Log/ger/Output/Screen.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_SCREEN';
  package Log::ger::Output::Screen;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.007'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  our %colors = (
      10 => "\e[31m"  , # fatal, red
      20 => "\e[35m"  , # error, magenta
      30 => "\e[1;34m", # warning, light blue
      40 => "\e[32m"  , # info, green
      50 => "",         # debug, no color
      60 => "\e[33m"  , # trace, orange
  );
  
  our %level_map;
  
  sub _pick_color {
      my $level = shift;
      if (defined(my $c = $colors{$level})) {
          return $c;
      }
      if (defined(my $clevel = $level_map{$level})) {
          return $colors{$clevel};
      }
  
      # find the nearest
      my ($dist, $clevel);
      for my $k (keys %colors) {
          my $d = abs($k - $level);
          if (!defined($dist) || $dist > $d) {
              $dist = $d;
              $clevel = $k;
          }
      }
      $level_map{$level} = $clevel;
      return $colors{$clevel};
  }
  
  sub hook_before_log {
      my ($ctx, $msg) = @_;
  }
  
  sub hook_after_log {
      my ($ctx, $msg) = @_;
      print { $ctx->{_fh} } "\n" unless $msg =~ /\R\z/;
  }
  
  sub get_hooks {
      my %conf = @_;
  
      my $stderr = $conf{stderr};
      $stderr = 1 unless defined $stderr;
      my $handle = $stderr ? \*STDERR : \*STDOUT;
      my $use_color = $conf{use_color};
      $use_color = $ENV{COLOR} unless defined $use_color;
      $use_color = (-t STDOUT) unless defined $use_color;
      my $formatter = $conf{formatter};
  
      return {
          # we provide two versions for testing, one using create_log_routine and
          # one using create_logml_routine. by default, create_logml_routine will
          # take precendence.
  
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $logger = sub {
                      my $level = $args{level};
                      my $msg = $_[1];
                      if ($formatter) {
                          $msg = $formatter->($msg);
                      }
                      hook_before_log({ _fh=>$handle }, $msg);
                      if ($use_color) {
                          print $handle _pick_color($level), $msg, "\e[0m";
                      } else {
                          print $handle $msg;
                      }
                      hook_after_log({ _fh=>$handle }, $msg);
                  };
                  [$logger];
              }],
          create_logml_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $logger = sub {
                      my $level = Log::ger::Util::numeric_level($_[1]);
                      return if $level > $Log::ger::Current_Level;
                      my $msg = $_[2];
                      if ($formatter) {
                          $msg = $formatter->($msg);
                      }
                      hook_before_log({ _fh=>$handle }, $msg);
                      if ($use_color) {
                          print $handle _pick_color($level), $msg, "\e[0m";
                      } else {
                          print $handle $msg;
                      }
                      hook_after_log({ _fh=>$handle }, $msg);
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Output log to screen
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::Screen - Output log to screen
  
  =head1 VERSION
  
  version 0.007
  
  =head1 SYNOPSIS
  
   use Log::ger::Output Screen => (
       # stderr => 1,    # set to 0 to print to stdout instead of stderr
       # use_color => 0, # set to 1/0 to force usage of color, default is from COLOR or (-t STDOUT)
       # formatter => sub { ... },
   );
   use Log::ger;
  
   log_warn "blah...";
  
  =head1 DESCRIPTION
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 stderr => bool (default: 1)
  
  Whether to print to STDERR (the default) or st=head2 use_color => bool
  
  =head2 use_color => bool
  
  The default is to look at the COLOR environment variable, or 1 when in
  interactive mode and 0 when not in interactive mode.
  
  =head2 formatter => code
  
  When defined, will pass the formatted message (but being applied with colors) to
  this custom formatter.
  
  =head1 ENVIRONMENT
  
  =head2 COLOR => bool
  
  =head1 SEE ALSO
  
  Modelled after L<Log::Any::Adapter::Screen>.
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_SCREEN

$fatpacked{"Log/ger/Output/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_OUTPUT_STRING';
  package Log::ger::Output::String;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  sub get_hooks {
      my %conf = @_;
  
      $conf{string} or die "Please specify string";
  
      my $formatter = $conf{formatter};
      my $append_newline = $conf{append_newline};
      $append_newline = 1 unless defined $append_newline;
  
      return {
          create_log_routine => [
              __PACKAGE__, 50,
              sub {
                  my %args = @_;
                  my $level = $args{level};
                  my $logger = sub {
                      my $msg = $_[1];
                      if ($formatter) {
                          $msg = $formatter->($msg);
                      }
                      ${ $conf{string} } .= $msg;
                      ${ $conf{string} } .= "\n"
                          unless !$append_newline || $msg =~ /\R\z/;
                  };
                  [$logger];
              }],
      };
  }
  
  1;
  # ABSTRACT: Set output to a string
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Output::String - Set output to a string
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use var '$str';
   use Log::ger::Output 'String' => (
       string => \$str,
       # append_newline => 0, # default is true, to mimic Log::ger::Output::Screen
   );
   use Log::ger;
  
   log_warn "warn ...";
   log_error "debug ...";
  
  C<$str> will contain "warn ...\n".
  
  =head1 DESCRIPTION
  
  For testing only.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 string => scalarref
  
  Required.
  
  =head2 formatter => coderef
  
  Optional.
  
  =head2 append_newline => bool (default: 1)
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_OUTPUT_STRING

$fatpacked{"Log/ger/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN';
  package Log::ger::Plugin;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub set {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      $args{prefix} ||= $pkg . '::';
      $args{replace_package_regex} = $pkg->_replace_package_regex;
      Log::ger::Util::set_plugin(%args);
  }
  
  sub set_for_current_package {
      my $pkg = shift;
  
      my %args;
      if (ref $_[0] eq 'HASH') {
          %args = %{shift()};
      } else {
          %args = (name => shift, conf => {@_});
      }
  
      my $caller = caller(0);
      $args{target} = 'package';
      $args{target_arg} = $caller;
  
      set($pkg, \%args);
  }
  
  sub _import_sets_for_current_package { 0 }
  
  sub _replace_package_regex { undef }
  
  sub import {
      if (@_ > 1) {
          if ($_[0]->_import_sets_for_current_package) {
              goto &set_for_current_package;
          } else {
              goto &set;
          }
      }
  }
  
  1;
  # ABSTRACT: Use a plugin
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin - Use a plugin
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
  To set globally:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set('OptAway');
  
  or:
  
   use Log::ger::Plugin 'OptAway';
  
  To set for current package only:
  
   use Log::ger::Plugin;
   Log::ger::Plugin->set_for_current_package('OptAway');
  
  =for Pod::Coverage ^(.+)$
  
  =head1 SEE ALSO
  
  L<Log::ger::Format>
  
  L<Log::ger::Layout>
  
  L<Log::ger::Output>
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN

$fatpacked{"Log/ger/Plugin/MultilevelLog.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_PLUGIN_MULTILEVELLOG';
  package Log::ger::Plugin::MultilevelLog;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  use Log::ger::Util;
  
  sub get_hooks {
      my %conf = @_;
  
      return {
          create_routine_names => [
              __PACKAGE__, 50,
              sub {
                  return [{
                      logml_subs    => [[$conf{sub_name}    || 'log', undef]],
                      logml_methods => [[$conf{method_name} || 'log', undef]],
                  }];
              },
          ],
      };
  }
  
  1;
  # ABSTRACT: Create a log($LEVEL, ...) subroutine/method
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Plugin::MultilevelLog - Create a log($LEVEL, ...) subroutine/method
  
  =head1 VERSION
  
  version 0.023
  
  =head1 SYNOPSIS
  
   use Log::ger::Plugin MultilevelLog => (
       sub_name => 'log',    # optional
       method_name => 'log', # optional
   );
   use Log::ger;
  
  =head1 DESCRIPTION
  
  The default way is to create separate C<log_LEVEL> subroutine (or C<LEVEL>
  methods) for each level, e.g. C<log_trace> subroutine (or C<trace> method),
  C<log_warn> (or C<warn>), and so on. But sometimes you might want a log routine
  that takes $level as the first argument, e.g. instead of:
  
   log_warn('blah ...');
  
  or:
  
   $log->debug('Blah: %s', $data);
  
  you prefer:
  
   log('warn', 'blah ...');
  
  or:
  
   $log->log('debug', 'Blah: %s', $data);
  
  This plugin can create such log routine for you.
  
  Note: the multilevel log is slower because of extra argument and additional
  string level -> numeric level conversion.
  
  Note: the individual separate C<log_LEVEL> subroutines (or C<LEVEL> methods) are
  still installed.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 CONFIGURATION
  
  =head2 sub_name => str (default: "log")
  
  =head2 method_name => str (default: "log")
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_PLUGIN_MULTILEVELLOG

$fatpacked{"Log/ger/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_GER_UTIL';
  package Log::ger::Util;
  
  our $DATE = '2017-08-03'; # DATE
  our $VERSION = '0.023'; # VERSION
  
  use strict;
  use warnings;
  
  require Log::ger;
  require Log::ger::Heavy;
  
  sub _dump {
      unless ($Log::ger::_dumper) {
          eval {
              no warnings 'once';
              require Data::Dmp;
              $Data::Dmp::OPT_REMOVE_PRAGMAS = 1;
              1;
          };
          if ($@) {
              no warnings 'once';
              require Data::Dumper;
              $Log::ger::_dumper = sub {
                  local $Data::Dumper::Terse = 1;
                  local $Data::Dumper::Indent = 0;
                  local $Data::Dumper::Useqq = 1;
                  local $Data::Dumper::Deparse = 1;
                  local $Data::Dumper::Quotekeys = 0;
                  local $Data::Dumper::Sortkeys = 1;
                  local $Data::Dumper::Trailingcomma = 1;
                  Data::Dumper::Dumper($_[0]);
              };
          } else {
              $Log::ger::_dumper = sub { Data::Dmp::dmp($_[0]) };
          }
      }
      $Log::ger::_dumper->($_[0]);
  }
  
  sub numeric_level {
      my $level = shift;
      return $level if $level =~ /\A\d+\z/;
      return $Log::ger::Levels{$level}
          if defined $Log::ger::Levels{$level};
      return $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      die "Unknown level '$level'";
  }
  
  sub string_level {
      my $level = shift;
      return $level if defined $Log::ger::Levels{$level};
      $level = $Log::ger::Level_Aliases{$level}
          if defined $Log::ger::Level_Aliases{$level};
      for (keys %Log::ger::Levels) {
          my $v = $Log::ger::Levels{$_};
          return $_ if $v == $level;
      }
      die "Unknown level '$level'";
  }
  
  sub set_level {
      no warnings 'once';
      $Log::ger::Current_Level = numeric_level(shift);
      reinit_all_targets();
  }
  
  sub _action_on_hooks {
      no warnings 'once';
  
      my ($action, $target, $target_arg, $phase) = splice @_, 0, 4;
  
      my $hooks = $Log::ger::Global_Hooks{$phase} or die "Unknown phase '$phase'";
      if ($target eq 'package') {
          $hooks = ($Log::ger::Per_Package_Hooks{$target_arg}{$phase} ||= []);
      } elsif ($target eq 'object') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Object_Hooks{$addr}{$phase} ||= []);
      } elsif ($target eq 'hash') {
          my ($addr) = $target_arg =~ $Log::ger::re_addr;
          $hooks = ($Log::ger::Per_Hash_Hooks{$addr}{$phase} ||= []);
      }
  
      if ($action eq 'add') {
          my $hook = shift;
          # XXX remove duplicate key
          # my $key = $hook->[0];
          unshift @$hooks, $hook;
      } elsif ($action eq 'remove') {
          my $code = shift;
          for my $i (reverse 0..$#{$hooks}) {
              splice @$hooks, $i, 1 if $code->($hooks->[$i]);
          }
      } elsif ($action eq 'reset') {
          my $saved = [@$hooks];
          splice @$hooks, 0, scalar(@$hooks),
              @{ $Log::ger::Default_Hooks{$phase} };
          return $saved;
      } elsif ($action eq 'empty') {
          my $saved = [@$hooks];
          splice @$hooks, 0;
          return $saved;
      } elsif ($action eq 'save') {
          return [@$hooks];
      } elsif ($action eq 'restore') {
          my $saved = shift;
          splice @$hooks, 0, scalar(@$hooks), @$saved;
          return $saved;
      }
  }
  
  sub add_hook {
      my ($phase, $hook) = @_;
      _action_on_hooks('add', '', undef, $phase, $hook);
  }
  
  sub add_per_target_hook {
      my ($target, $target_arg, $phase, $hook) = @_;
      _action_on_hooks('add', $target, $target_arg, $phase, $hook);
  }
  
  sub remove_hook {
      my ($phase, $code) = @_;
      _action_on_hooks('remove', '', undef, $phase, $code);
  }
  
  sub remove_per_target_hook {
      my ($target, $target_arg, $phase, $code) = @_;
      _action_on_hooks('remove', $target, $target_arg, $phase, $code);
  }
  
  sub reset_hooks {
      my ($phase) = @_;
      _action_on_hooks('reset', '', undef, $phase);
  }
  
  sub reset_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('reset', $target, $target_arg, $phase);
  }
  
  sub empty_hooks {
      my ($phase) = @_;
      _action_on_hooks('empty', '', undef, $phase);
  }
  
  sub empty_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('empty', $target, $target_arg, $phase);
  }
  
  sub save_hooks {
      my ($phase) = @_;
      _action_on_hooks('save', '', undef, $phase);
  }
  
  sub save_per_target_hooks {
      my ($target, $target_arg, $phase) = @_;
      _action_on_hooks('save', $target, $target_arg, $phase);
  }
  
  sub restore_hooks {
      my ($phase, $saved) = @_;
      _action_on_hooks('restore', '', undef, $phase, $saved);
  }
  
  sub restore_per_target_hooks {
      my ($target, $target_arg, $phase, $saved) = @_;
      _action_on_hooks('restore', $target, $target_arg, $phase, $saved);
  }
  
  sub reinit_target {
      my ($target, $target_arg) = @_;
  
      # adds target if not already exists
      Log::ger::add_target($target, $target_arg, {}, 0);
  
      if ($target eq 'package') {
          my $init_args = $Log::ger::Package_Targets{$target_arg};
          Log::ger::init_target(package => $target_arg, $init_args);
      } elsif ($target eq 'object') {
          my ($obj_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid object '$target_arg': not a reference";
          my $v = $Log::ger::Object_Targets{$obj_addr}
              or die "Unknown object target '$target_arg'";
          Log::ger::init_target(object => $v->[0], $v->[1]);
      } elsif ($target eq 'hash') {
          my ($hash_addr) = $target_arg =~ $Log::ger::re_addr
              or die "Invalid hashref '$target_arg': not a reference";
          my $v = $Log::ger::Hash_Targets{$hash_addr}
              or die "Unknown hash target '$target_arg'";
          Log::ger::init_target(hash => $v->[0], $v->[1]);
      } else {
          die "Unknown target '$target'";
      }
  }
  
  sub reinit_all_targets {
      for my $pkg (keys %Log::ger::Package_Targets) {
          Log::ger::init_target(
              package => $pkg, $Log::ger::Package_Targets{$pkg});
      }
      for my $k (keys %Log::ger::Object_Targets) {
          my ($obj, $init_args) = @{ $Log::ger::Object_Targets{$k} };
          Log::ger::init_target(object => $obj, $init_args);
      }
      for my $k (keys %Log::ger::Hash_Targets) {
          my ($hash, $init_args) = @{ $Log::ger::Hash_Targets{$k} };
          Log::ger::init_target(hash => $hash, $init_args);
      }
  }
  
  sub set_plugin {
      my %args = @_;
  
      my $hooks;
      if ($args{hooks}) {
          $hooks = $args{hooks};
      } else {
          no strict 'refs';
          my $prefix = $args{prefix} || 'Log::ger::Plugin::';
          my $mod = $args{name};
          $mod = $prefix . $mod unless index($mod, $prefix) == 0;
          (my $mod_pm = "$mod.pm") =~ s!::!/!g;
          require $mod_pm;
          $hooks = &{"$mod\::get_hooks"}(%{ $args{conf} || {} });
      }
  
      {
          last unless $args{replace_package_regex};
          my $all_hooks;
          if (!$args{target}) {
              $all_hooks = \%Log::ger::Global_Hooks;
          } elsif ($args{target} eq 'package') {
              $all_hooks = $Log::ger::Per_Package_Hooks{ $args{target_arg} };
          } elsif ($args{target} eq 'object') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Object_Hooks{$addr};
          } elsif ($args{target} eq 'hash') {
              my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
              $all_hooks = $Log::ger::Per_Hash_Hooks{$addr};
          }
          last unless $all_hooks;
          for my $phase (keys %$all_hooks) {
              my $hooks = $all_hooks->{$phase};
              for my $i (reverse 0..$#{$hooks}) {
                  splice @$hooks, $i, 1
                      if $hooks->[$i][0] =~ $args{replace_package_regex};
              }
          }
      }
  
      for my $phase (keys %$hooks) {
          my $hook = $hooks->{$phase};
          if (defined $args{target}) {
              add_per_target_hook(
                  $args{target}, $args{target_arg}, $phase, $hook);
          } else {
              add_hook($phase, $hook);
          }
      }
  
      my $reinit = $args{reinit};
      $reinit = 1 unless defined $reinit;
      if ($reinit) {
          if (defined $args{target}) {
              reinit_target($args{target}, $args{target_arg});
          } else {
              reinit_all_targets();
          }
      }
  }
  
  1;
  # ABSTRACT: Utility routines for Log::ger
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Log::ger::Util - Utility routines for Log::ger
  
  =head1 VERSION
  
  version 0.023
  
  =head1 DESCRIPTION
  
  This package is created to keep Log::ger as minimalist as possible.
  
  =for Pod::Coverage ^(.+)$
  
  =head1 AUTHOR
  
  perlancar <perlancar@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2017 by perlancar@cpan.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
LOG_GER_UTIL

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  
  our $VERSION = '0.104';
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 0.86 ();          # shipped with 5.8.1
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  # FREEZE/THAW per Sereal/CBOR/Types::Serialiser protocol
  sub FREEZE { return $_[0]->[PATH] }
  sub THAW   { return path( $_[2] ) }
  { no warnings 'once'; *TO_JSON = *FREEZE };
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      !!eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_PU; # has PerlIO::utf8_strict; lazily populated
  
  sub _check_PU {
      !!eval { require PerlIO::utf8_strict; PerlIO::utf8_strict->VERSION(0.003); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  BEGIN {
      *_same = IS_WIN32() ? sub { lc( $_[0] ) eq lc( $_[1] ) } : sub { $_[0] eq $_[1] };
  }
  
  # mode bits encoded for chmod in symbolic mode
  my %MODEBITS = ( om => 0007, gm => 0070, um => 0700 ); ## no critic
  { my $m = 0; $MODEBITS{$_} = ( 1 << $m++ ) for qw/ox ow or gx gw gr ux uw ur/ };
  
  sub _symbolic_chmod {
      my ( $mode, $symbolic ) = @_;
      for my $clause ( split /,\s*/, $symbolic ) {
          if ( $clause =~ m{\A([augo]+)([=+-])([rwx]+)\z} ) {
              my ( $who, $action, $perms ) = ( $1, $2, $3 );
              $who =~ s/a/ugo/g;
              for my $w ( split //, $who ) {
                  my $p = 0;
                  $p |= $MODEBITS{"$w$_"} for split //, $perms;
                  if ( $action eq '=' ) {
                      $mode = ( $mode & ~$MODEBITS{"${w}m"} ) | $p;
                  }
                  else {
                      $mode = $action eq "+" ? ( $mode | $p ) : ( $mode & ~$p );
                  }
              }
          }
          else {
              Carp::croak("Invalid mode clause '$clause' for chmod()");
          }
      }
      return $mode;
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file, $msg ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          $msg = $! unless defined $msg;
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ),
              $msg );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  #pod =construct path
  #pod
  #pod     $path = path("foo/bar");
  #pod     $path = path("/tmp", "file.txt"); # list
  #pod     $path = path(".");                # cwd
  #pod     $path = path("~user/file.txt");   # tilde processing
  #pod
  #pod Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  #pod directory path.  It's still up to you to call directory-like methods only on
  #pod directories and file-like methods only on files.  This function is exported
  #pod automatically by default.
  #pod
  #pod The first argument must be defined and have non-zero length or an exception
  #pod will be thrown.  This prevents subtle, dangerous errors with code like
  #pod C<< path( maybe_undef() )->remove_tree >>.
  #pod
  #pod If the first component of the path is a tilde ('~') then the component will be
  #pod replaced with the output of C<glob('~')>.  If the first component of the path
  #pod is a tilde followed by a user name then the component will be replaced with
  #pod output of C<glob('~username')>.  Behaviour for non-existent users depends on
  #pod the output of C<glob> on the system.
  #pod
  #pod On Windows, if the path consists of a drive identifier without a path component
  #pod (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  #pod directory on that volume using C<Cwd::getdcwd()>.
  #pod
  #pod If called with a single C<Path::Tiny> argument, the original is returned unless
  #pod the original is holding a temporary file or directory reference in which case a
  #pod stringified copy is made.
  #pod
  #pod     $path = path("foo/bar");
  #pod     $temp = Path::Tiny->tempfile;
  #pod
  #pod     $p2 = path($path); # like $p2 = $path
  #pod     $t2 = path($temp); # like $t2 = path( "$temp" )
  #pod
  #pod This optimizes copies without proliferating references unexpectedly if a copy is
  #pod made by code outside your control.
  #pod
  #pod Current API available since 0.017.
  #pod
  #pod =cut
  
  sub path {
      my $path = shift;
      Carp::croak("Path::Tiny paths require defined, positive-length parts")
        unless 1 + @_ == grep { defined && length } $path, @_;
  
      # non-temp Path::Tiny objects are effectively immutable and can be reused
      if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
          return $path;
      }
  
      # stringify objects
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenations stringifies objects, too
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize, but with unix slashes and put back trailing volume slash
      my $cpath = $path = File::Spec->canonpath($path);
      $path =~ tr[\\][/] if IS_WIN32();
      $path = "/" if $path eq '/..'; # for old File::Spec
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$};
  
      # root paths must always have a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          require File::Glob;
          my ($homedir) = File::Glob::bsd_glob($1);
          $homedir =~ tr[\\][/] if IS_WIN32();
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  #pod =construct new
  #pod
  #pod     $path = Path::Tiny->new("foo/bar");
  #pod
  #pod This is just like C<path>, but with method call overhead.  (Why would you
  #pod do that?)
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub new { shift; path(@_) }
  
  #pod =construct cwd
  #pod
  #pod     $path = Path::Tiny->cwd; # path( Cwd::getcwd )
  #pod     $path = cwd; # optional export
  #pod
  #pod Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  #pod This is slightly faster than C<< path(".")->absolute >>.
  #pod
  #pod C<cwd> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  #pod =construct rootdir
  #pod
  #pod     $path = Path::Tiny->rootdir; # /
  #pod     $path = rootdir;             # optional export 
  #pod
  #pod Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  #pod picky for C<path("/")>.
  #pod
  #pod C<rootdir> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  #pod =construct tempfile, tempdir
  #pod
  #pod     $temp = Path::Tiny->tempfile( @options );
  #pod     $temp = Path::Tiny->tempdir( @options );
  #pod     $temp = tempfile( @options ); # optional export
  #pod     $temp = tempdir( @options );  # optional export
  #pod
  #pod C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  #pod object with the file name.  The C<TMPDIR> option is enabled by default.
  #pod
  #pod The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  #pod destroyed, the C<File::Temp> object will be as well.
  #pod
  #pod C<File::Temp> annoyingly requires you to specify a custom template in slightly
  #pod different ways depending on which function or method you call, but
  #pod C<Path::Tiny> lets you ignore that and can take either a leading template or a
  #pod C<TEMPLATE> option and does the right thing.
  #pod
  #pod     $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
  #pod     $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  #pod
  #pod The tempfile path object will be normalized to have an absolute path, even if
  #pod created in a relative directory using C<DIR>.  If you want it to have
  #pod the C<realpath> instead, pass a leading options hash like this:
  #pod
  #pod     $real_temp = tempfile({realpath => 1}, @options);
  #pod
  #pod C<tempdir> is just like C<tempfile>, except it calls
  #pod C<< File::Temp->newdir >> instead.
  #pod
  #pod Both C<tempfile> and C<tempdir> may be exported on request and used as
  #pod functions instead of as methods.
  #pod
  #pod B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  #pod reused.  This is not as secure as using File::Temp handles directly, but is
  #pod less prone to deadlocks or access problems on some platforms.  Think of what
  #pod C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  #pod up.
  #pod
  #pod B<Note 2>: if you don't want these cleaned up automatically when the object
  #pod is destroyed, File::Temp requires different options for directories and
  #pod files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  #pod files.
  #pod
  #pod B<Note 3>: Don't lose the temporary object by chaining a method call instead
  #pod of storing it:
  #pod
  #pod     my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  #pod
  #pod B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  #pod Keeping a reference to, or modifying the cached object may break the
  #pod behavior documented above and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.097.
  #pod
  #pod =cut
  
  sub tempfile {
      shift if @_ && $_[0] eq 'Path::Tiny'; # called as method
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );
  
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if @_ && $_[0] eq 'Path::Tiny'; # called as method
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );
  
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      # Some ActiveState Perls for Windows break Cwd in ways that lead
      # File::Temp to get confused about what path to remove; this
      # monkey-patches the object with our own view of the absolute path
      $temp->{REALNAME} = $self->[CANON] if IS_WIN32;
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  sub _resolve_symlinks {
      my ($self) = @_;
      my $new = $self;
      my ( $count, %seen ) = 0;
      while ( -l $new->[PATH] ) {
          if ( $seen{ $new->[PATH] }++ ) {
              $self->_throw( 'readlink', $self->[PATH], "symlink loop detected" );
          }
          if ( ++$count > 100 ) {
              $self->_throw( 'readlink', $self->[PATH], "maximum symlink depth exceeded" );
          }
          my $resolved = readlink $new->[PATH] or $new->_throw( 'readlink', $new->[PATH] );
          $resolved = path($resolved);
          $new = $resolved->is_absolute ? $resolved : $new->sibling($resolved);
      }
      return $new;
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  #pod =method absolute
  #pod
  #pod     $abs = path("foo/bar")->absolute;
  #pod     $abs = path("foo/bar")->absolute("/tmp");
  #pod
  #pod Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  #pod absolute).  If no argument is given, the current directory is used as the
  #pod absolute base path.  If an argument is given, it will be converted to an
  #pod absolute path (if it is not already) and used as the absolute base path.
  #pod
  #pod This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  #pod in L<File::Spec> would normally do so on your platform.  If you need them
  #pod resolved, you must call the more expensive C<realpath> method instead.
  #pod
  #pod On Windows, an absolute path without a volume component will have it added
  #pod based on the current drive.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # no base means use current directory as base
      require Cwd;
      return path( Cwd::getcwd(), $_[0]->[PATH] ) unless defined $base;
  
      # relative base should be made absolute; we check is_absolute rather
      # than unconditionally make base absolute so that "/foo" doesn't become
      # "C:/foo" on Windows.
      $base = path($base);
      return path( ( $base->is_absolute ? $base : $base->absolute ), $_[0]->[PATH] );
  }
  
  #pod =method append, append_raw, append_utf8
  #pod
  #pod     path("foo.txt")->append(@data);
  #pod     path("foo.txt")->append(\@data);
  #pod     path("foo.txt")->append({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->append_raw(@data);
  #pod     path("foo.txt")->append_utf8(@data);
  #pod
  #pod Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  #pod optional hash reference may be used to pass options.  Valid options are:
  #pod
  #pod =for :list
  #pod * C<binmode>: passed to C<binmode()> on the handle used for writing.
  #pod * C<truncate>: truncates the file after locking and before appending
  #pod
  #pod The C<truncate> option is a way to replace the contents of a file
  #pod B<in place>, unlike L</spew> which writes to a temporary file and then
  #pod replaces the original (if it exists).
  #pod
  #pod C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<append_utf8> is like C<append> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw append will be done instead on the data encoded
  #pod with C<Unicode::UTF8>.
  #pod
  #pod Current API available since 0.060.
  #pod
  #pod =cut
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $mode = $args->{truncate} ? ">" : ">>";
      my $fh = $self->filehandle( { locked => 1 }, $mode, $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      $args->{binmode} = ':unix';
      append( $self, $args, @data );
  }
  
  sub append_utf8 {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          $args->{binmode} = ":unix";
          append( $self, $args, map { Unicode::UTF8::encode_utf8($_) } @data );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          append( $self, $args, @data );
      }
      else {
          $args->{binmode} = ":unix:encoding(UTF-8)";
          append( $self, $args, @data );
      }
  }
  
  #pod =method assert
  #pod
  #pod     $path = path("foo.txt")->assert( sub { $_->exists } );
  #pod
  #pod Returns the invocant after asserting that a code reference argument returns
  #pod true.  When the assertion code reference runs, it will have the invocant
  #pod object in the C<$_> variable.  If it returns false, an exception will be
  #pod thrown.  The assertion code reference may also throw its own exception.
  #pod
  #pod If no assertion is provided, the invocant is returned without error.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub assert {
      my ( $self, $assertion ) = @_;
      return $self unless $assertion;
      if ( ref $assertion eq 'CODE' ) {
          local $_ = $self;
          $assertion->()
            or Path::Tiny::Error->throw( "assert", $self->[PATH], "failed assertion" );
      }
      else {
          Carp::croak("argument to assert must be a code reference argument");
      }
      return $self;
  }
  
  #pod =method basename
  #pod
  #pod     $name = path("foo/bar.txt")->basename;        # bar.txt
  #pod     $name = path("foo.txt")->basename('.txt');    # foo
  #pod     $name = path("foo.txt")->basename(qr/.txt/);  # foo
  #pod     $name = path("foo.txt")->basename(@suffixes);
  #pod
  #pod Returns the file portion or last directory portion of a path.
  #pod
  #pod Given a list of suffixes as strings or regular expressions, any that match at
  #pod the end of the file portion or last directory portion will be removed before
  #pod the result is returned.
  #pod
  #pod Current API available since 0.054.
  #pod
  #pod =cut
  
  sub basename {
      my ( $self, @suffixes ) = @_;
      $self->_splitpath unless defined $self->[FILE];
      my $file = $self->[FILE];
      for my $s (@suffixes) {
          my $re = ref($s) eq 'Regexp' ? qr/$s$/ : qr/\Q$s\E$/;
          last if $file =~ s/$re//;
      }
      return $file;
  }
  
  #pod =method canonpath
  #pod
  #pod     $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  #pod
  #pod Returns a string with the canonical format of the path name for
  #pod the platform.  In particular, this means directory separators
  #pod will be C<\> on Windows.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub canonpath { $_[0]->[CANON] }
  
  #pod =method cached_temp
  #pod
  #pod Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  #pod C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  #pod If there is no such object, this method throws.
  #pod
  #pod B<WARNING>: Keeping a reference to, or modifying the cached object may
  #pod break the behavior documented for temporary files and directories created
  #pod with C<Path::Tiny> and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub cached_temp {
      my $self = shift;
      $self->_throw( "cached_temp", $self, "has no cached File::Temp object" )
        unless defined $self->[TEMP];
      return $self->[TEMP];
  }
  
  #pod =method child
  #pod
  #pod     $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
  #pod     $file = path("/tmp")->child(@parts);
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the original.  Works
  #pod like C<catfile> or C<catdir> from File::Spec, but without caring about
  #pod file or directories.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  #pod =method children
  #pod
  #pod     @paths = path("/tmp")->children;
  #pod     @paths = path("/tmp")->children( qr/\.txt$/ );
  #pod
  #pod Returns a list of C<Path::Tiny> objects for all files and directories
  #pod within a directory.  Excludes "." and ".." automatically.
  #pod
  #pod If an optional C<qr//> argument is provided, it only returns objects for child
  #pod names that match the given regular expression.  Only the base name is used
  #pod for matching:
  #pod
  #pod     @paths = path("/tmp")->children( qr/^foo/ );
  #pod     # matches children like the glob foo*
  #pod
  #pod Current API available since 0.028.
  #pod
  #pod =cut
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  #pod =method chmod
  #pod
  #pod     path("foo.txt")->chmod(0777);
  #pod     path("foo.txt")->chmod("0755");
  #pod     path("foo.txt")->chmod("go-w");
  #pod     path("foo.txt")->chmod("a=r,u+wx");
  #pod
  #pod Sets file or directory permissions.  The argument can be a numeric mode, a
  #pod octal string beginning with a "0" or a limited subset of the symbolic mode use
  #pod by F</bin/chmod>.
  #pod
  #pod The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  #pod match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  #pod "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  #pod are required for each clause, multiple ops are not allowed and permissions
  #pod C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub chmod {
      my ( $self, $new_mode ) = @_;
  
      my $mode;
      if ( $new_mode =~ /\d/ ) {
          $mode = ( $new_mode =~ /^0/ ? oct($new_mode) : $new_mode );
      }
      elsif ( $new_mode =~ /[=+-]/ ) {
          $mode = _symbolic_chmod( $self->stat->mode & 07777, $new_mode ); ## no critic
      }
      else {
          Carp::croak("Invalid mode argument '$new_mode' for chmod()");
      }
  
      CORE::chmod( $mode, $self->[PATH] ) or $self->_throw("chmod");
  
      return 1;
  }
  
  #pod =method copy
  #pod
  #pod     path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  #pod
  #pod Copies the current path to the given destination using L<File::Copy>'s
  #pod C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  #pod newly copied file.
  #pod
  #pod Current API available since 0.070.
  #pod
  #pod =cut
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  
      return -d $dest ? path( $dest, $self->basename ) : path($dest);
  }
  
  #pod =method digest
  #pod
  #pod     $obj = path("/tmp/foo.txt")->digest;        # SHA-256
  #pod     $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  #pod     $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  #pod
  #pod Returns a hexadecimal digest for a file.  An optional hash reference of options may
  #pod be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  #pod bytes will be read at a time.  If not provided, the entire file will be slurped
  #pod into memory to compute the digest.
  #pod
  #pod Any subsequent arguments are passed to the constructor for L<Digest> to select
  #pod an algorithm.  If no arguments are given, the default is SHA-256.
  #pod
  #pod Current API available since 0.056.
  #pod
  #pod =cut
  
  sub digest {
      my ( $self, @opts ) = @_;
      my $args = ( @opts && ref $opts[0] eq 'HASH' ) ? shift @opts : {};
      $args = _get_args( $args, qw/chunk_size/ );
      unshift @opts, 'SHA-256' unless @opts;
      require Digest;
      my $digest = Digest->new(@opts);
      if ( $args->{chunk_size} ) {
          my $fh = $self->filehandle( { locked => 1 }, "<", ":unix" );
          my $buf;
          $digest->add($buf) while read $fh, $buf, $args->{chunk_size};
      }
      else {
          $digest->add( $self->slurp_raw );
      }
      return $digest->hexdigest;
  }
  
  #pod =method dirname (deprecated)
  #pod
  #pod     $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  #pod
  #pod Returns the directory portion you would get from calling
  #pod C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  #pod parent directory portion.  Because L<File::Spec> is inconsistent, the result
  #pod might or might not have a trailing slash.  Because of this, this method is
  #pod B<deprecated>.
  #pod
  #pod A better, more consistently approach is likely C<< $path->parent->stringify >>,
  #pod which will not have a trailing slash except for a root directory.
  #pod
  #pod Deprecated in 0.056.
  #pod
  #pod =cut
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  #pod =method edit, edit_raw, edit_utf8
  #pod
  #pod     path("foo.txt")->edit( \&callback, $options );
  #pod     path("foo.txt")->edit_utf8( \&callback );
  #pod     path("foo.txt")->edit_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file using a single
  #pod callback argument. They slurp the file using C<slurp>, place the contents
  #pod inside a localized C<$_> variable, call the callback function (without
  #pod arguments), and then write C<$_> (presumably mutated) back to the
  #pod file with C<spew>.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to C<slurp> and C<spew>.
  #pod
  #pod C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  #pod C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ =
        $self->slurp( exists( $args->{binmode} ) ? { binmode => $args->{binmode} } : () );
      $cb->();
      $self->spew( $args, $_ );
  
      return;
  }
  
  # this is done long-hand to benefit from slurp_utf8 optimizations
  sub edit_utf8 {
      my ( $self, $cb ) = @_;
      Carp::croak("Callback for edit_utf8() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ = $self->slurp_utf8;
      $cb->();
      $self->spew_utf8($_);
  
      return;
  }
  
  sub edit_raw { $_[2] = { binmode => ":unix" }; goto &edit }
  
  #pod =method edit_lines, edit_lines_utf8, edit_lines_raw
  #pod
  #pod     path("foo.txt")->edit_lines( \&callback, $options );
  #pod     path("foo.txt")->edit_lines_utf8( \&callback );
  #pod     path("foo.txt")->edit_lines_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file's lines using a
  #pod single callback argument.  They iterate over the file: for each line, the
  #pod line is put into a localized C<$_> variable, the callback function is
  #pod executed (without arguments) and then C<$_> is written to a temporary file.
  #pod When iteration is finished, the temporary file is atomically renamed over
  #pod the original.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to the method that open handles for reading and
  #pod writing.
  #pod
  #pod C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  #pod C<slurp_*> and C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit_lines {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit_lines() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # writing need to follow the link and create the tempfile in the same
      # dir for later atomic rename
      my $resolved_path = $self->_resolve_symlinks;
      my $temp          = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
  
      my $temp_fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      my $in_fh = $self->filehandle( { locked => 1 }, '<', $binmode );
  
      local $_;
      while (<$in_fh>) {
          $cb->();
          $temp_fh->print($_);
      }
  
      close $temp_fh or $self->_throw( 'close', $temp );
      close $in_fh or $self->_throw('close');
  
      return $temp->move($resolved_path);
  }
  
  sub edit_lines_raw { $_[2] = { binmode => ":unix" }; goto &edit_lines }
  
  sub edit_lines_utf8 {
      $_[2] = { binmode => ":raw:encoding(UTF-8)" };
      goto &edit_lines;
  }
  
  #pod =method exists, is_file, is_dir
  #pod
  #pod     if ( path("/tmp")->exists ) { ... }     # -e
  #pod     if ( path("/tmp")->is_dir ) { ... }     # -d
  #pod     if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  #pod
  #pod Implements file test operations, this means the file or directory actually has
  #pod to exist on the filesystem.  Until then, it's just a path.
  #pod
  #pod B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  #pod C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  #pod read just like files.
  #pod
  #pod Use C<-f> instead if you really mean to check for a plain file.
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -e $_[0]->[PATH] && !-d _ }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  #pod =method filehandle
  #pod
  #pod     $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  #pod
  #pod Returns an open file handle.  The C<$mode> argument must be a Perl-style
  #pod read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  #pod is given, it is set during the C<open> call.
  #pod
  #pod An optional hash reference may be used to pass options.
  #pod
  #pod The C<locked> option governs file locking; if true, handles opened for writing,
  #pod appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  #pod locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  #pod truncation until after the lock is acquired.
  #pod
  #pod The C<exclusive> option causes the open() call to fail if the file already
  #pod exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  #pod C<exclusive> implies C<locked> and will set it for you if you forget it.
  #pod
  #pod See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  #pod
  #pod Current API available since 0.066.
  #pod
  #pod =cut
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked exclusive/ );
      $args->{locked} = 1 if $args->{exclusive};
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              $flags |= Fcntl::O_EXCL() if $args->{exclusive};
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX if
              # the file is writable; otherwise give up on locking.  N.B.
              # checking -w before open to determine the open mode is an
              # unavoidable race condition
              if ( -w $self->[PATH] ) {
                  $opentype = "+<";
                  $lock     = Fcntl::LOCK_EX();
              }
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  #pod =method is_absolute, is_relative
  #pod
  #pod     if ( path("/tmp")->is_absolute ) { ... }
  #pod     if ( path("/tmp")->is_relative ) { ... }
  #pod
  #pod Booleans for whether the path appears absolute or relative.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  #pod =method is_rootdir
  #pod
  #pod     while ( ! $path->is_rootdir ) {
  #pod         $path = $path->parent;
  #pod         ...
  #pod     }
  #pod
  #pod Boolean for whether the path is the root directory of the volume.  I.e. the
  #pod C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  #pod
  #pod This works even on C<MSWin32> with drives and UNC volumes:
  #pod
  #pod     path("C:/")->is_rootdir;             # true
  #pod     path("//server/share/")->is_rootdir; #true
  #pod
  #pod Current API available since 0.038.
  #pod
  #pod =cut
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  #pod =method iterator
  #pod
  #pod     $iter = path("/tmp")->iterator( \%options );
  #pod
  #pod Returns a code reference that walks a directory lazily.  Each invocation
  #pod returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  #pod
  #pod     $iter = path("/tmp")->iterator;
  #pod     while ( $path = $iter->() ) {
  #pod         ...
  #pod     }
  #pod
  #pod The current and parent directory entries ("." and "..") will not
  #pod be included.
  #pod
  #pod If the C<recurse> option is true, the iterator will walk the directory
  #pod recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  #pod directory links will be followed recursively.  There is no protection against
  #pod loops when following links. If a directory is not readable, it will not be
  #pod followed.
  #pod
  #pod The default is the same as:
  #pod
  #pod     $iter = path("/tmp")->iterator( {
  #pod         recurse         => 0,
  #pod         follow_symlinks => 0,
  #pod     } );
  #pod
  #pod For a more powerful, recursive iterator with built-in loop avoidance, see
  #pod L<Path::Iterator::Rule>.
  #pod
  #pod See also L</visit>.
  #pod
  #pod Current API available since 0.016.
  #pod
  #pod =cut
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  #pod =method lines, lines_raw, lines_utf8
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines;
  #pod     @contents = path("/tmp/foo.txt")->lines(\%options);
  #pod     @contents = path("/tmp/foo.txt")->lines_raw;
  #pod     @contents = path("/tmp/foo.txt")->lines_utf8;
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  #pod
  #pod Returns a list of lines from a file.  Optionally takes a hash-reference of
  #pod options.  Valid options are C<binmode>, C<count> and C<chomp>.
  #pod
  #pod If C<binmode> is provided, it will be set on the handle prior to reading.
  #pod
  #pod If a positive C<count> is provided, that many lines will be returned from the
  #pod start of the file.  If a negative C<count> is provided, the entire file will be
  #pod read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  #pod exceeds the number of lines in the file, all lines will be returned.
  #pod
  #pod If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  #pod C<LF>) will be removed from the lines returned.
  #pod
  #pod Because the return is a list, C<lines> in scalar context will return the number
  #pod of lines (and throw away the data).
  #pod
  #pod     $number_of_lines = path("/tmp/foo.txt")->lines;
  #pod
  #pod C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  #pod instead of C<:unix> so PerlIO buffering can manage reading by line.
  #pod
  #pod C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod UTF-8 slurp will be done and then the lines will be split.  This is
  #pod actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  #pod intensive.  If memory use is a concern, consider C<openr_utf8> and
  #pod iterating directly on the handle.
  #pod
  #pod Current API available since 0.065.
  #pod
  #pod =cut
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( $counter, $mod, @result ) = ( 0, abs( $args->{count} ) );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              $result[ $counter++ ] = $line;
              # for positive count, terminate after right number of lines
              last if $counter == $args->{count};
              # for negative count, eventually wrap around in the result array
              $counter %= $mod;
          }
          # reorder results if full and wrapped somewhere in the middle
          splice( @result, 0, 0, splice( @result, $counter ) )
            if @result == $mod && $counter % $mod;
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  my $CRLF = qr/(?:\x{0d}?\x{0a}|\x{0d})/;
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) )
          && $args->{chomp}
          && !$args->{count} )
      {
          my $slurp = slurp_utf8($self);
          $slurp =~ s/$CRLF$//; # like chomp, but full CR?LF|CR
          return split $CRLF, $slurp, -1; ## no critic
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          return lines( $self, $args );
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  #pod =method mkpath
  #pod
  #pod     path("foo/bar/baz")->mkpath;
  #pod     path("foo/bar/baz")->mkpath( \%options );
  #pod
  #pod Like calling C<make_path> from L<File::Path>.  An optional hash reference
  #pod is passed through to C<make_path>.  Errors will be trapped and an exception
  #pod thrown.  Returns the list of directories created or an empty list if
  #pod the directories already exist, just like C<make_path>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  #pod =method move
  #pod
  #pod     path("foo.txt")->move("bar.txt");
  #pod
  #pod Move the current path to the given destination path using Perl's
  #pod built-in L<rename|perlfunc/rename> function. Returns the result
  #pod of the C<rename> function.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst" );
  }
  
  #pod =method openr, openw, openrw, opena
  #pod
  #pod     $fh = path("foo.txt")->openr($binmode);  # read
  #pod     $fh = path("foo.txt")->openr_raw;
  #pod     $fh = path("foo.txt")->openr_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openw($binmode);  # write
  #pod     $fh = path("foo.txt")->openw_raw;
  #pod     $fh = path("foo.txt")->openw_utf8;
  #pod
  #pod     $fh = path("foo.txt")->opena($binmode);  # append
  #pod     $fh = path("foo.txt")->opena_raw;
  #pod     $fh = path("foo.txt")->opena_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openrw($binmode); # read/write
  #pod     $fh = path("foo.txt")->openrw_raw;
  #pod     $fh = path("foo.txt")->openrw_utf8;
  #pod
  #pod Returns a file handle opened in the specified mode.  The C<openr> style methods
  #pod take a single C<binmode> argument.  All of the C<open*> methods have
  #pod C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  #pod C<:raw:encoding(UTF-8)>, respectively.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<locked>.  If true, handles opened for writing, appending or read-write are
  #pod locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  #pod
  #pod     $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  #pod
  #pod See L</filehandle> for more on locking.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  #pod =method parent
  #pod
  #pod     $parent = path("foo/bar/baz")->parent; # foo/bar
  #pod     $parent = path("foo/wibble.txt")->parent; # foo
  #pod
  #pod     $parent = path("foo/bar/baz")->parent(2); # foo
  #pod
  #pod Returns a C<Path::Tiny> object corresponding to the parent directory of the
  #pod original directory or file. An optional positive integer argument is the number
  #pod of parent directories upwards to return.  C<parent> by itself is equivalent to
  #pod C<parent(1)>.
  #pod
  #pod Current API available since 0.014.
  #pod
  #pod =cut
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  #pod =method realpath
  #pod
  #pod     $real = path("/baz/foo/../bar")->realpath;
  #pod     $real = path("foo/../bar")->realpath;
  #pod
  #pod Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  #pod parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  #pod more expensive as it must actually consult the filesystem.
  #pod
  #pod If the parent path can't be resolved (e.g. if it includes directories that
  #pod don't exist), an exception will be thrown:
  #pod
  #pod     $real = path("doesnt_exist/foo")->realpath; # dies
  #pod
  #pod However, if the parent path exists and only the last component (e.g. filename)
  #pod doesn't exist, the realpath will be the realpath of the parent plus the
  #pod non-existent last component:
  #pod
  #pod     $real = path("./aasdlfasdlf")->realpath; # works
  #pod
  #pod The underlying L<Cwd> module usually worked this way on Unix, but died on
  #pod Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  #pod it's safe to use anywhere.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # Win32 and some Unixes need parent path resolved separately so realpath
  # doesn't throw an error resolving non-existent basename
  sub realpath {
      my $self = shift;
      $self = $self->_resolve_symlinks;
      require Cwd;
      $self->_splitpath if !defined $self->[FILE];
      my $check_parent =
        length $self->[FILE] && $self->[FILE] ne '.' && $self->[FILE] ne '..';
      my $realpath = eval {
          # pure-perl Cwd can carp
          local $SIG{__WARN__} = sub { };
          Cwd::realpath( $check_parent ? $self->parent->[PATH] : $self->[PATH] );
      };
      # parent realpath must exist; not all Cwd::realpath will error if it doesn't
      $self->_throw("resolving realpath")
        unless defined $realpath && length $realpath && -e $realpath;
      return ( $check_parent ? path( $realpath, $self->[FILE] ) : path($realpath) );
  }
  
  #pod =method relative
  #pod
  #pod     $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  #pod
  #pod Returns a C<Path::Tiny> object with a path relative to a new base path
  #pod given as an argument.  If no argument is given, the current directory will
  #pod be used as the new base path.
  #pod
  #pod If either path is already relative, it will be made absolute based on the
  #pod current directly before determining the new relative path.
  #pod
  #pod The algorithm is roughly as follows:
  #pod
  #pod =for :list
  #pod * If the original and new base path are on different volumes, an exception
  #pod   will be thrown.
  #pod * If the original and new base are identical, the relative path is C<".">.
  #pod * If the new base subsumes the original, the relative path is the original
  #pod   path with the new base chopped off the front
  #pod * If the new base does not subsume the original, a common prefix path is
  #pod   determined (possibly the root directory) and the relative path will
  #pod   consist of updirs (C<"..">) to reach the common prefix, followed by the
  #pod   original path less the common prefix.
  #pod
  #pod Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  #pod on a common prefix takes into account symlinks that could affect the updir
  #pod process.  Given an original path "/A/B" and a new base "/A/C",
  #pod (where "A", "B" and "C" could each have multiple path components):
  #pod
  #pod =for :list
  #pod * Symlinks in "A" don't change the result unless the last component of A is
  #pod   a symlink and the first component of "C" is an updir.
  #pod * Symlinks in "B" don't change the result and will exist in the result as
  #pod   given.
  #pod * Symlinks and updirs in "C" must be resolved to actual paths, taking into
  #pod   account the possibility that not all path components might exist on the
  #pod   filesystem.
  #pod
  #pod Current API available since 0.001.  New algorithm (that accounts for
  #pod symlinks) available since 0.079.
  #pod
  #pod =cut
  
  sub relative {
      my ( $self, $base ) = @_;
      $base = path( defined $base && length $base ? $base : '.' );
  
      # relative paths must be converted to absolute first
      $self = $self->absolute if $self->is_relative;
      $base = $base->absolute if $base->is_relative;
  
      # normalize volumes if they exist
      $self = $self->absolute if !length $self->volume && length $base->volume;
      $base = $base->absolute if length $self->volume  && !length $base->volume;
  
      # can't make paths relative across volumes
      if ( !_same( $self->volume, $base->volume ) ) {
          Carp::croak("relative() can't cross volumes: '$self' vs '$base'");
      }
  
      # if same absolute path, relative is current directory
      return path(".") if _same( $self->[PATH], $base->[PATH] );
  
      # if base is a prefix of self, chop prefix off self
      if ( $base->subsumes($self) ) {
          $base = "" if $base->is_rootdir;
          my $relative = "$self";
          $relative =~ s{\A\Q$base/}{};
          return path($relative);
      }
  
      # base is not a prefix, so must find a common prefix (even if root)
      my ( @common, @self_parts, @base_parts );
      @base_parts = split /\//, $base->_just_filepath;
  
      # if self is rootdir, then common directory is root (shown as empty
      # string for later joins); otherwise, must be computed from path parts.
      if ( $self->is_rootdir ) {
          @common = ("");
          shift @base_parts;
      }
      else {
          @self_parts = split /\//, $self->_just_filepath;
  
          while ( @self_parts && @base_parts && _same( $self_parts[0], $base_parts[0] ) ) {
              push @common, shift @base_parts;
              shift @self_parts;
          }
      }
  
      # if there are any symlinks from common to base, we have a problem, as
      # you can't guarantee that updir from base reaches the common prefix;
      # we must resolve symlinks and try again; likewise, any updirs are
      # a problem as it throws off calculation of updirs needed to get from
      # self's path to the common prefix.
      if ( my $new_base = $self->_resolve_between( \@common, \@base_parts ) ) {
          return $self->relative($new_base);
      }
  
      # otherwise, symlinks in common or from common to A don't matter as
      # those don't involve updirs
      my @new_path = ( ("..") x ( 0+ @base_parts ), @self_parts );
      return path(@new_path);
  }
  
  sub _just_filepath {
      my $self     = shift;
      my $self_vol = $self->volume;
      return "$self" if !length $self_vol;
  
      ( my $self_path = "$self" ) =~ s{\A\Q$self_vol}{};
  
      return $self_path;
  }
  
  sub _resolve_between {
      my ( $self, $common, $base ) = @_;
      my $path = $self->volume . join( "/", @$common );
      my $changed = 0;
      for my $p (@$base) {
          $path .= "/$p";
          if ( $p eq '..' ) {
              $changed = 1;
              if ( -e $path ) {
                  $path = path($path)->realpath->[PATH];
              }
              else {
                  $path =~ s{/[^/]+/..$}{/};
              }
          }
          if ( -l $path ) {
              $changed = 1;
              $path    = path($path)->realpath->[PATH];
          }
      }
      return $changed ? path($path) : undef;
  }
  
  #pod =method remove
  #pod
  #pod     path("foo.txt")->remove;
  #pod
  #pod This is just like C<unlink>, except for its error handling: if the path does
  #pod not exist, it returns false; if deleting the file fails, it throws an
  #pod exception.
  #pod
  #pod Current API available since 0.012.
  #pod
  #pod =cut
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink( $self->[PATH] ) || $self->_throw('unlink');
  }
  
  #pod =method remove_tree
  #pod
  #pod     # directory
  #pod     path("foo/bar/baz")->remove_tree;
  #pod     path("foo/bar/baz")->remove_tree( \%options );
  #pod     path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  #pod
  #pod Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  #pod An optional hash reference is passed through to C<remove_tree>.  Errors will be
  #pod trapped and an exception thrown.  Returns the number of directories deleted,
  #pod just like C<remove_tree>.
  #pod
  #pod If you want to remove a directory only if it is empty, use the built-in
  #pod C<rmdir> function instead.
  #pod
  #pod     rmdir path("foo/bar/baz/");
  #pod
  #pod Current API available since 0.013.
  #pod
  #pod =cut
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      $args->{safe}  = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  #pod =method sibling
  #pod
  #pod     $foo = path("/tmp/foo.txt");
  #pod     $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
  #pod     $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the parent of the original.
  #pod This is slightly more efficient than C<< $path->parent->child(...) >>.
  #pod
  #pod Current API available since 0.058.
  #pod
  #pod =cut
  
  sub sibling {
      my $self = shift;
      return path( $self->parent->[PATH], @_ );
  }
  
  #pod =method slurp, slurp_raw, slurp_utf8
  #pod
  #pod     $data = path("foo.txt")->slurp;
  #pod     $data = path("foo.txt")->slurp( {binmode => ":raw"} );
  #pod     $data = path("foo.txt")->slurp_raw;
  #pod     $data = path("foo.txt")->slurp_utf8;
  #pod
  #pod Reads file contents into a scalar.  Takes an optional hash reference which may
  #pod be used to pass options.  The only available option is C<binmode>, which is
  #pod passed to C<binmode()> on the handle used for reading.
  #pod
  #pod C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  #pod a fast, unbuffered, raw read.
  #pod
  #pod C<slurp_utf8> is like C<slurp> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw slurp will be done instead and the result decoded
  #pod with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  #pod magnitude faster than using C<:encoding(UTF-8)>.
  #pod
  #pod B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  #pod you plan to slurp from a file created with L<File::Temp>, be sure to
  #pod close other handles or open without locking to avoid a deadlock:
  #pod
  #pod     my $tempfile = File::Temp->new(EXLOCK => 0);
  #pod     my $guts = path($tempfile)->slurp;
  #pod
  #pod Current API available since 0.004.
  #pod
  #pod =cut
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $_[1] = { binmode => ":unix:utf8_strict" };
          goto &slurp;
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  #pod =method spew, spew_raw, spew_utf8
  #pod
  #pod     path("foo.txt")->spew(@data);
  #pod     path("foo.txt")->spew(\@data);
  #pod     path("foo.txt")->spew({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->spew_raw(@data);
  #pod     path("foo.txt")->spew_utf8(@data);
  #pod
  #pod Writes data to a file atomically.  The file is written to a temporary file in
  #pod the same directory, then renamed over the original.  An optional hash reference
  #pod may be used to pass options.  The only option is C<binmode>, which is passed to
  #pod C<binmode()> on the handle used for writing.
  #pod
  #pod C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod spew will be done instead on the data encoded with C<Unicode::UTF8>.
  #pod
  #pod B<NOTE>: because the file is written to a temporary file and then renamed, the
  #pod new file will wind up with permissions based on your current umask.  This is a
  #pod feature to protect you from a race condition that would otherwise give
  #pod different permissions than you might expect.  If you really want to keep the
  #pod original mode flags, use L</append> with the C<truncate> option.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # spewing need to follow the link
      # and create the tempfile in the same dir
      my $resolved_path = $self->_resolve_symlinks;
  
      my $temp = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          my $self = shift;
          spew(
              $self,
              { binmode => ":unix" },
              map { Unicode::UTF8::encode_utf8($_) } map { ref eq 'ARRAY' ? @$_ : $_ } @_
          );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          splice @_, 1, 0, { binmode => ":unix:utf8_strict" };
          goto &spew;
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  #pod =method stat, lstat
  #pod
  #pod     $stat = path("foo.txt")->stat;
  #pod     $stat = path("/some/symlink")->lstat;
  #pod
  #pod Like calling C<stat> or C<lstat> from L<File::stat>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  #pod =method stringify
  #pod
  #pod     $path = path("foo.txt");
  #pod     say $path->stringify; # same as "$path"
  #pod
  #pod Returns a string representation of the path.  Unlike C<canonpath>, this method
  #pod returns the path standardized with Unix-style C</> directory separators.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub stringify { $_[0]->[PATH] }
  
  #pod =method subsumes
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/baz"); # true
  #pod     path("/foo/bar")->subsumes("/foo/baz");   # false
  #pod
  #pod Returns true if the first path is a prefix of the second path at a directory
  #pod boundary.
  #pod
  #pod This B<does not> resolve parent directory entries (C<..>) or symlinks:
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/../baz"); # true
  #pod
  #pod If such things are important to you, ensure that both paths are resolved to
  #pod the filesystem with C<realpath>:
  #pod
  #pod     my $p1 = path("foo/bar")->realpath;
  #pod     my $p2 = path("foo/bar/../baz")->realpath;
  #pod     if ( $p1->subsumes($p2) ) { ... }
  #pod
  #pod Current API available since 0.048.
  #pod
  #pod =cut
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  #pod =method touch
  #pod
  #pod     path("foo.txt")->touch;
  #pod     path("foo.txt")->touch($epoch_secs);
  #pod
  #pod Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  #pod changes the modification and access times to the current time.  If the first
  #pod argument is the epoch seconds then it will be used.
  #pod
  #pod Returns the path object so it can be easily chained with other methods:
  #pod
  #pod     # won't die if foo.txt doesn't exist
  #pod     $content = path("foo.txt")->touch->slurp;
  #pod
  #pod Current API available since 0.015.
  #pod
  #pod =cut
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      if ( defined $epoch ) {
          utime $epoch, $epoch, $self->[PATH]
            or $self->_throw("utime ($epoch)");
      }
      else {
          # literal undef prevents warnings :-(
          utime undef, undef, $self->[PATH]
            or $self->_throw("utime ()");
      }
      return $self;
  }
  
  #pod =method touchpath
  #pod
  #pod     path("bar/baz/foo.txt")->touchpath;
  #pod
  #pod Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  #pod before touching the file.  Returns the path object like C<touch> does.
  #pod
  #pod Current API available since 0.022.
  #pod
  #pod =cut
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  #pod =method visit
  #pod
  #pod     path("/tmp")->visit( \&callback, \%options );
  #pod
  #pod Executes a callback for each child of a directory.  It returns a hash
  #pod reference with any state accumulated during iteration.
  #pod
  #pod The options are the same as for L</iterator> (which it uses internally):
  #pod C<recurse> and C<follow_symlinks>.  Both default to false.
  #pod
  #pod The callback function will receive a C<Path::Tiny> object as the first argument
  #pod and a hash reference to accumulate state as the second argument.  For example:
  #pod
  #pod     # collect files sizes
  #pod     my $sizes = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             return if $path->is_dir;
  #pod             $state->{$path} = -s $path;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod For convenience, the C<Path::Tiny> object will also be locally aliased as the
  #pod C<$_> global variable:
  #pod
  #pod     # print paths matching /foo/
  #pod     path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  #pod
  #pod If the callback returns a B<reference> to a false scalar value, iteration will
  #pod terminate.  This is not the same as "pruning" a directory search; this just
  #pod stops all iteration and returns the state hash reference.
  #pod
  #pod     # find up to 10 files larger than 100K
  #pod     my $files = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             $state->{$path}++ if -s $path > 102400
  #pod             return \0 if keys %$state == 10;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub visit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      Carp::croak("Callback for visit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
      my $next  = $self->iterator($args);
      my $state = {};
      while ( my $file = $next->() ) {
          local $_ = $file;
          my $r = $cb->( $file, $state );
          last if ref($r) eq 'SCALAR' && !$$r;
      }
      return $state;
  }
  
  #pod =method volume
  #pod
  #pod     $vol = path("/tmp/foo.txt")->volume;   # ""
  #pod     $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  #pod
  #pod Returns the volume portion of the path.  This is equivalent
  #pod to what L<File::Spec> would give from C<splitpath> and thus
  #pod usually is the empty string on Unix-like operating systems or the
  #pod drive letter for an absolute path on C<MSWin32>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.104
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    ($head) = $file->lines( {count => 1} );
    ($tail) = $file->lines( {count => -1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module provides a small, fast utility for working with file paths.  It is
  friendlier to use than L<File::Spec> and provides easy access to functions from
  several other core file handling modules.  It aims to be smaller and faster
  than many alternatives on CPAN, while helping people do many common things in
  consistent and less error-prone ways.
  
  Path::Tiny does not try to work for anything except Unix-like and Win32
  platforms.  Even then, it might break if you try something particularly obscure
  or tortuous.  (Quick!  What does this mean:
  C<< ///../../..//./././a//b/.././c/././ >>?  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode.  On Windows, that means they will not have CRLF translation from the
  C<:crlf> IO layer.  Installing L<Unicode::UTF8> 0.58 or later will speed up
  C<*_utf8> situations in many cases and is highly recommended.
  Alternatively, installing L<PerlIO::utf8_strict> 0.003 or later will be
  used in place of the default C<:encoding(UTF-8)>.
  
  This module depends heavily on PerlIO layers for correct operation and thus
  requires Perl 5.008001 or later.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  If called with a single C<Path::Tiny> argument, the original is returned unless
  the original is holding a temporary file or directory reference in which case a
  stringified copy is made.
  
      $path = path("foo/bar");
      $temp = Path::Tiny->tempfile;
  
      $p2 = path($path); # like $p2 = $path
      $t2 = path($temp); # like $t2 = path( "$temp" )
  
  This optimizes copies without proliferating references unexpectedly if a copy is
  made by code outside your control.
  
  Current API available since 0.017.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  Current API available since 0.001.
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will be normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.  If you want it to have
  the C<realpath> instead, pass a leading options hash like this:
  
      $real_temp = tempfile({realpath => 1}, @options);
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  reused.  This is not as secure as using File::Temp handles directly, but is
  less prone to deadlocks or access problems on some platforms.  Think of what
  C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  up.
  
  B<Note 2>: if you don't want these cleaned up automatically when the object
  is destroyed, File::Temp requires different options for directories and
  files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  files.
  
  B<Note 3>: Don't lose the temporary object by chaining a method call instead
  of storing it:
  
      my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  
  B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  Keeping a reference to, or modifying the cached object may break the
  behavior documented above and is not supported.  Use at your own risk.
  
  Current API available since 0.097.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  If no argument is given, the current directory is used as the
  absolute base path.  If an argument is given, it will be converted to an
  absolute path (if it is not already) and used as the absolute base path.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  Current API available since 0.101.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  Valid options are:
  
  =over 4
  
  =item *
  
  C<binmode>: passed to C<binmode()> on the handle used for writing.
  
  =item *
  
  C<truncate>: truncates the file after locking and before appending
  
  =back
  
  The C<truncate> option is a way to replace the contents of a file
  B<in place>, unlike L</spew> which writes to a temporary file and then
  replaces the original (if it exists).
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw append will be done instead on the data encoded
  with C<Unicode::UTF8>.
  
  Current API available since 0.060.
  
  =head2 assert
  
      $path = path("foo.txt")->assert( sub { $_->exists } );
  
  Returns the invocant after asserting that a code reference argument returns
  true.  When the assertion code reference runs, it will have the invocant
  object in the C<$_> variable.  If it returns false, an exception will be
  thrown.  The assertion code reference may also throw its own exception.
  
  If no assertion is provided, the invocant is returned without error.
  
  Current API available since 0.062.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename;        # bar.txt
      $name = path("foo.txt")->basename('.txt');    # foo
      $name = path("foo.txt")->basename(qr/.txt/);  # foo
      $name = path("foo.txt")->basename(@suffixes);
  
  Returns the file portion or last directory portion of a path.
  
  Given a list of suffixes as strings or regular expressions, any that match at
  the end of the file portion or last directory portion will be removed before
  the result is returned.
  
  Current API available since 0.054.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  Current API available since 0.001.
  
  =head2 cached_temp
  
  Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  If there is no such object, this method throws.
  
  B<WARNING>: Keeping a reference to, or modifying the cached object may
  break the behavior documented for temporary files and directories created
  with C<Path::Tiny> and is not supported.  Use at your own risk.
  
  Current API available since 0.101.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  Current API available since 0.001.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  Current API available since 0.028.
  
  =head2 chmod
  
      path("foo.txt")->chmod(0777);
      path("foo.txt")->chmod("0755");
      path("foo.txt")->chmod("go-w");
      path("foo.txt")->chmod("a=r,u+wx");
  
  Sets file or directory permissions.  The argument can be a numeric mode, a
  octal string beginning with a "0" or a limited subset of the symbolic mode use
  by F</bin/chmod>.
  
  The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  are required for each clause, multiple ops are not allowed and permissions
  C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  
  Current API available since 0.053.
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies the current path to the given destination using L<File::Copy>'s
  C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  newly copied file.
  
  Current API available since 0.070.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
      $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  
  Returns a hexadecimal digest for a file.  An optional hash reference of options may
  be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  bytes will be read at a time.  If not provided, the entire file will be slurped
  into memory to compute the digest.
  
  Any subsequent arguments are passed to the constructor for L<Digest> to select
  an algorithm.  If no arguments are given, the default is SHA-256.
  
  Current API available since 0.056.
  
  =head2 dirname (deprecated)
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory portion you would get from calling
  C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  parent directory portion.  Because L<File::Spec> is inconsistent, the result
  might or might not have a trailing slash.  Because of this, this method is
  B<deprecated>.
  
  A better, more consistently approach is likely C<< $path->parent->stringify >>,
  which will not have a trailing slash except for a root directory.
  
  Deprecated in 0.056.
  
  =head2 edit, edit_raw, edit_utf8
  
      path("foo.txt")->edit( \&callback, $options );
      path("foo.txt")->edit_utf8( \&callback );
      path("foo.txt")->edit_raw( \&callback );
  
  These are convenience methods that allow "editing" a file using a single
  callback argument. They slurp the file using C<slurp>, place the contents
  inside a localized C<$_> variable, call the callback function (without
  arguments), and then write C<$_> (presumably mutated) back to the
  file with C<spew>.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<slurp> and C<spew>.
  
  C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 edit_lines, edit_lines_utf8, edit_lines_raw
  
      path("foo.txt")->edit_lines( \&callback, $options );
      path("foo.txt")->edit_lines_utf8( \&callback );
      path("foo.txt")->edit_lines_raw( \&callback );
  
  These are convenience methods that allow "editing" a file's lines using a
  single callback argument.  They iterate over the file: for each line, the
  line is put into a localized C<$_> variable, the callback function is
  executed (without arguments) and then C<$_> is written to a temporary file.
  When iteration is finished, the temporary file is atomically renamed over
  the original.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to the method that open handles for reading and
  writing.
  
  C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  C<slurp_*> and C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }     # -e
      if ( path("/tmp")->is_dir ) { ... }     # -d
      if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  
  Implements file test operations, this means the file or directory actually has
  to exist on the filesystem.  Until then, it's just a path.
  
  B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  read just like files.
  
  Use C<-f> instead if you really mean to check for a plain file.
  
  Current API available since 0.053.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.
  
  The C<locked> option governs file locking; if true, handles opened for writing,
  appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  truncation until after the lock is acquired.
  
  The C<exclusive> option causes the open() call to fail if the file already
  exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  C<exclusive> implies C<locked> and will set it for you if you forget it.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  Current API available since 0.066.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  Current API available since 0.001.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  Current API available since 0.038.
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  See also L</visit>.
  
  Current API available since 0.016.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.
  
  If C<binmode> is provided, it will be set on the handle prior to reading.
  
  If a positive C<count> is provided, that many lines will be returned from the
  start of the file.  If a negative C<count> is provided, the entire file will be
  read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  exceeds the number of lines in the file, all lines will be returned.
  
  If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  C<LF>) will be removed from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  Current API available since 0.065.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  Current API available since 0.001.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Move the current path to the given destination path using Perl's
  built-in L<rename|perlfunc/rename> function. Returns the result
  of the C<rename> function.
  
  Current API available since 0.001.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  Current API available since 0.011.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  Current API available since 0.014.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the parent path can't be resolved (e.g. if it includes directories that
  don't exist), an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  However, if the parent path exists and only the last component (e.g. filename)
  doesn't exist, the realpath will be the realpath of the parent plus the
  non-existent last component:
  
      $real = path("./aasdlfasdlf")->realpath; # works
  
  The underlying L<Cwd> module usually worked this way on Unix, but died on
  Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  it's safe to use anywhere.
  
  Current API available since 0.001.
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a path relative to a new base path
  given as an argument.  If no argument is given, the current directory will
  be used as the new base path.
  
  If either path is already relative, it will be made absolute based on the
  current directly before determining the new relative path.
  
  The algorithm is roughly as follows:
  
  =over 4
  
  =item *
  
  If the original and new base path are on different volumes, an exception will be thrown.
  
  =item *
  
  If the original and new base are identical, the relative path is C<".">.
  
  =item *
  
  If the new base subsumes the original, the relative path is the original path with the new base chopped off the front
  
  =item *
  
  If the new base does not subsume the original, a common prefix path is determined (possibly the root directory) and the relative path will consist of updirs (C<"..">) to reach the common prefix, followed by the original path less the common prefix.
  
  =back
  
  Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  on a common prefix takes into account symlinks that could affect the updir
  process.  Given an original path "/A/B" and a new base "/A/C",
  (where "A", "B" and "C" could each have multiple path components):
  
  =over 4
  
  =item *
  
  Symlinks in "A" don't change the result unless the last component of A is a symlink and the first component of "C" is an updir.
  
  =item *
  
  Symlinks in "B" don't change the result and will exist in the result as given.
  
  =item *
  
  Symlinks and updirs in "C" must be resolved to actual paths, taking into account the possibility that not all path components might exist on the filesystem.
  
  =back
  
  Current API available since 0.001.  New algorithm (that accounts for
  symlinks) available since 0.079.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  This is just like C<unlink>, except for its error handling: if the path does
  not exist, it returns false; if deleting the file fails, it throws an
  exception.
  
  Current API available since 0.012.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  Current API available since 0.013.
  
  =head2 sibling
  
      $foo = path("/tmp/foo.txt");
      $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
      $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  
  Returns a new C<Path::Tiny> object relative to the parent of the original.
  This is slightly more efficient than C<< $path->parent->child(...) >>.
  
  Current API available since 0.058.
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference which may
  be used to pass options.  The only available option is C<binmode>, which is
  passed to C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw slurp will be done instead and the result decoded
  with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  magnitude faster than using C<:encoding(UTF-8)>.
  
  B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  you plan to slurp from a file created with L<File::Temp>, be sure to
  close other handles or open without locking to avoid a deadlock:
  
      my $tempfile = File::Temp->new(EXLOCK => 0);
      my $guts = path($tempfile)->slurp;
  
  Current API available since 0.004.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  spew will be done instead on the data encoded with C<Unicode::UTF8>.
  
  B<NOTE>: because the file is written to a temporary file and then renamed, the
  new file will wind up with permissions based on your current umask.  This is a
  feature to protect you from a race condition that would otherwise give
  different permissions than you might expect.  If you really want to keep the
  original mode flags, use L</append> with the C<truncate> option.
  
  Current API available since 0.011.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  Current API available since 0.001.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  Current API available since 0.001.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  Current API available since 0.048.
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with other methods:
  
      # won't die if foo.txt doesn't exist
      $content = path("foo.txt")->touch->slurp;
  
  Current API available since 0.015.
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  Current API available since 0.022.
  
  =head2 visit
  
      path("/tmp")->visit( \&callback, \%options );
  
  Executes a callback for each child of a directory.  It returns a hash
  reference with any state accumulated during iteration.
  
  The options are the same as for L</iterator> (which it uses internally):
  C<recurse> and C<follow_symlinks>.  Both default to false.
  
  The callback function will receive a C<Path::Tiny> object as the first argument
  and a hash reference to accumulate state as the second argument.  For example:
  
      # collect files sizes
      my $sizes = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              return if $path->is_dir;
              $state->{$path} = -s $path;
          },
          { recurse => 1 }
      );
  
  For convenience, the C<Path::Tiny> object will also be locally aliased as the
  C<$_> global variable:
  
      # print paths matching /foo/
      path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  
  If the callback returns a B<reference> to a false scalar value, iteration will
  terminate.  This is not the same as "pruning" a directory search; this just
  stops all iteration and returns the state hash reference.
  
      # find up to 10 files larger than 100K
      my $files = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              $state->{$path}++ if -s $path > 102400
              return \0 if keys %$state == 10;
          },
          { recurse => 1 }
      );
  
  If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  
  Current API available since 0.062.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  Current API available since 0.001.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32 FREEZE THAW TO_JSON abs2rel
  
  =head1 EXCEPTION HANDLING
  
  Simple usage errors will generally croak.  Failures of underlying Perl
  functions will be thrown as exceptions in the class
  C<Path::Tiny::Error>.
  
  A C<Path::Tiny::Error> object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op> — a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file> — the file or directory relating to the error
  
  =item *
  
  C<err> — hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg> — a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 Subclassing not supported
  
  For speed, this class is implemented as an array based object and uses many
  direct function calls internally.  You must not subclass it and expect
  things to work properly.
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.  If the user does not have write
  permission, no lock will be used.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods by default use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.  Alternatively, if you install L<PerlIO::utf8_strict>,
  that will be used instead of C<:encoding(UTF-8)> and is also very fast.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::chmod>
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alex Efros Chris Williams Dave Rolsky David Steinbrunner Doug Bell Gabor Szabo Gabriel Andrade George Hartzell Geraud Continsouzas Goro Fuji Graham Knop Ollis James Hunt John Karr Karen Etheridge Mark Ellis Martin Kjeldsen Michael G. Schwern Nigel Gregoire Philippe Bruhat (BooK) Regina Verbae Roy Ivy III Shlomi Fish Smylers Tatsuhiko Miyagawa Toby Inkster Yanick Champoux 김도형 - Keedi Kim
  
  =over 4
  
  =item *
  
  Alex Efros <powerman@powerman.name>
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  James Hunt <james@niftylogic.com>
  
  =item *
  
  John Karr <brainbuz@brainbuz.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Mark Ellis <mark.ellis@cartridgesave.co.uk>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Nigel Gregoire <nigelgregoire@gmail.com>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  Regina Verbae <regina-verbae@users.noreply.github.com>
  
  =item *
  
  Roy Ivy III <rivy@cpan.org>
  
  =item *
  
  Shlomi Fish <shlomif@shlomifish.org>
  
  =item *
  
  Smylers <Smylers@stripey.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  Yanick Champoux <yanick@babyl.dyndns.org>
  
  =item *
  
  김도형 - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Reply/Plugin/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'REPLY_PLUGIN_TYPETINY';
  package Reply::Plugin::TypeTiny;
  
  use strict;
  use warnings;
  
  BEGIN {
  	$Reply::Plugin::TypeTiny::AUTHORITY = 'cpan:TOBYINK';
  	$Reply::Plugin::TypeTiny::VERSION   = '1.002001';
  };
  
  require Reply::Plugin;
  our @ISA = 'Reply::Plugin';
  
  use Scalar::Util qw(blessed);
  use Term::ANSIColor;
  
  sub mangle_error {
  	my $self  = shift;
  	my ($err) = @_;
  	
  	if (blessed $err and $err->isa("Error::TypeTiny::Assertion"))
  	{
  		my $explain = $err->explain;
  		if ($explain)
  		{
  			print color("cyan");
  			print "Error::TypeTiny::Assertion explain:\n";
  			$self->_explanation($explain, "");
  			local $| = 1;
  			print "\n";
  			print color("reset");
  		}
  	}
  	
  	return @_;
  }
  
  sub _explanation
  {
  	my $self = shift;
  	my ($ex, $indent)  = @_;
  	
  	for my $line (@$ex)
  	{
  		if (ref($line) eq q(ARRAY))
  		{
  			print "$indent * Explain:\n";
  			$self->_explanation($line, "$indent   ");
  		}
  		else
  		{
  			print "$indent * $line\n";
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Reply::Plugin::TypeTiny - improved type constraint exceptions in Reply
  
  =head1 STATUS
  
  This module is not covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is a small plugin to improve error messages in L<Reply>.
  Not massively tested.
  
  =begin trustme
  
  =item mangle_error
  
  =end trustme
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Error::TypeTiny::Assertion>, L<Reply>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
REPLY_PLUGIN_TYPETINY

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  # $Id: ShellQuote.pm,v 1.11 2010-06-11 20:08:57 roderick Exp $
  #
  # Copyright (c) 1997 Roderick Schertler.  All rights reserved.  This
  # program is free software; you can redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  =head1 NAME
  
  String::ShellQuote - quote strings for passing through the shell
  
  =head1 SYNOPSIS
  
      $string = shell_quote @list;
      $string = shell_quote_best_effort @list;
      $string = shell_comment_quote $string;
  
  =head1 DESCRIPTION
  
  This module contains some functions which are useful for quoting strings
  which are going to pass through the shell or a shell-like object.
  
  =over
  
  =cut
  
  package String::ShellQuote;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT);
  
  require Exporter;
  
  $VERSION	= '1.04';
  @ISA		= qw(Exporter);
  @EXPORT		= qw(shell_quote shell_quote_best_effort shell_comment_quote);
  
  sub croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _shell_quote_backend {
      my @in = @_;
      my @err = ();
  
      if (0) {
  	require RS::Handy;
  	print RS::Handy::data_dump(\@in);
      }
  
      return \@err, '' unless @in;
  
      my $ret = '';
      my $saw_non_equal = 0;
      foreach (@in) {
  	if (!defined $_ or $_ eq '') {
  	    $_ = "''";
  	    next;
  	}
  
  	if (s/\x00//g) {
  	    push @err, "No way to quote string containing null (\\000) bytes";
  	}
  
      	my $escape = 0;
  
  	# = needs quoting when it's the first element (or part of a
  	# series of such elements), as in command position it's a
  	# program-local environment setting
  
  	if (/=/) {
  	    if (!$saw_non_equal) {
  	    	$escape = 1;
  	    }
  	}
  	else {
  	    $saw_non_equal = 1;
  	}
  
  	if (m|[^\w!%+,\-./:=@^]|) {
  	    $escape = 1;
  	}
  
  	if ($escape
  		|| (!$saw_non_equal && /=/)) {
  
  	    # ' -> '\''
      	    s/'/'\\''/g;
  
  	    # make multiple ' in a row look simpler
  	    # '\'''\'''\'' -> '"'''"'
      	    s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
  
  	    $_ = "'$_'";
  	    s/^''//;
  	    s/''$//;
  	}
      }
      continue {
  	$ret .= "$_ ";
      }
  
      chop $ret;
      return \@err, $ret;
  }
  
  =item B<shell_quote> [I<string>]...
  
  B<shell_quote> quotes strings so they can be passed through the shell.
  Each I<string> is quoted so that the shell will pass it along as a
  single argument and without further interpretation.  If no I<string>s
  are given an empty string is returned.
  
  If any I<string> can't be safely quoted B<shell_quote> will B<croak>.
  
  =cut
  
  sub shell_quote {
      my ($rerr, $s) = _shell_quote_backend @_;
  
      if (@$rerr) {
      	my %seen;
      	@$rerr = grep { !$seen{$_}++ } @$rerr;
  	my $s = join '', map { "shell_quote(): $_\n" } @$rerr;
  	chomp $s;
  	croak $s;
      }
      return $s;
  }
  
  =item B<shell_quote_best_effort> [I<string>]...
  
  This is like B<shell_quote>, excpet if the string can't be safely quoted
  it does the best it can and returns the result, instead of dying.
  
  =cut
  
  sub shell_quote_best_effort {
      my ($rerr, $s) = _shell_quote_backend @_;
  
      return $s;
  }
  
  =item B<shell_comment_quote> [I<string>]
  
  B<shell_comment_quote> quotes the I<string> so that it can safely be
  included in a shell-style comment (the current algorithm is that a sharp
  character is placed after any newlines in the string).
  
  This routine might be changed to accept multiple I<string> arguments
  in the future.  I haven't done this yet because I'm not sure if the
  I<string>s should be joined with blanks ($") or nothing ($,).  Cast
  your vote today!  Be sure to justify your answer.
  
  =cut
  
  sub shell_comment_quote {
      return '' unless @_;
      unless (@_ == 1) {
  	croak "Too many arguments to shell_comment_quote "
  	    	    . "(got " . @_ . " expected 1)";
      }
      local $_ = shift;
      s/\n/\n#/g;
      return $_;
  }
  
  1;
  
  __END__
  
  =back
  
  =head1 EXAMPLES
  
      $cmd = 'fuser 2>/dev/null ' . shell_quote @files;
      @pids = split ' ', `$cmd`;
  
      print CFG "# Configured by: ",
  		shell_comment_quote($ENV{LOGNAME}), "\n";
  
  =head1 BUGS
  
  Only Bourne shell quoting is supported.  I'd like to add other shells
  (particularly cmd.exe), but I'm not familiar with them.  It would be a
  big help if somebody supplied the details.
  
  =head1 AUTHOR
  
  Roderick Schertler <F<roderick@argon.org>>
  
  =head1 SEE ALSO
  
  perl(1).
  
  =cut
STRING_SHELLQUOTE

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  $Sub::Exporter::Progressive::VERSION = '0.001013';
  use strict;
  use warnings;
  
  # ABSTRACT: Only use Sub::Exporter if you need it
  
  sub _croak {
    require Carp;
    &Carp::croak;
  }
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     no warnings 'once';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if ( grep {
           length ref $_
              or
           $_ !~ / \A [:-]? \w+ \z /xm
        } @args ) {
           _croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif ( defined( (my ($num) = grep { m/^\d/ } @args)[0] ) ) {
           _croak "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ( ($setup||'') eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              _croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              _croak $too_complicated if grep { length ref $_ } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 _croak $too_complicated if grep {
                    length ref $_
                       or
                    $_ =~ / \A - (?! all \b ) /x
                 } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              _croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        _croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 VERSION
  
  version 0.001013
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 AUTHOR
  
  Arthur Axel "fREW" Schmidt <Sub-Exporter-Progressive@afoolishmanifesto.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Arthur Axel "fREW" Schmidt.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"TOML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML';
  package TOML;
  
  # -------------------------------------------------------------------
  # TOML - Parser for Tom's Obvious, Minimal Language.
  #
  # Copyright (C) 2013 Darren Chamberlain <darren@cpan.org>
  # -------------------------------------------------------------------
  
  use 5.008005;
  use strict;
  use warnings;
  use Exporter 'import';
  
  our ($VERSION, @EXPORT, @_NAMESPACE, $PARSER);
  
  use B;
  use Carp qw(croak);
  use TOML::Parser 0.03;
  
  $VERSION = "0.97";
  @EXPORT = qw(from_toml to_toml);
  $PARSER = TOML::Parser->new(inflate_boolean  => sub { $_[0] });
  
  sub to_toml {
      my $stuff = shift;
      local @_NAMESPACE = ();
      _to_toml($stuff);
  }
  
  sub _to_toml {
      my ($stuff) = @_;
  
      if (ref $stuff eq 'HASH') {
          my $res = '';
          my @keys = sort keys %$stuff;
          for my $key (grep { ref $stuff->{$_} ne 'HASH' } @keys) {
              my $val = $stuff->{$key};
              $res .= "$key = " . _serialize($val) . "\n";
          }
          for my $key (grep { ref $stuff->{$_} eq 'HASH' } @keys) {
              my $val = $stuff->{$key};
              local @_NAMESPACE = (@_NAMESPACE, $key);
              $res .= sprintf("[%s]\n", join(".", @_NAMESPACE));
              $res .= _to_toml($val);
          }
          return $res;
      } else {
          croak("You cannot convert non-HashRef values to TOML");
      }
  }
  
  sub _serialize {
      my $value = shift;
      my $b_obj = B::svref_2object(\$value);
      my $flags = $b_obj->FLAGS;
  
      return $value
          if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
      my $type = ref($value);
      if (!$type) {
          return string_to_json($value);
      } elsif ($type eq 'ARRAY') {
          return sprintf('[%s]', join(", ", map { _serialize($_) } @$value));
      } elsif ($type eq 'SCALAR') {
          if (defined $$value) {
              if ($$value eq '0') {
                  return 'false';
              } elsif ($$value eq '1') {
                  return 'true';
              } else {
                  croak("cannot encode reference to scalar");
              }
          }
          croak("cannot encode reference to scalar");
      }
      croak("Bad type in to_toml: $type");
  }
  
  my %esc = (
      "\n" => '\n',
      "\r" => '\r',
      "\t" => '\t',
      "\f" => '\f',
      "\b" => '\b',
      "\"" => '\"',
      "\\" => '\\\\',
      "\'" => '\\\'',
  );
  sub string_to_json {
      my ($arg) = @_;
  
      $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
      $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
      return '"' . $arg . '"';
  }
  
  sub from_toml {
      my $string = shift;
      local $@;
      my $toml = eval { $PARSER->parse($string) };
      return wantarray ? ($toml, $@) : $toml;
  }
  
  1;
  
  __END__
  
  =encoding utf-8
  
  =for stopwords versa
  
  =head1 NAME
  
  TOML - Parser for Tom's Obvious, Minimal Language.
  
  =head1 SYNOPSIS
  
      use TOML qw(from_toml to_toml);
  
      # Parsing toml
      my $toml = slurp("~/.foo.toml");
      my $data = from_toml($toml);
  
      # With error checking
      my ($data, $err) = from_toml($toml);
      unless ($data) {
          die "Error parsing toml: $err";
      }
  
      # Creating toml
      my $toml = to_toml($data); 
  
  =head1 DESCRIPTION
  
  C<TOML> implements a parser for Tom's Obvious, Minimal Language, as
  defined at L<https://github.com/mojombo/toml>. C<TOML> exports two
  subroutines, C<from_toml> and C<to_toml>,
  
  =head1 FAQ
  
  =over 4
  
  =item How change how to de-serialize?
  
  You can change C<$TOML::PARSER> for change how to de-serialize.
  
  example:
  
      use TOML;
      use TOML::Parser;
  
      local $TOML::PARSER = TOML::Parser->new(
          inflate_boolean => sub { $_[0] eq 'true' ? \1 : \0 },
      );
  
      my $data = TOML::from_toml('foo = true');
  
  =back
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item from_toml
  
  C<from_toml> transforms a string containing toml to a perl data
  structure or vice versa. This data structure complies with the tests
  provided at L<https://github.com/mojombo/toml/tree/master/tests>.
  
  If called in list context, C<from_toml> produces a (C<hash>,
  C<error_string>) tuple, where C<error_string> is C<undef> on
  non-errors. If there is an error, then C<hash> will be undefined and
  C<error_string> will contains (scant) details about said error.
  
  =item to_toml
  
  C<to_toml> transforms a perl data structure into toml-formatted
  string.
  
  =back
  
  =head1 SEE ALSO
  
  L<TOML::Parser>
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; version 2.
  
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  02111-1301 USA
  
  =head1 AUTHOR
  
  Darren Chamberlain <darren@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item Tokuhiro Matsuno <tokuhirom@cpan.org>
  
  =item Matthias Bethke <matthias@towiski.de>
  
  =item Sergey Romanov <complefor@rambler.ru>
  
  =item karupanerura <karupa@cpan.org>
  
  =back
TOML

$fatpacked{"TOML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER';
  package TOML::Parser;
  use 5.010000;
  use strict;
  use warnings;
  use Encode;
  
  our $VERSION = "0.91";
  
  use TOML::Parser::Tokenizer qw/:constant/;
  use TOML::Parser::Tokenizer::Strict;
  use TOML::Parser::Util qw/unescape_str/;
  use Types::Serialiser;
  
  sub new {
      my $class = shift;
      my $args  = (@_ == 1 and ref $_[0] eq 'HASH') ? +shift : +{ @_ };
      return bless +{
          inflate_datetime => sub { $_[0] },
          inflate_boolean  => sub { $_[0] eq 'true' ? Types::Serialiser::true : Types::Serialiser::false },
          strict_mode      => 0,
          %$args,
      } => $class;
  }
  
  sub parse_file {
      my ($self, $file) = @_;
      open my $fh, '<:encoding(utf-8)', $file or die $!;
      return $self->parse_fh($fh);
  }
  
  sub parse_fh {
      my ($self, $fh) = @_;
      my $src = do { local $/; <$fh> };
      return $self->parse($src);
  }
  
  sub _tokenizer_class {
      my $self = shift;
      return $self->{strict_mode} ? 'TOML::Parser::Tokenizer::Strict' : 'TOML::Parser::Tokenizer';
  }
  
  our @TOKENS;
  our $ROOT;
  our $CONTEXT;
  sub parse {
      my ($self, $src) = @_;
  
      local $ROOT    = {};
      local $CONTEXT = $ROOT;
      local @TOKENS  = $self->_tokenizer_class->tokenize($src);
      while (my $token = shift @TOKENS) {
          $self->_parse_token($token);
      }
      return $ROOT;
  }
  
  sub _parse_token {
      my ($self, $token) = @_;
  
      my ($type, $val) = @$token;
      if ($type eq TOKEN_TABLE) {
          $self->_parse_table($val);
      }
      elsif ($type eq TOKEN_ARRAY_OF_TABLE) {
          $self->_parse_array_of_table($val);
      }
      elsif (my ($key, $value) = $self->_parse_key_and_value($token)) {
          die "Duplicate key. key:$key" if exists $CONTEXT->{$key};
          $CONTEXT->{$key} = $value;
      }
      elsif ($type eq TOKEN_COMMENT) {
          # pass through
      }
      else {
          die "Unknown case. type:$type";
      }
  }
  
  sub _parse_key_and_value {
      my ($self, $token) = @_;
  
      my ($type, $val) = @$token;
      if ($type eq TOKEN_KEY) {
          my $token = shift @TOKENS;
  
          my $key = $val;
          my $value = $self->_parse_value_token($token);
          return ($key, $value);
      }
  
      return;
  }
  
  sub _parse_table {
      my ($self, $keys) = @_;
      my @keys = @$keys;
  
      $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. @{[ join '.', @keys ]} cannot be `Table`";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  }
  
  sub _parse_array_of_table {
      my ($self, $keys) = @_;
      my @keys     = @$keys;
      my $last_key = pop @keys;
  
      $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. @{[ join '.', @keys ]} cannot be `Array of table`.";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  
      $CONTEXT->{$last_key} = [] unless exists $CONTEXT->{$last_key};
      die "invalid structure. @{[ join '.', @keys ]} cannot be `Array of table`" unless ref $CONTEXT->{$last_key} eq 'ARRAY';
      push @{ $CONTEXT->{$last_key} } => $CONTEXT = {};
  }
  
  sub _parse_value_token {
      my $self  = shift;
      my $token = shift;
  
      my ($type, $val, @args) = @$token;
      if ($type eq TOKEN_COMMENT) {
          return; # pass through
      }
      elsif ($type eq TOKEN_INTEGER || $type eq TOKEN_FLOAT) {
          $val =~ tr/_//d;
          return 0+$val;
      }
      elsif ($type eq TOKEN_BOOLEAN) {
          return $self->inflate_boolean($val);
      }
      elsif ($type eq TOKEN_DATETIME) {
          return $self->inflate_datetime($val);
      }
      elsif ($type eq TOKEN_STRING) {
          my ($is_raw) = @args;
          return $is_raw ? $val : unescape_str($val);
      }
      elsif ($type eq TOKEN_MULTI_LINE_STRING_BEGIN) {
          my ($is_raw) = @args;
          my $value = $self->_parse_value_token(shift @TOKENS);
          $value =~ s/\A(?:\r\n|[\r\n])//msg;
          $value =~ s/\\\s+//msg;
          if (my $token = shift @TOKENS) {
              my ($type) = @$token;
              return $value if $type eq TOKEN_MULTI_LINE_STRING_END;
              die "Unexpected token: $type";
          }
      }
      elsif ($type eq TOKEN_INLINE_TABLE_BEGIN) {
          my %data;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_INLINE_TABLE_END;
              next if $token->[0] eq TOKEN_COMMENT;
              my ($key, $value) = $self->_parse_key_and_value($token);
              die "Duplicate key. key:$key" if exists $data{$key};
              $data{$key} = $value;
          }
          return \%data;
      }
      elsif ($type eq TOKEN_ARRAY_BEGIN) {
          my @data;
  
          my $last_token;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_ARRAY_END;
              next if $token->[0] eq TOKEN_COMMENT;
              if ($self->{strict_mode}) {
                  die "Unexpected token: $token->[0]" if defined $last_token && $token->[0] ne $last_token->[0];
              }
              push @data => $self->_parse_value_token($token);
              $last_token = $token;
          }
          return \@data;
      }
  
      die "Unexpected token: $type";
  }
  
  sub inflate_datetime {
      my $self = shift;
      return $self->{inflate_datetime}->(@_);
  }
  
  sub inflate_boolean {
      my $self = shift;
      return $self->{inflate_boolean}->(@_);
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords versa
  
  =head1 NAME
  
  TOML::Parser - simple toml parser
  
  =head1 SYNOPSIS
  
      use TOML::Parser;
  
      my $parser = TOML::Parser->new;
      my $data   = $parser->parse($toml);
  
  =head1 DESCRIPTION
  
  TOML::Parser is a simple toml parser.
  
  This data structure complies with the tests
  provided at L<https://github.com/toml-lang/toml/tree/v0.4.0/tests>.
  
  The v0.4.0 specification is supported.
  
  =head1 METHODS
  
  =over
  
  =item my $parser = TOML::Parser->new(\%args)
  
  Creates a new TOML::Parser instance.
  
      use TOML::Parser;
  
      # create new parser
      my $parser = TOML::Parser->new();
  
  Arguments can be:
  
  =over
  
  =item * C<inflate_datetime>
  
  If use it, You can replace inflate C<datetime> process.
  The subroutine of default is C<identity>. C<e.g.) sub { $_[0] }>
  
      use TOML::Parser;
      use DateTime;
      use DateTime::Format::ISO8601;
  
      # create new parser
      my $parser = TOML::Parser->new(
          inflate_datetime => sub {
              my $dt = shift;
              return DateTime::Format::ISO8601->parse_datetime($dt);
          },
      );
  
  =item * C<inflate_boolean>
  
  If use it, You can replace inflate boolean process.
  The return value of default subroutine is C<Types::Serialiser::true> or C<Types::Serialiser::false>.
  
      use TOML::Parser;
  
      # create new parser
      my $parser = TOML::Parser->new(
          inflate_boolean => sub {
              my $boolean = shift;
              return $boolean eq 'true' ? 1 : 0;
          },
      );
  
  =item * C<strict_mode>
  
  TOML::Parser is using a more flexible rule for compatibility with old TOML of default.
  If make this option true value, You can parse a toml with strict rule.
  
      use TOML::Parser;
  
      # create new parser
      my $parser = TOML::Parser->new(
          strict_mode => 1
      );
  
  =back
  
  =item my $data = $parser->parse_file($path)
  
  =item my $data = $parser->parse_fh($fh)
  
  =item my $data = $parser->parse($src)
  
  Transforms a string containing toml to a perl data structure or vice versa.
  
  =back
  
  =head1 SEE ALSO
  
  L<TOML>
  
  =head1 LICENSE
  
  Copyright (C) karupanerura.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  karupanerura E<lt>karupa@cpan.orgE<gt>
  
  =head1 CONTRIBUTOR
  
  Olivier Mengué E<lt>dolmen@cpan.orgE<gt>
  yowcow E<lt>yowcow@cpan.orgE<gt>
  Syohei YOSHIDA E<lt>syohex@gmail.comE<gt>
  
  =cut
TOML_PARSER

$fatpacked{"TOML/Parser/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER';
  package TOML::Parser::Tokenizer;
  use 5.010000;
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  
  use constant DEBUG => $ENV{TOML_PARSER_TOKENIZER_DEBUG} ? 1 : 0;
  
  BEGIN {
      my @TOKENS = map uc, qw/
          comment
          table
          array_of_table
          key
          integer
          float
          boolean
          datetime
          string
          multi_line_string_begin
          multi_line_string_end
          inline_table_begin
          inline_table_end
          array_begin
          array_end
      /;
      my %CONSTANTS = map {
          ("TOKEN_$_" => $_)
      } @TOKENS;
  
      require constant;
      constant->import(\%CONSTANTS);
  
      # Exporter
      our @EXPORT_OK   = keys %CONSTANTS;
      our %EXPORT_TAGS = (
          constant => [keys %CONSTANTS],
      );
  };
  
  sub grammar_regexp {
      return +{
          comment        => qr{#(.*)},
          table          => {
              start => qr{\[},
              key   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^.\s\\\]]+))},
              sep   => qr{\.},
              end   => qr{\]},
          },
          array_of_table => {
              start => qr{\[\[},
              key   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^.\s\\\]]+))},
              sep   => qr{\.},
              end   => qr{\]\]},
          },
          key            => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^\s=]+))\s*=},
          value          => {
              datetime => qr{([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.[0-9]+)?(?:Z|[-+][0-9]{2}:[0-9]{2}))},
              float    => qr{([-+]?(?:[0-9_]+(?:\.[0-9_]+)?[eE][-+]?[0-9_]+|[0-9_]*\.[0-9_]+))},
              integer  => qr{([-+]?[0-9_]+)},
              boolean  => qr{(true|false)},
              string   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\')},
              mlstring => qr{("""|''')},
              inline   => {
                  start => qr{\{},
                  sep   => qr{\s*,\s*},
                  end   => qr{\}},
              },
              array    => {
                  start => qr{\[},
                  sep   => qr{\s*,\s*},
                  end   => qr{\]},
              },
          },
      };
  }
  
  sub tokenize {
      my ($class, $src) = @_;
  
      local $_ = $src;
      return $class->_tokenize();
  }
  
  sub _tokenize {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
  
      my @tokens;
      until (/\G\z/mgco) {
          if (/\G$grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              $class->_skip_whitespace();
              push @tokens => [TOKEN_COMMENT, $1 || ''];
          }
          elsif (/\G$grammar_regexp->{array_of_table}->{start}/mgc) {
              push @tokens => $class->_tokenize_array_of_table();
          }
          elsif (/\G$grammar_regexp->{table}->{start}/mgc) {
              push @tokens => $class->_tokenize_table();
          }
          elsif (my @t = $class->_tokenize_key_and_value()) {
              push @tokens => @t;
          }
          elsif (/\G\s+/mgco) {
              # pass through
              $class->_skip_whitespace();
          }
          else {
              $class->_syntax_error();
          }
      }
      return @tokens;
  }
  
  sub _tokenize_key_and_value {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
  
      my @tokens;
      if (/\G$grammar_regexp->{key}/mgc) {
          my $key = $1 || $2 || $3;
          warn "[TOKEN] KEY: $key" if DEBUG;
          $class->_skip_whitespace();
          push @tokens => [TOKEN_KEY, $key];
          push @tokens => $class->_tokenize_value();
          return @tokens;
      }
  
      return;
  }
  
  sub _tokenize_value {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
      warn "[CALL] _tokenize_value" if DEBUG;
  
      if (/\G$grammar_regexp->{comment}/mgc) {
          warn "[TOKEN] COMMENT: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_COMMENT, $1 || ''];
      }
      elsif (/\G$grammar_regexp->{value}->{datetime}/mgc) {
          warn "[TOKEN] DATETIME: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_DATETIME, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{float}/mgc) {
          warn "[TOKEN] FLOAT: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_FLOAT, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{integer}/mgc) {
          warn "[TOKEN] INTEGER: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_INTEGER, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{boolean}/mgc) {
          warn "[TOKEN] BOOLEAN: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_BOOLEAN, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{mlstring}/mgc) {
          warn "[TOKEN] MULTI LINE STRING: $1" if DEBUG;
          return (
              [TOKEN_MULTI_LINE_STRING_BEGIN],
              $class->_extract_multi_line_string($1),
              [TOKEN_MULTI_LINE_STRING_END],
          );
      }
      elsif (/\G$grammar_regexp->{value}->{string}/mgc) {
          warn "[TOKEN] STRING: $1" if DEBUG;
          $class->_skip_whitespace();
  
          my $is_raw = defined $2;
          return [TOKEN_STRING, defined $1 ? $1 : defined $2 ? $2 : '', $is_raw];
      }
      elsif (/\G$grammar_regexp->{value}->{inline}->{start}/mgc) {
          warn "[TOKEN] INLINE TABLE" if DEBUG;
          $class->_skip_whitespace();
          return (
              [TOKEN_INLINE_TABLE_BEGIN],
              $class->_tokenize_inline_table(),
              [TOKEN_INLINE_TABLE_END],
          );
      }
      elsif (/\G$grammar_regexp->{value}->{array}->{start}/mgc) {
          warn "[TOKEN] ARRAY" if DEBUG;
          $class->_skip_whitespace();
          return (
              [TOKEN_ARRAY_BEGIN],
              $class->_tokenize_array(),
              [TOKEN_ARRAY_END],
          );
      }
  
      $class->_syntax_error();
  }
  
  sub _tokenize_table {
      my $class = shift;
  
      my $grammar_regexp = $class->grammar_regexp()->{table};
      warn "[CALL] _tokenize_table" if DEBUG;
  
      $class->_skip_whitespace();
  
      my @expected = ($grammar_regexp->{key});
  
      my @keys;
   LOOP:
      while (1) {
          for my $rx (@expected) {
              if (/\G$rx/smgc) {
                  if ($rx eq $grammar_regexp->{key}) {
                      my $key = $1 || $2 || $3;
                      warn "[TOKEN] table key: $key" if DEBUG;
                      push @keys => $key;
                      @expected = ($grammar_regexp->{sep}, $grammar_regexp->{end});
                  }
                  elsif ($rx eq $grammar_regexp->{sep}) {
                      warn "[TOKEN] table key separator" if DEBUG;
                      @expected = ($grammar_regexp->{key});
                  }
                  elsif ($rx eq $grammar_regexp->{end}) {
                      warn "[TOKEN] table key end" if DEBUG;
                      @expected = ();
                      last LOOP;
                  }
                  $class->_skip_whitespace();
                  next LOOP;
              }
          }
  
          $class->_syntax_error();
      }
  
      warn "[TOKEN] TABLE: @{[ join '.', @keys ]}" if DEBUG;
      return [TOKEN_TABLE, \@keys];
  }
  
  sub _tokenize_array_of_table {
      my $class = shift;
  
      my $grammar_regexp = $class->grammar_regexp()->{array_of_table};
      warn "[CALL] _tokenize_array_of_table" if DEBUG;
  
      $class->_skip_whitespace();
  
      my @expected = ($grammar_regexp->{key});
  
      my @keys;
   LOOP:
      while (1) {
          for my $rx (@expected) {
              if (/\G$rx/smgc) {
                  if ($rx eq $grammar_regexp->{key}) {
                      my $key = $1 || $2 || $3;
                      warn "[TOKEN] table key: $key" if DEBUG;
                      push @keys => $key;
                      @expected = ($grammar_regexp->{sep}, $grammar_regexp->{end});
                  }
                  elsif ($rx eq $grammar_regexp->{sep}) {
                      warn "[TOKEN] table key separator" if DEBUG;
                      @expected = ($grammar_regexp->{key});
                  }
                  elsif ($rx eq $grammar_regexp->{end}) {
                      warn "[TOKEN] table key end" if DEBUG;
                      @expected = ();
                      last LOOP;
                  }
                  $class->_skip_whitespace();
                  next LOOP;
              }
          }
  
          $class->_syntax_error();
      }
  
      warn "[TOKEN] ARRAY_OF_TABLE: @{[ join '.', @keys ]}" if DEBUG;
      return [TOKEN_ARRAY_OF_TABLE, \@keys];
  }
  
  sub _extract_multi_line_string {
      my ($class, $delimiter) = @_;
      my $is_raw = $delimiter eq q{'''};
      if (/\G(.+?)\Q$delimiter/smgc) {
          warn "[TOKEN] MULTI LINE STRING: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_STRING, $1, $is_raw];
      }
      $class->_syntax_error();
  }
  
  sub _tokenize_inline_table {
      my $class = shift;
  
      my $common_grammar_regexp = $class->grammar_regexp();
      my $grammar_regexp = $common_grammar_regexp->{value}->{inline};
  
      warn "[CALL] _tokenize_inline_table" if DEBUG;
      return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;
  
      my $need_sep = 0;
  
      my @tokens;
      while (1) {
          warn "[CONTEXT] _tokenize_inline_table [loop]" if DEBUG;
  
          $class->_skip_whitespace();
          if (/\G$common_grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              push @tokens => [TOKEN_COMMENT, $1 || ''];
              next;
          }
          elsif (/\G$grammar_regexp->{end}/mgc) {
              last;
          }
  
          if ($need_sep) {
              if (/\G$grammar_regexp->{sep}/smgc) {
                  $need_sep = 0;
                  next;
              }
          }
          else {
              if (my @t = $class->_tokenize_key_and_value()) {
                  push @tokens => @t;
                  $need_sep = 1;
                  next;
              }
          }
  
          $class->_syntax_error();
      }
  
      return @tokens;
  }
  
  sub _tokenize_array {
      my $class = shift;
  
      my $common_grammar_regexp = $class->grammar_regexp();
      my $grammar_regexp = $common_grammar_regexp->{value}->{array};
  
      warn "[CALL] _tokenize_array" if DEBUG;
      return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;
  
      my $need_sep = 0;
  
      my @tokens;
      while (1) {
          warn "[CONTEXT] _tokenize_inline_table [loop]" if DEBUG;
  
          $class->_skip_whitespace();
          if (/\G$common_grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              push @tokens => [TOKEN_COMMENT, $1 || ''];
              next;
          }
          elsif (/\G$grammar_regexp->{end}/mgc) {
              last;
          }
  
          if ($need_sep) {
              if (/\G$grammar_regexp->{sep}/smgc) {
                  $need_sep = 0;
                  next;
              }
          }
          else {
              if (my @t = $class->_tokenize_value()) {
                  push @tokens => @t;
                  $need_sep = 1;
                  next;
              }
          }
  
          $class->_syntax_error();
      }
  
      return @tokens;
  }
  
  sub _skip_whitespace {
      my $class = shift;
      if (/\G\s+/smgco) {
          # pass through
          warn "[PASS] WHITESPACE" if DEBUG;
      }
  }
  
  sub _syntax_error { shift->_error('Syntax Error') }
  
  sub _error {
      my ($class, $msg) = @_;
  
      my $src   = $_;
      my $curr  = pos || 0;
      my $line  = 1;
      my $start = pos $src || 0;
      while ($src =~ /$/smgco and pos $src <= $curr) {
          $start = pos $src;
          $line++;
      }
      my $end = pos $src;
      my $len = $curr - $start;
      $len-- if $len > 0;
  
      my $trace = join "\n",
          "${msg}: line:$line",
          substr($src, $start || 0, $end - $start),
          (' ' x $len) . '^';
      die $trace, "\n";
  }
  
  1;
  __END__
TOML_PARSER_TOKENIZER

$fatpacked{"TOML/Parser/Tokenizer/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER_STRICT';
  package TOML::Parser::Tokenizer::Strict;
  use 5.010000;
  use strict;
  use warnings;
  
  use parent qw/TOML::Parser::Tokenizer/;
  BEGIN { import TOML::Parser::Tokenizer qw/:constant/ }
  
  sub grammar_regexp {
      my $grammar_regexp = {%{ shift->SUPER::grammar_regexp() }};
      $grammar_regexp->{table}                 = {%{ $grammar_regexp->{table} }};
      $grammar_regexp->{array_of_table}        = {%{ $grammar_regexp->{array_of_table} }};
      $grammar_regexp->{table}->{key}          = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))};
      $grammar_regexp->{array_of_table}->{key} = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))};
      $grammar_regexp->{key}                   = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))\s*=};
      return $grammar_regexp;
  }
  
  1;
  __END__
TOML_PARSER_TOKENIZER_STRICT

$fatpacked{"TOML/Parser/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_UTIL';
  package TOML::Parser::Util;
  use 5.008005;
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw/unescape_str/;
  
  sub unescape_str {
      my $str = shift;
  
      $str =~ s!\\b !\x08!xmgo;      # backspace       (U+0008)
      $str =~ s!\\t !\x09!xmgo;      # tab             (U+0009)
      $str =~ s!\\n !\x0A!xmgo;      # linefeed        (U+000A)
      $str =~ s!\\f !\x0C!xmgo;      # form feed       (U+000C)
      $str =~ s!\\r !\x0D!xmgo;      # carriage return (U+000D)
      $str =~ s!\\" !\x22!xmgo;      # quote           (U+0022)
      $str =~ s!\\/ !\x2F!xmgo;      # slash           (U+002F)
      $str =~ s!\\\\!\x5C!xmgo;      # backslash       (U+005C)
      $str =~ s{\\u([0-9A-Fa-f]{4})}{# unicode         (U+XXXX)
          chr hex $1
      }xmgeo;
      $str =~ s{\\U([0-9A-Fa-f]{8})}{# unicode         (U+XXXXXXXX)
          chr hex $1
      }xmgeo;
  
      return $str;
  }
  
  1;
  __END__
TOML_PARSER_UTIL

$fatpacked{"Test/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TYPETINY';
  package Test::TypeTiny;
  
  use strict;
  use warnings;
  
  use Test::More qw();
  use Scalar::Util qw(blessed);
  use Types::TypeTiny qw(to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN {
  	*EXTENDED_TESTING = $ENV{EXTENDED_TESTING} ? sub(){!!1} : sub(){!!0};
  };
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.002001';
  our @EXPORT    = qw( should_pass should_fail ok_subtype );
  our @EXPORT_OK = qw( EXTENDED_TESTING matchfor );
  
  sub matchfor
  {
  	my @matchers = @_;
  	bless \@matchers, do {
  		package #
  		Test::TypeTiny::Internal::MATCHFOR;
  		use overload
  			q[==] => 'match',
  			q[eq] => 'match',
  			q[""] => 'to_string',
  			fallback => 1;
  		sub to_string {
  			$_[0][0]
  		}
  		sub match {
  			my ($self, $e) = @_;
  			my $does = Scalar::Util::blessed($e) ? ($e->can('DOES') || $e->can('isa')) : undef;
  			for my $s (@$self) {
  				return 1 if  ref($s) && $e =~ $s;
  				return 1 if !ref($s) && $does && $e->$does($s);
  			}
  			return;
  		}
  		__PACKAGE__;
  	};
  }
  
  sub _mk_message
  {
  	require Type::Tiny;
  	my ($template, $value) = @_;
  	sprintf($template, Type::Tiny::_dd($value));
  }
  
  sub ok_subtype
  {
  	my ($type, @s) = @_;
  	@_ = (
  		not(scalar grep !$_->is_subtype_of($type), @s),
  		sprintf("%s subtype: %s", $type, join q[, ], @s),
  	);
  	goto \&Test::More::ok;
  }
  
  eval(EXTENDED_TESTING ? <<'SLOW' : <<'FAST');
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!!$type->check($value), '->check');
  	$test->ok(!!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	
  	local $Test::Builder::Level = $Test::Builder::Level + 1;
  	
  	my $strictures = $type->can("_strict_check");
  	
  	my $test = "Test::Builder"->new->child(
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	$test->plan(tests => ($strictures ? 2 : 1));
  	$test->ok(!$type->check($value), '->check');
  	$test->ok(!$type->_strict_check($value), '->_strict_check') if $strictures;
  	$test->finalize;
  	return $test->is_passing;
  }
  
  SLOW
  
  sub should_pass
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!!$type->check($value),
  		$message || _mk_message("%s passes type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  sub should_fail
  {
  	my ($value, $type, $message) = @_;
  	$type = to_TypeTiny($type) unless blessed($type) && $type->can("check");
  	@_ = (
  		!$type->check($value),
  		$message || _mk_message("%s fails type constraint $type", $value),
  	);
  	goto \&Test::More::ok;
  }
  
  FAST
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Test::TypeTiny - useful functions for testing the efficacy of type constraints
  
  =head1 SYNOPSIS
  
  =for test_synopsis
  BEGIN { die "SKIP: uses a module that doesn't exist as an example" };
  
     use strict;
     use warnings;
     use Test::More;
     use Test::TypeTiny;
     
     use Types::Mine qw(Integer Number);
     
     should_pass(1, Integer);
     should_pass(-1, Integer);
     should_pass(0, Integer);
     should_fail(2.5, Integer);
     
     ok_subtype(Number, Integer);
     
     done_testing;
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Test::TypeTiny> provides a few handy functions for testing type constraints.
  
  =head2 Functions
  
  =over
  
  =item C<< should_pass($value, $type, $test_name) >>
  
  =item C<< should_pass($value, $type) >>
  
  Test that passes iff C<< $value >> passes C<< $type->check >>.
  
  =item C<< should_fail($value, $type, $test_name) >>
  
  =item C<< should_fail($value, $type) >>
  
  Test that passes iff C<< $value >> fails C<< $type->check >>.
  
  =item C<< ok_subtype($type, @subtypes) >>
  
  Test that passes iff all C<< @subtypes >> are subtypes of C<< $type >>.
  
  =item C<< EXTENDED_TESTING >>
  
  Exportable boolean constant.
  
  =item C<< matchfor(@things) >>
  
  Assistant for matching exceptions. Not exported by default.
  See also L<Test::Fatal::matchfor>.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the C<EXTENDED_TESTING> environment variable is set to true, this
  module will promote each C<should_pass> or C<should_fail> test into a
  subtest block and test the type constraint in both an inlined and
  non-inlined manner.
  
  This variable must be set at compile time (i.e. before this module is
  loaded).
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  For an alternative to C<should_pass>, see L<Test::Deep::Type> which will
  happily accept a Type::Tiny type constraint instead of a MooseX::Types one.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TEST_TYPETINY

$fatpacked{"Text/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF';
  package Text::Diff;
  
  use 5.006;
  use strict;
  use warnings;
  use Carp            qw/ croak confess /;
  use Exporter        ();
  use Algorithm::Diff ();
  
  our $VERSION = '1.45';
  our @ISA     = qw/ Exporter /;
  our @EXPORT  = qw/ diff /;
  
  ## Hunks are made of ops.  An op is the starting index for each
  ## sequence and the opcode:
  use constant A       => 0;   # Array index before match/discard
  use constant B       => 1;
  use constant OPCODE  => 2;   # "-", " ", "+"
  use constant FLAG    => 3;   # What to display if not OPCODE "!"
  
  my %internal_styles = (
      Unified  => undef,
      Context  => undef,
      OldStyle => undef,
      Table    => undef,   ## "internal", but in another module
  );
  
  sub diff {
      my @seqs    = ( shift, shift );
      my $options = shift || {};
  
      for my $i ( 0 .. 1 ) {
          my $seq = $seqs[$i];
          my $type = ref $seq;
  
          while ( $type eq "CODE" ) {
              $seqs[$i] = $seq = $seq->( $options );
              $type = ref $seq;
          }
  
          my $AorB = !$i ? "A" : "B";
  
          if ( $type eq "ARRAY" ) {
              ## This is most efficient :)
              $options->{"OFFSET_$AorB"} = 0
                  unless defined $options->{"OFFSET_$AorB"};
          }
          elsif ( $type eq "SCALAR" ) {
              $seqs[$i] = [split( /^/m, $$seq )];
              $options->{"OFFSET_$AorB"} = 1
                  unless defined $options->{"OFFSET_$AorB"};
          }
          elsif ( ! $type ) {
              $options->{"OFFSET_$AorB"} = 1
                  unless defined $options->{"OFFSET_$AorB"};
              $options->{"FILENAME_$AorB"} = $seq
                  unless defined $options->{"FILENAME_$AorB"};
              $options->{"MTIME_$AorB"} = (stat($seq))[9]
                  unless defined $options->{"MTIME_$AorB"};
  
              local $/ = "\n";
              open F, "<$seq" or croak "$!: $seq";
              $seqs[$i] = [<F>];
              close F;
  
          }
          elsif ( $type eq "GLOB" || UNIVERSAL::isa( $seq, "IO::Handle" ) ) {
              $options->{"OFFSET_$AorB"} = 1
                  unless defined $options->{"OFFSET_$AorB"};
              local $/ = "\n";
              $seqs[$i] = [<$seq>];
          }
          else {
              confess "Can't handle input of type ", ref;
          }
      }
  
      ## Config vars
      my $output;
      my $output_handler = $options->{OUTPUT};
      my $type = ref $output_handler ;
      if ( ! defined $output_handler ) {
          $output = "";
          $output_handler = sub { $output .= shift };
      }
      elsif ( $type eq "CODE" ) {
          ## No problems, mate.
      }
      elsif ( $type eq "SCALAR" ) {
          my $out_ref = $output_handler;
          $output_handler = sub { $$out_ref .= shift };
      }
      elsif ( $type eq "ARRAY" ) {
          my $out_ref = $output_handler;
          $output_handler = sub { push @$out_ref, shift };
      }
      elsif ( $type eq "GLOB" || UNIVERSAL::isa $output_handler, "IO::Handle" ) {
          my $output_handle = $output_handler;
          $output_handler = sub { print $output_handle shift };
      }
      else {
          croak "Unrecognized output type: $type";
      }
  
      my $style  = $options->{STYLE};
      $style = "Unified" unless defined $options->{STYLE};
      $style = "Text::Diff::$style" if exists $internal_styles{$style};
  
      if ( ! $style->can( "hunk" ) ) {
          eval "require $style; 1" or die $@;
      }
  
      $style = $style->new if ! ref $style && $style->can( "new" );
  
      my $ctx_lines = $options->{CONTEXT};
      $ctx_lines = 3 unless defined $ctx_lines;
      $ctx_lines = 0 if $style->isa( "Text::Diff::OldStyle" );
  
      my @keygen_args = $options->{KEYGEN_ARGS}
          ? @{$options->{KEYGEN_ARGS}}
          : ();
  
      ## State vars
      my $diffs = 0; ## Number of discards this hunk
      my $ctx   = 0; ## Number of " " (ctx_lines) ops pushed after last diff.
      my @ops;       ## ops (" ", +, -) in this hunk
      my $hunks = 0; ## Number of hunks
  
      my $emit_ops = sub {
          $output_handler->( $style->file_header( @seqs,     $options ) )
              unless $hunks++;
          $output_handler->( $style->hunk_header( @seqs, @_, $options ) );
          $output_handler->( $style->hunk       ( @seqs, @_, $options ) );
          $output_handler->( $style->hunk_footer( @seqs, @_, $options ) );
      };
  
      ## We keep 2*ctx_lines so that if a diff occurs
      ## at 2*ctx_lines we continue to grow the hunk instead
      ## of emitting diffs and context as we go. We
      ## need to know the total length of both of the two
      ## subsequences so the line count can be printed in the
      ## header.
      my $dis_a = sub {push @ops, [@_[0,1],"-"]; ++$diffs ; $ctx = 0 };
      my $dis_b = sub {push @ops, [@_[0,1],"+"]; ++$diffs ; $ctx = 0 };
  
      Algorithm::Diff::traverse_sequences(
          @seqs,
          {
              MATCH => sub {
                  push @ops, [@_[0,1]," "];
  
                  if ( $diffs && ++$ctx > $ctx_lines * 2 ) {
                      $emit_ops->( [ splice @ops, 0, $#ops - $ctx_lines ] );
                      $ctx = $diffs = 0;
                  }
  
                  ## throw away context lines that aren't needed any more
                  shift @ops if ! $diffs && @ops > $ctx_lines;
              },
              DISCARD_A => $dis_a,
              DISCARD_B => $dis_b,
          },
          $options->{KEYGEN},  # pass in user arguments for key gen function
          @keygen_args,
      );
  
      if ( $diffs ) {
          $#ops -= $ctx - $ctx_lines if $ctx > $ctx_lines;
          $emit_ops->( \@ops );
      }
  
      $output_handler->( $style->file_footer( @seqs, $options ) ) if $hunks;
  
      return defined $output ? $output : $hunks;
  }
  
  sub _header {
      my ( $h ) = @_;
      my ( $p1, $fn1, $t1, $p2, $fn2, $t2 ) = @{$h}{
          "FILENAME_PREFIX_A",
          "FILENAME_A",
          "MTIME_A",
          "FILENAME_PREFIX_B",
          "FILENAME_B",
          "MTIME_B"
      };
  
      ## remember to change Text::Diff::Table if this logic is tweaked.
      return "" unless defined $fn1 && defined $fn2;
  
      return join( "",
          $p1, " ", $fn1, defined $t1 ? "\t" . localtime $t1 : (), "\n",
          $p2, " ", $fn2, defined $t2 ? "\t" . localtime $t2 : (), "\n",
      );
  }
  
  ## _range encapsulates the building of, well, ranges.  Turns out there are
  ## a few nuances.
  sub _range {
      my ( $ops, $a_or_b, $format ) = @_;
  
      my $start = $ops->[ 0]->[$a_or_b];
      my $after = $ops->[-1]->[$a_or_b];
  
      ## The sequence indexes in the lines are from *before* the OPCODE is
      ## executed, so we bump the last index up unless the OP indicates
      ## it didn't change.
      ++$after
          unless $ops->[-1]->[OPCODE] eq ( $a_or_b == A ? "+" : "-" );
  
      ## convert from 0..n index to 1..(n+1) line number.  The unless modifier
      ## handles diffs with no context, where only one file is affected.  In this
      ## case $start == $after indicates an empty range, and the $start must
      ## not be incremented.
      my $empty_range = $start == $after;
      ++$start unless $empty_range;
  
      return
          $start == $after
              ? $format eq "unified" && $empty_range
                  ? "$start,0"
                  : $start
              : $format eq "unified"
                  ? "$start,".($after-$start+1)
                  : "$start,$after";
  }
  
  sub _op_to_line {
      my ( $seqs, $op, $a_or_b, $op_prefixes ) = @_;
  
      my $opcode = $op->[OPCODE];
      return () unless defined $op_prefixes->{$opcode};
  
      my $op_sym = defined $op->[FLAG] ? $op->[FLAG] : $opcode;
      $op_sym = $op_prefixes->{$op_sym};
      return () unless defined $op_sym;
  
      $a_or_b = $op->[OPCODE] ne "+" ? 0 : 1 unless defined $a_or_b;
      my @line = ( $op_sym, $seqs->[$a_or_b][$op->[$a_or_b]] );
      unless ( $line[1] =~ /(?:\n|\r\n)$/ ) {
          $line[1] .= "\n\\ No newline at end of file\n";
      }
      return @line;
  }
  
  SCOPE: {
      package Text::Diff::Base;
  
      sub new         {
          my $proto = shift;
          return bless { @_ }, ref $proto || $proto;
      }
  
      sub file_header { return "" }
  
      sub hunk_header { return "" }
  
      sub hunk        { return "" }
  
      sub hunk_footer { return "" }
  
      sub file_footer { return "" }
  }
  
  @Text::Diff::Unified::ISA = qw( Text::Diff::Base );
  
  sub Text::Diff::Unified::file_header {
      shift; ## No instance data
      my $options = pop ;
  
      _header(
          { FILENAME_PREFIX_A => "---", FILENAME_PREFIX_B => "+++", %$options }
      );
  }
  
  sub Text::Diff::Unified::hunk_header {
      shift; ## No instance data
      pop; ## Ignore options
      my $ops = pop;
  
      return join( "",
          "@@ -",
          _range( $ops, A, "unified" ),
          " +",
          _range( $ops, B, "unified" ),
          " @@\n",
      );
  }
  
  sub Text::Diff::Unified::hunk {
      shift; ## No instance data
      pop; ## Ignore options
      my $ops = pop;
  
      my $prefixes = { "+" => "+", " " => " ", "-" => "-" };
  
      return join "", map _op_to_line( \@_, $_, undef, $prefixes ), @$ops
  }
  
  @Text::Diff::Context::ISA = qw( Text::Diff::Base );
  
  sub Text::Diff::Context::file_header {
      _header { FILENAME_PREFIX_A=>"***", FILENAME_PREFIX_B=>"---", %{$_[-1]} };
  }
  
  sub Text::Diff::Context::hunk_header {
      return "***************\n";
  }
  
  sub Text::Diff::Context::hunk {
      shift; ## No instance data
      pop; ## Ignore options
      my $ops = pop;
      ## Leave the sequences in @_[0,1]
  
      my $a_range = _range( $ops, A, "" );
      my $b_range = _range( $ops, B, "" );
  
      ## Sigh.  Gotta make sure that differences that aren't adds/deletions
      ## get prefixed with "!", and that the old opcodes are removed.
      my $after;
      for ( my $start = 0; $start <= $#$ops ; $start = $after ) {
          ## Scan until next difference
          $after = $start + 1;
          my $opcode = $ops->[$start]->[OPCODE];
          next if $opcode eq " ";
  
          my $bang_it;
          while ( $after <= $#$ops && $ops->[$after]->[OPCODE] ne " " ) {
              $bang_it ||= $ops->[$after]->[OPCODE] ne $opcode;
              ++$after;
          }
  
          if ( $bang_it ) {
              for my $i ( $start..($after-1) ) {
                  $ops->[$i]->[FLAG] = "!";
              }
          }
      }
  
      my $b_prefixes = { "+" => "+ ",  " " => "  ", "-" => undef, "!" => "! " };
      my $a_prefixes = { "+" => undef, " " => "  ", "-" => "- ",  "!" => "! " };
  
      return join( "",
          "*** ", $a_range, " ****\n",
          map( _op_to_line( \@_, $_, A, $a_prefixes ), @$ops ),
          "--- ", $b_range, " ----\n",
          map( _op_to_line( \@_, $_, B, $b_prefixes ), @$ops ),
      );
  }
  
  @Text::Diff::OldStyle::ISA = qw( Text::Diff::Base );
  
  sub _op {
      my $ops = shift;
      my $op = $ops->[0]->[OPCODE];
      $op = "c" if grep $_->[OPCODE] ne $op, @$ops;
      $op = "a" if $op eq "+";
      $op = "d" if $op eq "-";
      return $op;
  }
  
  sub Text::Diff::OldStyle::hunk_header {
      shift; ## No instance data
      pop; ## ignore options
      my $ops = pop;
  
      my $op = _op $ops;
  
      return join "", _range( $ops, A, "" ), $op, _range( $ops, B, "" ), "\n";
  }
  
  sub Text::Diff::OldStyle::hunk {
      shift; ## No instance data
      pop; ## ignore options
      my $ops = pop;
      ## Leave the sequences in @_[0,1]
  
      my $a_prefixes = { "+" => undef,  " " => undef, "-" => "< "  };
      my $b_prefixes = { "+" => "> ",   " " => undef, "-" => undef };
  
      my $op = _op $ops;
  
      return join( "",
          map( _op_to_line( \@_, $_, A, $a_prefixes ), @$ops ),
          $op eq "c" ? "---\n" : (),
          map( _op_to_line( \@_, $_, B, $b_prefixes ), @$ops ),
      );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Text::Diff - Perform diffs on files and record sets
  
  =head1 SYNOPSIS
  
      use Text::Diff;
  
      ## Mix and match filenames, strings, file handles, producer subs,
      ## or arrays of records; returns diff in a string.
      ## WARNING: can return B<large> diffs for large files.
      my $diff = diff "file1.txt", "file2.txt", { STYLE => "Context" };
      my $diff = diff \$string1,   \$string2,   \%options;
      my $diff = diff \*FH1,       \*FH2;
      my $diff = diff \&reader1,   \&reader2;
      my $diff = diff \@records1,  \@records2;
  
      ## May also mix input types:
      my $diff = diff \@records1,  "file_B.txt";
  
  =head1 DESCRIPTION
  
  C<diff()> provides a basic set of services akin to the GNU C<diff> utility.  It
  is not anywhere near as feature complete as GNU C<diff>, but it is better
  integrated with Perl and available on all platforms.  It is often faster than
  shelling out to a system's C<diff> executable for small files, and generally
  slower on larger files.
  
  Relies on L<Algorithm::Diff> for, well, the algorithm.  This may not produce
  the same exact diff as a system's local C<diff> executable, but it will be a
  valid diff and comprehensible by C<patch>.  We haven't seen any differences
  between L<Algorithm::Diff>'s logic and GNU C<diff>'s, but we have not examined
  them to make sure they are indeed identical.
  
  B<Note>: If you don't want to import the C<diff> function, do one of the
  following:
  
     use Text::Diff ();
  
     require Text::Diff;
  
  That's a pretty rare occurrence,
  so C<diff()> is exported by default.
  
  If you pass a filename, but the file can't be read,
  then C<diff()> will C<croak>.
  
  =head1 OPTIONS
  
  C<diff()> takes two parameters from which to draw input and a set of
  options to control its output.  The options are:
  
  =over
  
  =item FILENAME_A, MTIME_A, FILENAME_B, MTIME_B
  
  The name of the file and the modification time "files".
  
  These are filled in automatically for each file when C<diff()> is passed a
  filename, unless a defined value is passed in.
  
  If a filename is not passed in and FILENAME_A and FILENAME_B are not provided
  or are C<undef>, the header will not be printed.
  
  Unused on C<OldStyle> diffs.
  
  =item OFFSET_A, OFFSET_B
  
  The index of the first line / element.  These default to 1 for all
  parameter types except ARRAY references, for which the default is 0.  This
  is because ARRAY references are presumed to be data structures, while the
  others are line-oriented text.
  
  =item STYLE
  
  "Unified", "Context", "OldStyle", or an object or class reference for a class
  providing C<file_header()>, C<hunk_header()>, C<hunk()>, C<hunk_footer()> and
  C<file_footer()> methods.  The two footer() methods are provided for
  overloading only; none of the formats provide them.
  
  Defaults to "Unified" (unlike standard C<diff>, but Unified is what's most
  often used in submitting patches and is the most human readable of the three.
  
  If the package indicated by the STYLE has no C<hunk()> method, C<diff()> will
  load it automatically (lazy loading).  Since all such packages should inherit
  from C<Text::Diff::Base>, this should be marvy.
  
  Styles may be specified as class names (C<STYLE =E<gt> 'Foo'>),
  in which case they will be C<new()>ed with no parameters,
  or as objects (C<STYLE =E<gt> Foo-E<gt>new>).
  
  =item CONTEXT
  
  How many lines before and after each diff to display.  Ignored on old-style
  diffs.  Defaults to 3.
  
  =item OUTPUT
  
  Examples and their equivalent subroutines:
  
      OUTPUT   => \*FOOHANDLE,   # like: sub { print FOOHANDLE shift() }
      OUTPUT   => \$output,      # like: sub { $output .= shift }
      OUTPUT   => \@output,      # like: sub { push @output, shift }
      OUTPUT   => sub { $output .= shift },
  
  If no C<OUTPUT> is supplied, returns the diffs in a string.  If
  C<OUTPUT> is a C<CODE> ref, it will be called once with the (optional)
  file header, and once for each hunk body with the text to emit.  If
  C<OUTPUT> is an L<IO::Handle>, output will be emitted to that handle.
  
  =item FILENAME_PREFIX_A, FILENAME_PREFIX_B
  
  The string to print before the filename in the header. Unused on C<OldStyle>
  diffs.  Defaults are C<"---">, C<"+++"> for Unified and C<"***">, C<"+++"> for
  Context.
  
  =item KEYGEN, KEYGEN_ARGS
  
  These are passed to L<Algorithm::Diff/traverse_sequences>.
  
  =back
  
  B<Note>: if neither C<FILENAME_> option is defined, the header will not be
  printed.  If at least one is present, the other and both C<MTIME_> options must
  be present or "Use of undefined variable" warnings will be generated (except
  on C<OldStyle> diffs, which ignores these options).
  
  =head1 Formatting Classes
  
  These functions implement the output formats.  They are grouped in to classes
  so C<diff()> can use class names to call the correct set of output routines and
  so that you may inherit from them easily.  There are no constructors or
  instance methods for these classes, though subclasses may provide them if need
  be.
  
  Each class has C<file_header()>, C<hunk_header()>, C<hunk()>, and C<footer()>
  methods identical to those documented in the C<Text::Diff::Unified> section.
  C<header()> is called before the C<hunk()> is first called, C<footer()>
  afterwards.  The default footer function is an empty method provided for
  overloading:
  
      sub footer { return "End of patch\n" }
  
  Some output formats are provided by external modules (which are loaded
  automatically), such as L<Text::Diff::Table>.  These are
  are documented here to keep the documentation simple.
  
  =head2 Text::Diff::Base
  
  Returns "" for all methods (other than C<new()>).
  
  =head2 Text::Diff::Unified
  
    --- A   Mon Nov 12 23:49:30 2001
    +++ B   Mon Nov 12 23:49:30 2001
    @@ -2,13 +2,13 @@
     2
     3
     4
    -5d
    +5a
     6
     7
     8
     9
    +9a
     10
     11
    -11d
     12
     13
  
  =over
  
  =item Text::Diff::Unified::file_header
  
    $s = Text::Diff::Unified->file_header( $options );
  
  Returns a string containing a unified header.  The sole parameter is the
  C<options> hash passed in to C<diff()>, containing at least:
  
    FILENAME_A  => $fn1,
    MTIME_A     => $mtime1,
    FILENAME_B  => $fn2,
    MTIME_B     => $mtime2
  
  May also contain
  
    FILENAME_PREFIX_A    => "---",
    FILENAME_PREFIX_B    => "+++",
  
  to override the default prefixes (default values shown).
  
  =item Text::Diff::Unified::hunk_header
  
    Text::Diff::Unified->hunk_header( \@ops, $options );
  
  Returns a string containing the heading of one hunk of unified diff.
  
  =item Text::Diff::Unified::hunk
  
    Text::Diff::Unified->hunk( \@seq_a, \@seq_b, \@ops, $options );
  
  Returns a string containing the output of one hunk of unified diff.
  
  =back
  
  =head2 Text::Diff::Table
  
    +--+----------------------------------+--+------------------------------+
    |  |../Test-Differences-0.2/MANIFEST  |  |../Test-Differences/MANIFEST  |
    |  |Thu Dec 13 15:38:49 2001          |  |Sat Dec 15 02:09:44 2001      |
    +--+----------------------------------+--+------------------------------+
    |  |                                  * 1|Changes                       *
    | 1|Differences.pm                    | 2|Differences.pm                |
    | 2|MANIFEST                          | 3|MANIFEST                      |
    |  |                                  * 4|MANIFEST.SKIP                 *
    | 3|Makefile.PL                       | 5|Makefile.PL                   |
    |  |                                  * 6|t/00escape.t                  *
    | 4|t/00flatten.t                     | 7|t/00flatten.t                 |
    | 5|t/01text_vs_data.t                | 8|t/01text_vs_data.t            |
    | 6|t/10test.t                        | 9|t/10test.t                    |
    +--+----------------------------------+--+------------------------------+
  
  This format also goes to some pains to highlight "invisible" characters on
  differing elements by selectively escaping whitespace:
  
    +--+--------------------------+--------------------------+
    |  |demo_ws_A.txt             |demo_ws_B.txt             |
    |  |Fri Dec 21 08:36:32 2001  |Fri Dec 21 08:36:50 2001  |
    +--+--------------------------+--------------------------+
    | 1|identical                 |identical                 |
    * 2|        spaced in         |        also spaced in    *
    * 3|embedded space            |embedded        tab       *
    | 4|identical                 |identical                 |
    * 5|        spaced in         |\ttabbed in               *
    * 6|trailing spaces\s\s\n     |trailing tabs\t\t\n       *
    | 7|identical                 |identical                 |
    * 8|lf line\n                 |crlf line\r\n             *
    * 9|embedded ws               |embedded\tws              *
    +--+--------------------------+--------------------------+
  
  See L<Text::Diff::Table> for more details, including how the whitespace
  escaping works.
  
  =head2 Text::Diff::Context
  
      *** A   Mon Nov 12 23:49:30 2001
      --- B   Mon Nov 12 23:49:30 2001
      ***************
      *** 2,14 ****
        2
        3
        4
      ! 5d
        6
        7
        8
        9
        10
        11
      - 11d
        12
        13
      --- 2,14 ----
        2
        3
        4
      ! 5a
        6
        7
        8
        9
      + 9a
        10
        11
        12
        13
  
  Note: C<hunk_header()> returns only "***************\n".
  
  =head2 Text::Diff::OldStyle
  
      5c5
      < 5d
      ---
      > 5a
      9a10
      > 9a
      12d12
      < 11d
  
  Note: no C<file_header()>.
  
  =head1 LIMITATIONS
  
  Must suck both input files entirely in to memory and store them with a normal
  amount of Perlish overhead (one array location) per record.  This is implied by
  the implementation of L<Algorithm::Diff>, which takes two arrays.  If
  L<Algorithm::Diff> ever offers an incremental mode, this can be changed
  (contact the maintainers of L<Algorithm::Diff> and C<Text::Diff> if you need
  this; it shouldn't be too terribly hard to tie arrays in this fashion).
  
  Does not provide most of the more refined GNU C<diff> options: recursive
  directory tree scanning, ignoring blank lines / whitespace, etc., etc.  These
  can all be added as time permits and need arises, many are rather easy; patches
  quite welcome.
  
  Uses closures internally, this may lead to leaks on Perl versions 5.6.1 and
  prior if used many times over a process' life time.
  
  =head1 SEE ALSO
  
  L<Algorithm::Diff> - the underlying implementation of the diff algorithm
  used by C<Text::Diff>.
  
  L<YAML::Diff> - find difference between two YAML documents.
  
  L<HTML::Differences> - find difference between two HTML documents.
  This uses a more sane approach than L<HTML::Diff>.
  
  L<XML::Diff> - find difference between two XML documents.
  
  L<Array::Diff> - find the differences between two Perl arrays.
  
  L<Hash::Diff> - find the differences between two Perl hashes.
  
  L<Data::Diff> - find difference between two arbitrary data structures.
  
  =head1 REPOSITORY
  
  L<https://github.com/neilbowers/Text-Diff>
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Barrie Slaymaker E<lt>barries@slaysys.comE<gt>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2009 Adam Kennedy.
  
  Copyright 2001 Barrie Slaymaker.  All Rights Reserved.
  
  You may use this under the terms of either the Artistic License or GNU Public
  License v 2.0 or greater.
  
  =cut
  
  1;
TEXT_DIFF

$fatpacked{"Text/Diff/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF_CONFIG';
  package Text::Diff::Config;
  
  use 5.006;
  use strict;
  use warnings;
  
  our $VERSION   = '1.44';
  our $Output_Unicode;
  
  BEGIN
  {
      $Output_Unicode = $ENV{'DIFF_OUTPUT_UNICODE'};
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Text::Diff::Config - global configuration for Text::Diff (as a 
  separate module).
  
  =head1 SYNOPSIS
  
    use Text::Diff::Config;
    
    $Text::Diff::Config::Output_Unicode = 1;
  
  =head1 DESCRIPTION
  
  This module configures Text::Diff and its related modules. Currently it contains
  only one global variable $Text::Diff::Config::Output_Unicode  which is a boolean
  flag, that if set outputs unicode characters as themselves without escaping them 
  as C< \x{HHHH} > first.
  
  It is initialized to the value of C< $ENV{DIFF_OUTPUT_UNICODE} >, but can be
  set to a different value at run-time, including using local.
  
  =head1 AUTHOR
  
  Shlomi Fish, L<http://www.shlomifish.org/> .
  
  =head1 LICENSE
  
  Copyright 2010, Shlomi Fish.
  
  This file is licensed under the MIT/X11 License:
  L<http://www.opensource.org/licenses/mit-license.php>.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  =cut
  
  package Text::Diff::Config;
  
  use strict;
  use warnings;
  
  use vars qw($Output_Unicode);
  
  BEGIN
  {
      $Output_Unicode = $ENV{'DIFF_OUTPUT_UNICODE'};
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Text::Diff::Config - global configuration for Text::Diff (as a 
  separate module).
  
  =head1 SYNOPSIS
  
    use Text::Diff::Config;
    
    $Text::Diff::Config::Output_Unicode = 1;
  
  =head1 DESCRIPTION
  
  This module configures Text::Diff and its related modules. Currently it contains
  only one global variable $Text::Diff::Config::Output_Unicode  which is a boolean
  flag, that if set outputs unicode characters as themselves without escaping them 
  as C< \x{HHHH} > first.
  
  It is initialized to the value of C< $ENV{DIFF_OUTPUT_UNICODE} >, but can be
  set to a different value at run-time, including using local.
  
  =head1 AUTHOR
  
  Shlomi Fish, L<http://www.shlomifish.org/> .
  
  =head1 LICENSE
  
  Copyright 2010, Shlomi Fish.
  
  This file is licensed under the MIT/X11 License:
  L<http://www.opensource.org/licenses/mit-license.php>.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  =cut
  
TEXT_DIFF_CONFIG

$fatpacked{"Text/Diff/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF_TABLE';
  package Text::Diff::Table;
  
  use 5.006;
  use strict;
  use warnings;
  use Carp;
  use Text::Diff::Config;
  
  our $VERSION   = '1.44';
  our @ISA       = qw( Text::Diff::Base Exporter );
  our @EXPORT_OK = qw( expand_tabs );
  
  my %escapes = map {
      my $c =
          $_ eq '"' || $_ eq '$' ? qq{'$_'}
      : $_ eq "\\"           ? qq{"\\\\"}
                             : qq{"$_"};
      ( ord eval $c => $_ )
  } (
      map( chr, 32..126),
      map( sprintf( "\\x%02x", $_ ), ( 0..31, 127..255 ) ),
  #    map( "\\c$_", "A".."Z"),
      "\\t", "\\n", "\\r", "\\f", "\\b", "\\a", "\\e"
      ## NOTE: "\\\\" is not here because some things are explicitly
      ## escaped before escape() is called and we don't want to
      ## double-escape "\".  Also, in most texts, leaving "\" more
      ## readable makes sense.
  );
  
  sub expand_tabs($) {
      my $s     = shift;
      my $count = 0;
      $s =~ s{(\t)(\t*)|([^\t]+)}{
           if ( $1 ) {
               my $spaces = " " x ( 8 - $count % 8  + 8 * length $2 );
               $count = 0;
               $spaces;
       }
       else {
           $count += length $3;
           $3;
      }
      }ge;
  
      return $s;
  }
  
  sub trim_trailing_line_ends($) {
      my $s = shift;
      $s =~ s/[\r\n]+(?!\n)$//;
      return $s;
  }
  
  sub escape($);
  
  SCOPE: {
     ## use utf8 if available.  don't if not.
     my $escaper = <<'EOCODE';
        sub escape($) {
        use utf8;
        join "", map {
            my $c = $_;
            $_ = ord;
            exists $escapes{$_}
            ? $escapes{$_}
            : $Text::Diff::Config::Output_Unicode 
            ? $c
            : sprintf( "\\x{%04x}", $_ );
        } split //, shift;
        }
  
        1;
  EOCODE
     unless ( eval $escaper ) {
         $escaper =~ s/ *use *utf8 *;\n// or die "Can't drop use utf8;";
         eval $escaper or die $@;
     }
  }
  
  sub new {
      my $proto = shift;
      return bless { @_ }, $proto
  }
  
  my $missing_elt = [ "", "" ];
  
  sub hunk {
      my $self    = shift;
      my @seqs    = ( shift, shift );
      my $ops     = shift;  ## Leave sequences in @_[0,1]
      my $options = shift;
  
      my ( @A, @B );
      for ( @$ops ) {
          my $opcode = $_->[Text::Diff::OPCODE()];
          if ( $opcode eq " " ) {
              push @A, $missing_elt while @A < @B;
              push @B, $missing_elt while @B < @A;
          }
          push @A, [ $_->[0] + ( $options->{OFFSET_A} || 0), $seqs[0][$_->[0]] ]
              if $opcode eq " " || $opcode eq "-";
          push @B, [ $_->[1] + ( $options->{OFFSET_B} || 0), $seqs[1][$_->[1]] ]
              if $opcode eq " " || $opcode eq "+";
      }
  
      push @A, $missing_elt while @A < @B;
      push @B, $missing_elt while @B < @A;
      my @elts;
      for ( 0..$#A ) {
          my ( $A, $B ) = (shift @A, shift @B );
          
          ## Do minimal cleaning on identical elts so these look "normal":
          ## tabs are expanded, trailing newelts removed, etc.  For differing
          ## elts, make invisible characters visible if the invisible characters
          ## differ.
          my $elt_type =  $B == $missing_elt ? "A" :
                          $A == $missing_elt ? "B" :
                          $A->[1] eq $B->[1]  ? "="
                                              : "*";
          if ( $elt_type ne "*" ) {
          if ( $elt_type eq "=" || $A->[1] =~ /\S/ || $B->[1] =~ /\S/ ) {
          $A->[1] = escape trim_trailing_line_ends expand_tabs $A->[1];
          $B->[1] = escape trim_trailing_line_ends expand_tabs $B->[1];
          }
          else {
          $A->[1] = escape $A->[1];
          $B->[1] = escape $B->[1];
          }
          }
          else {
              ## not using \z here for backcompat reasons.
              $A->[1] =~ /^(\s*?)([^ \t].*?)?(\s*)(?![\n\r])$/s;
              my ( $l_ws_A, $body_A, $t_ws_A ) = ( $1, $2, $3 );
          $body_A = "" unless defined $body_A;
              $B->[1] =~ /^(\s*?)([^ \t].*?)?(\s*)(?![\n\r])$/s;
              my ( $l_ws_B, $body_B, $t_ws_B ) = ( $1, $2, $3 );
          $body_B = "" unless defined $body_B;
  
              my $added_escapes;
  
              if ( $l_ws_A ne $l_ws_B ) {
                  ## Make leading tabs visible.  Other non-' ' chars
                  ## will be dealt with in escape(), but this prevents
                  ## tab expansion from hiding tabs by making them
                  ## look like ' '.
                  $added_escapes = 1 if $l_ws_A =~ s/\t/\\t/g;
                  $added_escapes = 1 if $l_ws_B =~ s/\t/\\t/g;
              }
  
              if ( $t_ws_A ne $t_ws_B ) {
                  ## Only trailing whitespace gets the \s treatment
                  ## to make it obvious what's going on.
                  $added_escapes = 1 if $t_ws_A =~ s/ /\\s/g;
                  $added_escapes = 1 if $t_ws_B =~ s/ /\\s/g;
                  $added_escapes = 1 if $t_ws_A =~ s/\t/\\t/g;
                  $added_escapes = 1 if $t_ws_B =~ s/\t/\\t/g;
              }
              else {
                  $t_ws_A = $t_ws_B = "";
              }
  
              my $do_tab_escape = $added_escapes || do {
                  my $expanded_A = expand_tabs join( $body_A, $l_ws_A, $t_ws_A );
                  my $expanded_B = expand_tabs join( $body_B, $l_ws_B, $t_ws_B );
                  $expanded_A eq $expanded_B;
              };
  
              my $do_back_escape = $do_tab_escape || do {
                  my ( $unescaped_A, $escaped_A,
                       $unescaped_B, $escaped_B
                  ) =
                      map
                          join( "", /(\\.)/g ),
                          map {
                              ( $_, escape $_ )
                          }
                          expand_tabs join( $body_A, $l_ws_A, $t_ws_A ),
                          expand_tabs join( $body_B, $l_ws_B, $t_ws_B );
                  $unescaped_A ne $unescaped_B && $escaped_A eq $escaped_B;
              };
  
              if ( $do_back_escape ) {
                  $body_A =~ s/\\/\\\\/g;
                  $body_B =~ s/\\/\\\\/g;
              }
  
              my $line_A = join $body_A, $l_ws_A, $t_ws_A;
              my $line_B = join $body_B, $l_ws_B, $t_ws_B;
  
              unless ( $do_tab_escape ) {
                  $line_A = expand_tabs $line_A;
                  $line_B = expand_tabs $line_B;
              }
  
              $A->[1] = escape $line_A;
              $B->[1] = escape $line_B;
          }
  
          push @elts, [ @$A, @$B, $elt_type ];
      }
  
      push @{$self->{ELTS}}, @elts, ["bar"];
      return "";
  }
  
  sub _glean_formats {
      my $self = shift;
  }
  
  sub file_footer {
      my $self = shift;
      my @seqs = (shift,shift);
      my $options = pop;
  
      my @heading_lines;
      
      if ( defined $options->{FILENAME_A} || defined $options->{FILENAME_B} ) {
          push @heading_lines, [ 
              map(
                  {
                      ( "", escape( defined $_ ? $_ : "<undef>" ) );
                  }
                  ( @{$options}{qw( FILENAME_A FILENAME_B)} )
              ),
              "=",
          ];
      }
  
      if ( defined $options->{MTIME_A} || defined $options->{MTIME_B} ) {
          push @heading_lines, [
              map( {
                      ( "",
                          escape(
                              ( defined $_ && length $_ )
                                  ? localtime $_
                                  : ""
                          )
                      );
                  }
                  @{$options}{qw( MTIME_A MTIME_B )}
              ),
              "=",
          ];
      }
  
      if ( defined $options->{INDEX_LABEL} ) {
          push @heading_lines, [ "", "", "", "", "=" ] unless @heading_lines;
          $heading_lines[-1]->[0] = $heading_lines[-1]->[2] =
              $options->{INDEX_LABEL};
      }
  
      ## Not ushifting on to @{$self->{ELTS}} in case it's really big.  Want
      ## to avoid the overhead.
  
      my $four_column_mode = 0;
      for my $cols ( @heading_lines, @{$self->{ELTS}} ) {
          next if $cols->[-1] eq "bar";
          if ( $cols->[0] ne $cols->[2] ) {
              $four_column_mode = 1;
              last;
          }
      }
  
      unless ( $four_column_mode ) {
          for my $cols ( @heading_lines, @{$self->{ELTS}} ) {
              next if $cols->[-1] eq "bar";
              splice @$cols, 2, 1;
          }
      }
  
      my @w = (0,0,0,0);
      for my $cols ( @heading_lines, @{$self->{ELTS}} ) {
          next if $cols->[-1] eq "bar";
          for my $i (0..($#$cols-1)) {
              $w[$i] = length $cols->[$i]
                  if defined $cols->[$i] && length $cols->[$i] > $w[$i];
          }
      }
  
      my %fmts = $four_column_mode
          ? (
              "=" => "| %$w[0]s|%-$w[1]s  | %$w[2]s|%-$w[3]s  |\n",
              "A" => "* %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  |\n",
              "B" => "| %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  *\n",
              "*" => "* %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  *\n",
          )
          : (
              "=" => "| %$w[0]s|%-$w[1]s  |%-$w[2]s  |\n",
              "A" => "* %$w[0]s|%-$w[1]s  |%-$w[2]s  |\n",
              "B" => "| %$w[0]s|%-$w[1]s  |%-$w[2]s  *\n",
              "*" => "* %$w[0]s|%-$w[1]s  |%-$w[2]s  *\n",
          );
  
      my @args = ('', '', '');
      push(@args, '') if $four_column_mode;
      $fmts{bar} = sprintf $fmts{"="}, @args;
      $fmts{bar} =~ s/\S/+/g;
      $fmts{bar} =~ s/ /-/g;
  
      # Sometimes the sprintf has too many arguments,
      # which results in a warning on Perl 5.021+
      # I really wanted to write:
      #   no warnings 'redundant';
      # but that causes a compilation error on older versions of perl
      # where the warnings pragma doesn't know about 'redundant'
      no warnings;
  
      return join( "",
          map {
              sprintf( $fmts{$_->[-1]}, @$_ );
          } (
          ["bar"],
          @heading_lines,
          @heading_lines ? ["bar"] : (),
          @{$self->{ELTS}},
          ),
      );
  
      @{$self->{ELTS}} = [];
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
    Text::Diff::Table - Text::Diff plugin to generate "table" format output
  
  =head1 SYNOPSIS
  
    use Text::Diff;
    
    diff \@a, $b, { STYLE => "Table" };
  
  =head1 DESCRIPTION
  
  This is a plugin output formatter for Text::Diff that generates "table" style
  diffs:
  
    +--+----------------------------------+--+------------------------------+
    |  |../Test-Differences-0.2/MANIFEST  |  |../Test-Differences/MANIFEST  |
    |  |Thu Dec 13 15:38:49 2001          |  |Sat Dec 15 02:09:44 2001      |
    +--+----------------------------------+--+------------------------------+
    |  |                                  * 1|Changes                       *
    | 1|Differences.pm                    | 2|Differences.pm                |
    | 2|MANIFEST                          | 3|MANIFEST                      |
    |  |                                  * 4|MANIFEST.SKIP                 *
    | 3|Makefile.PL                       | 5|Makefile.PL                   |
    |  |                                  * 6|t/00escape.t                  *
    | 4|t/00flatten.t                     | 7|t/00flatten.t                 |
    | 5|t/01text_vs_data.t                | 8|t/01text_vs_data.t            |
    | 6|t/10test.t                        | 9|t/10test.t                    |
    +--+----------------------------------+--+------------------------------+
  
  This format also goes to some pains to highlight "invisible" characters on
  differing elements by selectively escaping whitespace.  Each element is split
  in to three segments (leading whitespace, body, trailing whitespace).  If
  whitespace differs in a segement, that segment is whitespace escaped.
  
  Here is an example of the selective whitespace.
  
    +--+--------------------------+--------------------------+
    |  |demo_ws_A.txt             |demo_ws_B.txt             |
    |  |Fri Dec 21 08:36:32 2001  |Fri Dec 21 08:36:50 2001  |
    +--+--------------------------+--------------------------+
    | 1|identical                 |identical                 |
    * 2|        spaced in         |        also spaced in    *
    * 3|embedded space            |embedded        tab       *
    | 4|identical                 |identical                 |
    * 5|        spaced in         |\ttabbed in               *
    * 6|trailing spaces\s\s\n     |trailing tabs\t\t\n       *
    | 7|identical                 |identical                 |
    * 8|lf line\n                 |crlf line\r\n             *
    * 9|embedded ws               |embedded\tws              *
    +--+--------------------------+--------------------------+
  
  Here's why the lines do or do not have whitespace escaped:
  
  =over
  
  =item lines 1, 4, 7 don't differ, no need.
  
  =item lines 2, 3 differ in non-whitespace, no need.
  
  =item lines 5, 6, 8, 9 all have subtle ws changes.
  
  =back
  
  Whether or not line 3 should have that tab character escaped is a judgement
  call; so far I'm choosing not to.
  
  =head1 UNICODE
  
  To output the raw unicode chracters consult the documentation of
  L<Text::Diff::Config>. You can set the C<DIFF_OUTPUT_UNICODE> environment
  variable to 1 to output it from the command line. For more information,
  consult this bug: L<https://rt.cpan.org/Ticket/Display.html?id=54214> .
  
  =head1 LIMITATIONS
  
  Table formatting requires buffering the entire diff in memory in order to
  calculate column widths.  This format should only be used for smaller
  diffs.
  
  Assumes tab stops every 8 characters, as $DIETY intended.
  
  Assumes all character codes >= 127 need to be escaped as hex codes, ie that the
  user's terminal is ASCII, and not even "high bit ASCII", capable.  This can be
  made an option when the need arises.
  
  Assumes that control codes (character codes 0..31) that don't have slash-letter
  escapes ("\n", "\r", etc) in Perl are best presented as hex escapes ("\x01")
  instead of octal ("\001") or control-code ("\cA") escapes.
  
  =head1 AUTHOR
  
  Barrie Slaymaker E<lt>barries@slaysys.comE<gt>
  
  =head1 LICENSE
  
  Copyright 2001 Barrie Slaymaker, All Rights Reserved.
  
  You may use this software under the terms of the GNU public license, any
  version, or the Artistic license.
  
  =cut
TEXT_DIFF_TABLE

$fatpacked{"Text/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_TEMPLATE';
  # -*- perl -*-
  # Text::Template.pm
  #
  # Fill in `templates'
  #
  # Copyright 2013 M. J. Dominus.
  # You may copy and distribute this program under the
  # same terms as Perl itself.  
  # If in doubt, write to mjd-perl-template+@plover.com for a license.
  #
  
  package Text::Template;
  $Text::Template::VERSION = '1.47';
  # ABSTRACT: Expand template text with embedded Perl
  
  require 5.004;
  use Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(fill_in_file fill_in_string TTerror);
  use vars '$ERROR';
  use strict;
  
  my %GLOBAL_PREPEND = ('Text::Template' => '');
  
  sub Version {
    $Text::Template::VERSION;
  }
  
  sub _param {
    my $kk;
    my ($k, %h) = @_;
    for $kk ($k, "\u$k", "\U$k", "-$k", "-\u$k", "-\U$k") {
      return $h{$kk} if exists $h{$kk};
    }
    return;
  }
  
  sub always_prepend
  {
    my $pack = shift;
    my $old = $GLOBAL_PREPEND{$pack};
    $GLOBAL_PREPEND{$pack} = shift;
    $old;
  }
  
  {
    my %LEGAL_TYPE;
    BEGIN { 
      %LEGAL_TYPE = map {$_=>1} qw(FILE FILEHANDLE STRING ARRAY);
    }
    sub new {
      my $pack = shift;
      my %a = @_;
      my $stype = uc(_param('type', %a) || "FILE");
      my $source = _param('source', %a);
      my $untaint = _param('untaint', %a);
      my $prepend = _param('prepend', %a);
      my $alt_delim = _param('delimiters', %a);
      my $broken = _param('broken', %a);
      unless (defined $source) {
        require Carp;
        Carp::croak("Usage: $ {pack}::new(TYPE => ..., SOURCE => ...)");
      }
      unless ($LEGAL_TYPE{$stype}) {
        require Carp;
        Carp::croak("Illegal value `$stype' for TYPE parameter");
      }
      my $self = {TYPE => $stype,
  		PREPEND => $prepend,
                  UNTAINT => $untaint,
                  BROKEN => $broken,
  		(defined $alt_delim ? (DELIM => $alt_delim) : ()),
  	       };
      # Under 5.005_03, if any of $stype, $prepend, $untaint, or $broken
      # are tainted, all the others become tainted too as a result of
      # sharing the expression with them.  We install $source separately
      # to prevent it from acquiring a spurious taint.
      $self->{SOURCE} = $source;
  
      bless $self => $pack;
      return unless $self->_acquire_data;
      
      $self;
    }
  }
  
  # Convert template objects of various types to type STRING,
  # in which the template data is embedded in the object itself.
  sub _acquire_data {
    my ($self) = @_;
    my $type = $self->{TYPE};
    if ($type eq 'STRING') {
      # nothing necessary    
    } elsif ($type eq 'FILE') {
      my $data = _load_text($self->{SOURCE});
      unless (defined $data) {
        # _load_text already set $ERROR
        return undef;
      }
      if ($self->{UNTAINT} && _is_clean($self->{SOURCE})) {
        _unconditionally_untaint($data);
      }
      $self->{TYPE} = 'STRING';
      $self->{FILENAME} = $self->{SOURCE};
      $self->{SOURCE} = $data;
    } elsif ($type eq 'ARRAY') {
      $self->{TYPE} = 'STRING';
      $self->{SOURCE} = join '', @{$self->{SOURCE}};
    } elsif ($type eq 'FILEHANDLE') {
      $self->{TYPE} = 'STRING';
      local $/;
      my $fh = $self->{SOURCE};
      my $data = <$fh>; # Extra assignment avoids bug in Solaris perl5.00[45].
      if ($self->{UNTAINT}) {
        _unconditionally_untaint($data);
      }
      $self->{SOURCE} = $data;
    } else {
      # This should have been caught long ago, so it represents a 
      # drastic `can't-happen' sort of failure
      my $pack = ref $self;
      die "Can only acquire data for $pack objects of subtype STRING, but this is $type; aborting";
    }
    $self->{DATA_ACQUIRED} = 1;
  }
  
  sub source {
    my ($self) = @_;
    $self->_acquire_data unless $self->{DATA_ACQUIRED};
    return $self->{SOURCE};
  }
  
  sub set_source_data {
    my ($self, $newdata) = @_;
    $self->{SOURCE} = $newdata;
    $self->{DATA_ACQUIRED} = 1;
    $self->{TYPE} = 'STRING';
    1;
  }
  
  sub compile {
    my $self = shift;
  
    return 1 if $self->{TYPE} eq 'PREPARSED';
  
    return undef unless $self->_acquire_data;
    unless ($self->{TYPE} eq 'STRING') {
      my $pack = ref $self;
      # This should have been caught long ago, so it represents a 
      # drastic `can't-happen' sort of failure
      die "Can only compile $pack objects of subtype STRING, but this is $self->{TYPE}; aborting";
    }
  
    my @tokens;
    my $delim_pats = shift() || $self->{DELIM};
  
    
  
    my ($t_open, $t_close) = ('{', '}');
    my $DELIM;			# Regex matches a delimiter if $delim_pats
    if (defined $delim_pats) {
      ($t_open, $t_close) = @$delim_pats;
      $DELIM = "(?:(?:\Q$t_open\E)|(?:\Q$t_close\E))";
      @tokens = split /($DELIM|\n)/, $self->{SOURCE};
    } else {
      @tokens = split /(\\\\(?=\\*[{}])|\\[{}]|[{}\n])/, $self->{SOURCE};
    }
    my $state = 'TEXT';
    my $depth = 0;
    my $lineno = 1;
    my @content;
    my $cur_item = '';
    my $prog_start;
    while (@tokens) {
      my $t = shift @tokens;
      next if $t eq '';
      if ($t eq $t_open) {	# Brace or other opening delimiter
        if ($depth == 0) {
  	push @content, [$state, $cur_item, $lineno] if $cur_item ne '';
  	$cur_item = '';
  	$state = 'PROG';
  	$prog_start = $lineno;
        } else {
  	$cur_item .= $t;
        }
        $depth++;
      } elsif ($t eq $t_close) {	# Brace or other closing delimiter
        $depth--;
        if ($depth < 0) {
  	$ERROR = "Unmatched close brace at line $lineno";
  	return undef;
        } elsif ($depth == 0) {
  	push @content, [$state, $cur_item, $prog_start] if $cur_item ne '';
  	$state = 'TEXT';
  	$cur_item = '';
        } else {
  	$cur_item .= $t;
        }
      } elsif (!$delim_pats && $t eq '\\\\') { # precedes \\\..\\\{ or \\\..\\\}
        $cur_item .= '\\';
      } elsif (!$delim_pats && $t =~ /^\\([{}])$/) { # Escaped (literal) brace?
  	$cur_item .= $1;
      } elsif ($t eq "\n") {	# Newline
        $lineno++;
        $cur_item .= $t;
      } else {			# Anything else
        $cur_item .= $t;
      }
    }
  
    if ($state eq 'PROG') {
      $ERROR = "End of data inside program text that began at line $prog_start";
      return undef;
    } elsif ($state eq 'TEXT') {
      push @content, [$state, $cur_item, $lineno] if $cur_item ne '';
    } else {
      die "Can't happen error #1";
    }
    
    $self->{TYPE} = 'PREPARSED';
    $self->{SOURCE} = \@content;
    1;
  }
  
  sub prepend_text {
    my ($self) = @_;
    my $t = $self->{PREPEND};
    unless (defined $t) {
      $t = $GLOBAL_PREPEND{ref $self};
      unless (defined $t) {
        $t = $GLOBAL_PREPEND{'Text::Template'};
      }
    }
    $self->{PREPEND} = $_[1] if $#_ >= 1;
    return $t;
  }
  
  sub fill_in {
    my $fi_self = shift;
    my %fi_a = @_;
  
    unless ($fi_self->{TYPE} eq 'PREPARSED') {
      my $delims = _param('delimiters', %fi_a);
      my @delim_arg = (defined $delims ? ($delims) : ());
      $fi_self->compile(@delim_arg)
        or return undef;
    }
  
    my $fi_varhash = _param('hash', %fi_a);
    my $fi_package = _param('package', %fi_a) ;
    my $fi_broken  = 
      _param('broken', %fi_a)  || $fi_self->{BROKEN} || \&_default_broken;
    my $fi_broken_arg = _param('broken_arg', %fi_a) || [];
    my $fi_safe = _param('safe', %fi_a);
    my $fi_ofh = _param('output', %fi_a);
    my $fi_eval_package;
    my $fi_scrub_package = 0;
    my $fi_filename = _param('filename') || $fi_self->{FILENAME} || 'template';
  
    my $fi_prepend = _param('prepend', %fi_a);
    unless (defined $fi_prepend) {
      $fi_prepend = $fi_self->prepend_text;
    }
  
    if (defined $fi_safe) {
      $fi_eval_package = 'main';
    } elsif (defined $fi_package) {
      $fi_eval_package = $fi_package;
    } elsif (defined $fi_varhash) {
      $fi_eval_package = _gensym();
      $fi_scrub_package = 1;
    } else {
      $fi_eval_package = caller;
    }
  
    my $fi_install_package;
    if (defined $fi_varhash) {
      if (defined $fi_package) {
        $fi_install_package = $fi_package;
      } elsif (defined $fi_safe) {
        $fi_install_package = $fi_safe->root;
      } else {
        $fi_install_package = $fi_eval_package; # The gensymmed one
      }
      _install_hash($fi_varhash => $fi_install_package);
    }
  
    if (defined $fi_package && defined $fi_safe) {
      no strict 'refs';
      # Big fat magic here: Fix it so that the user-specified package
      # is the default one available in the safe compartment.
      *{$fi_safe->root . '::'} = \%{$fi_package . '::'};   # LOD
    }
  
    my $fi_r = '';
    my $fi_item;
    foreach $fi_item (@{$fi_self->{SOURCE}}) {
      my ($fi_type, $fi_text, $fi_lineno) = @$fi_item;
      if ($fi_type eq 'TEXT') {
        $fi_self->append_text_to_output(
          text   => $fi_text,
          handle => $fi_ofh,
          out    => \$fi_r,
          type   => $fi_type,
        );
      } elsif ($fi_type eq 'PROG') {
        no strict;
        my $fi_lcomment = "#line $fi_lineno $fi_filename";
        my $fi_progtext = 
          "package $fi_eval_package; $fi_prepend;\n$fi_lcomment\n$fi_text;";
        my $fi_res;
        my $fi_eval_err = '';
        if ($fi_safe) {
          $fi_safe->reval(q{undef $OUT});
  	$fi_res = $fi_safe->reval($fi_progtext);
  	$fi_eval_err = $@;
  	my $OUT = $fi_safe->reval('$OUT');
  	$fi_res = $OUT if defined $OUT;
        } else {
  	my $OUT;
  	$fi_res = eval $fi_progtext;
  	$fi_eval_err = $@;
  	$fi_res = $OUT if defined $OUT;
        }
  
        # If the value of the filled-in text really was undef,
        # change it to an explicit empty string to avoid undefined
        # value warnings later.
        $fi_res = '' unless defined $fi_res;
  
        if ($fi_eval_err) {
  	$fi_res = $fi_broken->(text => $fi_text,
  			       error => $fi_eval_err,
  			       lineno => $fi_lineno,
  			       arg => $fi_broken_arg,
  			       );
  	if (defined $fi_res) {
            $fi_self->append_text_to_output(
              text   => $fi_res,
              handle => $fi_ofh,
              out    => \$fi_r,
              type   => $fi_type,
            );
  	} else {
  	  return $fi_res;		# Undefined means abort processing
  	}
        } else {
          $fi_self->append_text_to_output(
            text   => $fi_res,
            handle => $fi_ofh,
            out    => \$fi_r,
            type   => $fi_type,
          );
        }
      } else {
        die "Can't happen error #2";
      }
    }
  
    _scrubpkg($fi_eval_package) if $fi_scrub_package;
    defined $fi_ofh ? 1 : $fi_r;
  }
  
  sub append_text_to_output {
    my ($self, %arg) = @_;
  
    if (defined $arg{handle}) {
      print { $arg{handle} } $arg{text};
    } else {
      ${ $arg{out} } .= $arg{text};
    }
  
    return;
  }
  
  sub fill_this_in {
    my $pack = shift;
    my $text = shift;
    my $templ = $pack->new(TYPE => 'STRING', SOURCE => $text, @_)
      or return undef;
    $templ->compile or return undef;
    my $result = $templ->fill_in(@_);
    $result;
  }
  
  sub fill_in_string {
    my $string = shift;
    my $package = _param('package', @_);
    push @_, 'package' => scalar(caller) unless defined $package;
    Text::Template->fill_this_in($string, @_);
  }
  
  sub fill_in_file {
    my $fn = shift;
    my $templ = Text::Template->new(TYPE => 'FILE', SOURCE => $fn, @_)
      or return undef;
    $templ->compile or return undef;
    my $text = $templ->fill_in(@_);
    $text;
  }
  
  sub _default_broken {
    my %a = @_;
    my $prog_text = $a{text};
    my $err = $a{error};
    my $lineno = $a{lineno};
    chomp $err;
  #  $err =~ s/\s+at .*//s;
    "Program fragment delivered error ``$err''";
  }
  
  sub _load_text {
    my $fn = shift;
    local *F;
    unless (open F, $fn) {
      $ERROR = "Couldn't open file $fn: $!";
      return undef;
    }
    local $/;
    <F>;
  }
  
  sub _is_clean {
    my $z;
    eval { ($z = join('', @_)), eval '#' . substr($z,0,0); 1 }   # LOD
  }
  
  sub _unconditionally_untaint {
    for (@_) {
      ($_) = /(.*)/s;
    }
  }
  
  {
    my $seqno = 0;
    sub _gensym {
      __PACKAGE__ . '::GEN' . $seqno++;
    }
    sub _scrubpkg {
      my $s = shift;
      $s =~ s/^Text::Template:://;
      no strict 'refs';
      my $hash = $Text::Template::{$s."::"};
      foreach my $key (keys %$hash) {
        undef $hash->{$key};
      }
      %$hash = ();
      delete $Text::Template::{$s."::"};
    }
  }
    
  # Given a hashful of variables (or a list of such hashes)
  # install the variables into the specified package,
  # overwriting whatever variables were there before.
  sub _install_hash {
    my $hashlist = shift;
    my $dest = shift;
    if (UNIVERSAL::isa($hashlist, 'HASH')) {
      $hashlist = [$hashlist];
    }
    my $hash;
    foreach $hash (@$hashlist) {
      my $name;
      foreach $name (keys %$hash) {
        my $val = $hash->{$name};
        no strict 'refs';
        local *SYM = *{"$ {dest}::$name"};
        if (! defined $val) {
  	delete ${"$ {dest}::"}{$name};
        } elsif (ref $val) {
  	*SYM = $val;
        } else {
   	*SYM = \$val;
        }
      }
    }
  }
  
  sub TTerror { $ERROR }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Text::Template - Expand template text with embedded Perl
  
  =head1 VERSION
  
  version 1.47
  
  =head1 SYNOPSIS
  
   use Text::Template;
  
  
   $template = Text::Template->new(TYPE => 'FILE',  SOURCE => 'filename.tmpl');
   $template = Text::Template->new(TYPE => 'ARRAY', SOURCE => [ ... ] );
   $template = Text::Template->new(TYPE => 'FILEHANDLE', SOURCE => $fh );
   $template = Text::Template->new(TYPE => 'STRING', SOURCE => '...' );
   $template = Text::Template->new(PREPEND => q{use strict;}, ...);
  
   # Use a different template file syntax:
   $template = Text::Template->new(DELIMITERS => [$open, $close], ...);
  
   $recipient = 'King';
   $text = $template->fill_in();  # Replaces `{$recipient}' with `King'
   print $text;
  
   $T::recipient = 'Josh';
   $text = $template->fill_in(PACKAGE => T);
  
   # Pass many variables explicitly
   $hash = { recipient => 'Abed-Nego',
             friends => [ 'me', 'you' ],
             enemies => { loathsome => 'Bill Gates',
                          fearsome => 'Larry Ellison' },
           };
   $text = $template->fill_in(HASH => $hash, ...);
   # $recipient is Abed-Nego,
   # @friends is ( 'me', 'you' ),
   # %enemies is ( loathsome => ..., fearsome => ... )
  
  
   # Call &callback in case of programming errors in template
   $text = $template->fill_in(BROKEN => \&callback, BROKEN_ARG => $ref, ...);
  
   # Evaluate program fragments in Safe compartment with restricted permissions
   $text = $template->fill_in(SAFE => $compartment, ...);
  
   # Print result text instead of returning it
   $success = $template->fill_in(OUTPUT => \*FILEHANDLE, ...);
  
   # Parse template with different template file syntax:
   $text = $template->fill_in(DELIMITERS => [$open, $close], ...);
   # Note that this is *faster* than using the default delimiters
  
   # Prepend specified perl code to each fragment before evaluating:
   $text = $template->fill_in(PREPEND => q{use strict 'vars';}, ...);
  
   use Text::Template 'fill_in_string';
   $text = fill_in_string( <<EOM, PACKAGE => 'T', ...);
   Dear {$recipient},
   Pay me at once.
          Love, 
           G.V.
   EOM
  
   use Text::Template 'fill_in_file';
   $text = fill_in_file($filename, ...);
  
   # All templates will always have `use strict vars' attached to all fragments
   Text::Template->always_prepend(q{use strict 'vars';});
  
  =head1 DESCRIPTION
  
  This is a library for generating form letters, building HTML pages, or
  filling in templates generally.  A `template' is a piece of text that
  has little Perl programs embedded in it here and there.  When you
  `fill in' a template, you evaluate the little programs and replace
  them with their values.  
  
  You can store a template in a file outside your program.  People can
  modify the template without modifying the program.  You can separate
  the formatting details from the main code, and put the formatting
  parts of the program into the template.  That prevents code bloat and
  encourages functional separation.
  
  =head2 Example
  
  Here's an example of a template, which we'll suppose is stored in the
  file C<formletter.tmpl>:
  
  	Dear {$title} {$lastname},
  
  	It has come to our attention that you are delinquent in your
  	{$monthname[$last_paid_month]} payment.  Please remit
  	${sprintf("%.2f", $amount)} immediately, or your patellae may
  	be needlessly endangered.
  
  			Love,
  
  			Mark "Vizopteryx" Dominus
  
  The result of filling in this template is a string, which might look
  something like this:
  
  	Dear Mr. Gates,
  
  	It has come to our attention that you are delinquent in your
  	February payment.  Please remit
  	$392.12 immediately, or your patellae may
  	be needlessly endangered.
  
  
  			Love,
  
  			Mark "Vizopteryx" Dominus
  
  Here is a complete program that transforms the example
  template into the example result, and prints it out:
  
  	use Text::Template;
  
  	my $template = Text::Template->new(SOURCE => 'formletter.tmpl')
  	  or die "Couldn't construct template: $Text::Template::ERROR";
  
  	my @monthname = qw(January February March April May June
                             July August September October November December);
  	my %vars = (title => 'Mr.',
  		    firstname => 'Bill',
  		    lastname => 'Gates',
  		    last_paid_month => 1,   # February
  		    amount => 392.12,
  		    monthname => \@monthname,
  		   );
  
  	my $result = $template->fill_in(HASH => \%vars);
  
  	if (defined $result) { print $result }
  	else { die "Couldn't fill in template: $Text::Template::ERROR" }
  
  =head2 Philosophy
  
  When people make a template module like this one, they almost always
  start by inventing a special syntax for substitutions.  For example,
  they build it so that a string like C<%%VAR%%> is replaced with the
  value of C<$VAR>.  Then they realize the need extra formatting, so
  they put in some special syntax for formatting.  Then they need a
  loop, so they invent a loop syntax.  Pretty soon they have a new
  little template language.
  
  This approach has two problems: First, their little language is
  crippled. If you need to do something the author hasn't thought of,
  you lose.  Second: Who wants to learn another language?  You already
  know Perl, so why not use it?
  
  C<Text::Template> templates are programmed in I<Perl>.  You embed Perl
  code in your template, with C<{> at the beginning and C<}> at the end.
  If you want a variable interpolated, you write it the way you would in
  Perl.  If you need to make a loop, you can use any of the Perl loop
  constructions.  All the Perl built-in functions are available.
  
  =head1 Details
  
  =head2 Template Parsing
  
  The C<Text::Template> module scans the template source.  An open brace
  C<{> begins a program fragment, which continues until the matching
  close brace C<}>.  When the template is filled in, the program
  fragments are evaluated, and each one is replaced with the resulting
  value to yield the text that is returned.
  
  A backslash C<\> in front of a brace (or another backslash that is in
  front of a brace) escapes its special meaning.  The result of filling
  out this template:
  
  	\{ The sum of 1 and 2 is {1+2}  \}
  
  is
  
  	{ The sum of 1 and 2 is 3  }
  
  If you have an unmatched brace, C<Text::Template> will return a
  failure code and a warning about where the problem is.  Backslashes
  that do not precede a brace are passed through unchanged.  If you have
  a template like this:
  
  	{ "String that ends in a newline.\n" }
  
  The backslash inside the string is passed through to Perl unchanged,
  so the C<\n> really does turn into a newline.  See the note at the end
  for details about the way backslashes work.  Backslash processing is
  I<not> done when you specify alternative delimiters with the
  C<DELIMITERS> option.  (See L<"Alternative Delimiters">, below.)
  
  Each program fragment should be a sequence of Perl statements, which
  are evaluated the usual way.  The result of the last statement
  executed will be evaluated in scalar context; the result of this
  statement is a string, which is interpolated into the template in
  place of the program fragment itself.
  
  The fragments are evaluated in order, and side effects from earlier
  fragments will persist into later fragments:
  
  	{$x = @things; ''}The Lord High Chamberlain has gotten {$x}
  	things for me this year.  
  	{ $diff = $x - 17; 
  	  $more = 'more'
  	  if ($diff == 0) {
  	    $diff = 'no';
  	  } elsif ($diff < 0) {
  	    $more = 'fewer';
  	  } 
            '';
  	} 
  	That is {$diff} {$more} than he gave me last year.
  
  The value of C<$x> set in the first line will persist into the next
  fragment that begins on the third line, and the values of C<$diff> and
  C<$more> set in the second fragment will persist and be interpolated
  into the last line.  The output will look something like this:
  
  	The Lord High Chamberlain has gotten 42
  	things for me this year.  
  
  	That is 25 more than he gave me last year.
  
  That is all the syntax there is.  
  
  =head2 The C<$OUT> variable
  
  There is one special trick you can play in a template.  Here is the
  motivation for it:  Suppose you are going to pass an array, C<@items>,
  into the template, and you want the template to generate a bulleted
  list with a header, like this:
  
  	Here is a list of the things I have got for you since 1907:
  	  * Ivory
  	  * Apes
  	  * Peacocks
  	  * ...
  
  One way to do it is with a template like this:
  
  	Here is a list of the things I have got for you since 1907:
  	{ my $blist = '';
            foreach $i (@items) {
              $blist .= qq{  * $i\n};
            }    
            $blist;
          } 
  
  Here we construct the list in a variable called C<$blist>, which we
  return at the end.  This is a little cumbersome.  There is a shortcut.
  
  Inside of templates, there is a special variable called C<$OUT>.
  Anything you append to this variable will appear in the output of the
  template.  Also, if you use C<$OUT> in a program fragment, the normal
  behavior, of replacing the fragment with its return value, is
  disabled; instead the fragment is replaced with the value of C<$OUT>.
  This means that you can write the template above like this:
  
  	Here is a list of the things I have got for you since 1907:
  	{ foreach $i (@items) {
              $OUT .= "  * $i\n";
            }    
          } 
  
  C<$OUT> is reinitialized to the empty string at the start of each
  program fragment.  It is private to C<Text::Template>, so 
  you can't use a variable named C<$OUT> in your template without
  invoking the special behavior.
  
  =head2 General Remarks
  
  All C<Text::Template> functions return C<undef> on failure, and set the
  variable C<$Text::Template::ERROR> to contain an explanation of what
  went wrong.  For example, if you try to create a template from a file
  that does not exist, C<$Text::Template::ERROR> will contain something like:
  
  	Couldn't open file xyz.tmpl: No such file or directory
  
  =head2 C<new>
  
  	$template = new Text::Template ( TYPE => ..., SOURCE => ... );
  
  This creates and returns a new template object.  C<new> returns
  C<undef> and sets C<$Text::Template::ERROR> if it can't create the
  template object.  C<SOURCE> says where the template source code will
  come from.  C<TYPE> says what kind of object the source is.
  
  The most common type of source is a file:
  
  	new Text::Template ( TYPE => 'FILE', SOURCE => $filename );
  
  This reads the template from the specified file.  The filename is
  opened with the Perl C<open> command, so it can be a pipe or anything
  else that makes sense with C<open>.
  
  The C<TYPE> can also be C<STRING>, in which case the C<SOURCE> should
  be a string:
  
  	new Text::Template ( TYPE => 'STRING', 
                               SOURCE => "This is the actual template!" );
  
  The C<TYPE> can be C<ARRAY>, in which case the source should be a
  reference to an array of strings.  The concatenation of these strings
  is the template:
  
  	new Text::Template ( TYPE => 'ARRAY', 
                               SOURCE => [ "This is ", "the actual", 
                                           " template!",
                                         ]
                             );
  
  The C<TYPE> can be FILEHANDLE, in which case the source should be an
  open filehandle (such as you got from the C<FileHandle> or C<IO::*>
  packages, or a glob, or a reference to a glob).  In this case
  C<Text::Template> will read the text from the filehandle up to
  end-of-file, and that text is the template:
  
  	# Read template source code from STDIN:
  	new Text::Template ( TYPE => 'FILEHANDLE', 
                               SOURCE => \*STDIN  );
  
  If you omit the C<TYPE> attribute, it's taken to be C<FILE>.
  C<SOURCE> is required.  If you omit it, the program will abort.
  
  The words C<TYPE> and C<SOURCE> can be spelled any of the following ways:
  
  	TYPE	SOURCE
  	Type	Source
  	type	source
  	-TYPE	-SOURCE
  	-Type	-Source
  	-type	-source
  
  Pick a style you like and stick with it.
  
  =over 4
  
  =item C<DELIMITERS>
  
  You may also add a C<DELIMITERS> option.  If this option is present,
  its value should be a reference to an array of two strings.  The first
  string is the string that signals the beginning of each program
  fragment, and the second string is the string that signals the end of
  each program fragment.  See L<"Alternative Delimiters">, below.
  
  =item C<UNTAINT>
  
  If your program is running in taint mode, you may have problems if
  your templates are stored in files.  Data read from files is
  considered 'untrustworthy', and taint mode will not allow you to
  evaluate the Perl code in the file.  (It is afraid that a malicious
  person might have tampered with the file.)
  
  In some environments, however, local files are trustworthy.  You can
  tell C<Text::Template> that a certain file is trustworthy by supplying
  C<UNTAINT =E<gt> 1> in the call to C<new>.  This will tell
  C<Text::Template> to disable taint checks on template code that has
  come from a file, as long as the filename itself is considered
  trustworthy.  It will also disable taint checks on template code that
  comes from a filehandle.  When used with C<TYPE =E<gt> 'string'> or C<TYPE
  =E<gt> 'array'>, it has no effect.
  
  See L<perlsec> for more complete information about tainting.
  
  Thanks to Steve Palincsar, Gerard Vreeswijk, and Dr. Christoph Baehr
  for help with this feature.
  
  =item C<PREPEND>
  
  This option is passed along to the C<fill_in> call unless it is
  overridden in the arguments to C<fill_in>.  See L<C<PREPEND> feature
  and using C<strict> in templates> below.
  
  =item C<BROKEN>
  
  This option is passed along to the C<fill_in> call unless it is
  overridden in the arguments to C<fill_in>.  See L<C<BROKEN>> below.
  
  =back
  
  =head2 C<compile>
  
  	$template->compile()
  
  Loads all the template text from the template's source, parses and
  compiles it.  If successful, returns true; otherwise returns false and
  sets C<$Text::Template::ERROR>.  If the template is already compiled,
  it returns true and does nothing.  
  
  You don't usually need to invoke this function, because C<fill_in>
  (see below) compiles the template if it isn't compiled already.
  
  If there is an argument to this function, it must be a reference to an
  array containing alternative delimiter strings.  See C<"Alternative
  Delimiters">, below.
  
  =head2 C<fill_in>
  
  	$template->fill_in(OPTIONS);
  
  Fills in a template.  Returns the resulting text if successful.
  Otherwise, returns C<undef>  and sets C<$Text::Template::ERROR>.
  
  The I<OPTIONS> are a hash, or a list of key-value pairs.  You can
  write the key names in any of the six usual styles as above; this
  means that where this manual says C<PACKAGE> (for example) you can
  actually use any of
  
  	PACKAGE Package package -PACKAGE -Package -package
  
  Pick a style you like and stick with it.  The all-lowercase versions
  may yield spurious warnings about
  
  	Ambiguous use of package => resolved to "package"
  
  so you might like to avoid them and use the capitalized versions.
  
  At present, there are eight legal options:  C<PACKAGE>, C<BROKEN>,
  C<BROKEN_ARG>, C<SAFE>, C<HASH>, C<OUTPUT>, and C<DELIMITERS>.
  
  =over 4
  
  =item C<PACKAGE>
  
  C<PACKAGE> specifies the name of a package in which the program
  fragments should be evaluated.  The default is to use the package from
  which C<fill_in> was called.  For example, consider this template:
  
  	The value of the variable x is {$x}.
  
  If you use C<$template-E<gt>fill_in(PACKAGE =E<gt> 'R')> , then the C<$x> in
  the template is actually replaced with the value of C<$R::x>.  If you
  omit the C<PACKAGE> option, C<$x> will be replaced with the value of
  the C<$x> variable in the package that actually called C<fill_in>.
  
  You should almost always use C<PACKAGE>.  If you don't, and your
  template makes changes to variables, those changes will be propagated
  back into the main program.  Evaluating the template in a private
  package helps prevent this.  The template can still modify variables
  in your program if it wants to, but it will have to do so explicitly.
  See the section at the end on `Security'.
  
  Here's an example of using C<PACKAGE>:
  
  	Your Royal Highness,
  
  	Enclosed please find a list of things I have gotten
  	for you since 1907:
  
  	{ foreach $item (@items) {
              $item_no++;
  	    $OUT .= " $item_no. \u$item\n";
  	  }
  	}
  
  	Signed,
  	Lord High Chamberlain
  
  We want to pass in an array which will be assigned to the array
  C<@items>.  Here's how to do that:
  
  	@items = ('ivory', 'apes', 'peacocks', );
  	$template->fill_in();
  
  This is not very safe.  The reason this isn't as safe is that if you
  had a variable named C<$item_no> in scope in your program at the point
  you called C<fill_in>, its value would be clobbered by the act of
  filling out the template.  The problem is the same as if you had
  written a subroutine that used those variables in the same way that
  the template does.  (C<$OUT> is special in templates and is always
  safe.)
  
  One solution to this is to make the C<$item_no> variable private to the
  template by declaring it with C<my>.  If the template does this, you
  are safe.
  
  But if you use the C<PACKAGE> option, you will probably be safe even
  if the template does I<not> declare its variables with C<my>:
  
  	@Q::items = ('ivory', 'apes', 'peacocks', );
  	$template->fill_in(PACKAGE => 'Q');
  
  In this case the template will clobber the variable C<$Q::item_no>,
  which is not related to the one your program was using.
  
  Templates cannot affect variables in the main program that are
  declared with C<my>, unless you give the template references to those
  variables.
  
  =item C<HASH>
  
  You may not want to put the template variables into a package.
  Packages can be hard to manage:  You can't copy them, for example.
  C<HASH> provides an alternative.  
  
  The value for C<HASH> should be a reference to a hash that maps
  variable names to values.  For example, 
  
  	$template->fill_in(HASH => { recipient => "The King",
  				     items => ['gold', 'frankincense', 'myrrh'],
  	                             object => \$self,
  				   });
  
  will fill out the template and use C<"The King"> as the value of
  C<$recipient> and the list of items as the value of C<@items>.  Note
  that we pass an array reference, but inside the template it appears as
  an array.  In general, anything other than a simple string or number
  should be passed by reference.
  
  We also want to pass an object, which is in C<$self>; note that we
  pass a reference to the object, C<\$self> instead.  Since we've passed
  a reference to a scalar, inside the template the object appears as
  C<$object>.  
  
  The full details of how it works are a little involved, so you might
  want to skip to the next section.
  
  Suppose the key in the hash is I<key> and the value is I<value>.  
  
  =over 4
  
  =item *
  
  If the I<value> is C<undef>, then any variables named C<$key>,
  C<@key>, C<%key>, etc., are undefined.  
  
  =item *
  
  If the I<value> is a string or a number, then C<$key> is set to that
  value in the template.
  
  =item *
  
  For anything else, you must pass a reference.
  
  If the I<value> is a reference to an array, then C<@key> is set to
  that array.  If the I<value> is a reference to a hash, then C<%key> is
  set to that hash.  Similarly if I<value> is any other kind of
  reference.  This means that
  
  	var => "foo"
  
  and
  
  	var => \"foo"
  
  have almost exactly the same effect.  (The difference is that in the
  former case, the value is copied, and in the latter case it is
  aliased.)  
  
  =item *
  
  In particular, if you want the template to get an object or any kind,
  you must pass a reference to it:
  
  	$template->fill_in(HASH => { database_handle => \$dbh, ... });
  
  If you do this, the template will have a variable C<$database_handle>
  which is the database handle object.  If you leave out the C<\>, the
  template will have a hash C<%database_handle>, which exposes the
  internal structure of the database handle object; you don't want that.
  
  =back
  
  Normally, the way this works is by allocating a private package,
  loading all the variables into the package, and then filling out the
  template as if you had specified that package.  A new package is
  allocated each time.  However, if you I<also> use the C<PACKAGE>
  option, C<Text::Template> loads the variables into the package you
  specified, and they stay there after the call returns.  Subsequent
  calls to C<fill_in> that use the same package will pick up the values
  you loaded in.
  
  If the argument of C<HASH> is a reference to an array instead of a
  reference to a hash, then the array should contain a list of hashes
  whose contents are loaded into the template package one after the
  other.  You can use this feature if you want to combine several sets
  of variables.  For example, one set of variables might be the defaults
  for a fill-in form, and the second set might be the user inputs, which
  override the defaults when they are present:
  
  	$template->fill_in(HASH => [\%defaults, \%user_input]);
  
  You can also use this to set two variables with the same name:
  
  	$template->fill_in(HASH => [{ v => "The King" },
                                      { v => [1,2,3] },
  	                           ]
                            );
  
  This sets C<$v> to C<"The King"> and C<@v> to C<(1,2,3)>.	
  
  =item C<BROKEN>
  
  If any of the program fragments fails to compile or aborts for any
  reason, and you have set the C<BROKEN> option to a function reference,
  C<Text::Template> will invoke the function.  This function is called
  the I<C<BROKEN> function>.  The C<BROKEN> function will tell
  C<Text::Template> what to do next.  
  
  If the C<BROKEN> function returns C<undef>, C<Text::Template> will
  immediately abort processing the template and return the text that it
  has accumulated so far.  If your function does this, it should set a
  flag that you can examine after C<fill_in> returns so that you can
  tell whether there was a premature return or not. 
  
  If the C<BROKEN> function returns any other value, that value will be
  interpolated into the template as if that value had been the return
  value of the program fragment to begin with.  For example, if the
  C<BROKEN> function returns an error string, the error string will be
  interpolated into the output of the template in place of the program
  fragment that cased the error.
  
  If you don't specify a C<BROKEN> function, C<Text::Template> supplies
  a default one that returns something like
  
  	Program fragment delivered error ``Illegal division by 0 at
  	template line 37''
  
  (Note that the format of this message has changed slightly since
  version 1.31.)  The return value of the C<BROKEN> function is
  interpolated into the template at the place the error occurred, so
  that this template:
  
  	(3+4)*5 = { 3+4)*5 }
  
  yields this result:
  
  	(3+4)*5 = Program fragment delivered error ``syntax error at template line 1''
  
  If you specify a value for the C<BROKEN> attribute, it should be a
  reference to a function that C<fill_in> can call instead of the
  default function.
  
  C<fill_in> will pass a hash to the C<broken> function.
  The hash will have at least these three members:
  
  =over 4
  
  =item C<text>
  
  The source code of the program fragment that failed
  
  =item C<error>
  
  The text of the error message (C<$@>) generated by eval.
  
  The text has been modified to omit the trailing newline and to include
  the name of the template file (if there was one).  The line number
  counts from the beginning of the template, not from the beginning of
  the failed program fragment.
  
  =item C<lineno>
  
  The line number of the template at which the program fragment began.
  
  =back
  
  There may also be an C<arg> member.  See C<BROKEN_ARG>, below
  
  =item C<BROKEN_ARG>
  
  If you supply the C<BROKEN_ARG> option to C<fill_in>, the value of the
  option is passed to the C<BROKEN> function whenever it is called.  The
  default C<BROKEN> function ignores the C<BROKEN_ARG>, but you can
  write a custom C<BROKEN> function that uses the C<BROKEN_ARG> to get
  more information about what went wrong. 
  
  The C<BROKEN> function could also use the C<BROKEN_ARG> as a reference
  to store an error message or some other information that it wants to
  communicate back to the caller.  For example:
  
  	$error = '';
  
  	sub my_broken {	
  	   my %args = @_;
  	   my $err_ref = $args{arg};
  	   ...
  	   $$err_ref = "Some error message";
  	   return undef;
  	}
  
  	$template->fill_in(BROKEN => \&my_broken,
  			   BROKEN_ARG => \$error,
  			  );
  
  	if ($error) {
  	  die "It didn't work: $error";
  	}
  
  If one of the program fragments in the template fails, it will call
  the C<BROKEN> function, C<my_broken>, and pass it the C<BROKEN_ARG>,
  which is a reference to C<$error>.  C<my_broken> can store an error
  message into C<$error> this way.  Then the function that called
  C<fill_in> can see if C<my_broken> has left an error message for it
  to find, and proceed accordingly.
  
  =item C<SAFE>
  
  If you give C<fill_in> a C<SAFE> option, its value should be a safe
  compartment object from the C<Safe> package.  All evaluation of
  program fragments will be performed in this compartment.  See L<Safe>
  for full details about such compartments and how to restrict the
  operations that can be performed in them.
  
  If you use the C<PACKAGE> option with C<SAFE>, the package you specify
  will be placed into the safe compartment and evaluation will take
  place in that package as usual.  
  
  If not, C<SAFE> operation is a little different from the default.
  Usually, if you don't specify a package, evaluation of program
  fragments occurs in the package from which the template was invoked.
  But in C<SAFE> mode the evaluation occurs inside the safe compartment
  and cannot affect the calling package.  Normally, if you use C<HASH>
  without C<PACKAGE>, the hash variables are imported into a private,
  one-use-only package.  But if you use C<HASH> and C<SAFE> together
  without C<PACKAGE>, the hash variables will just be loaded into the
  root namespace of the C<Safe> compartment.
  
  =item C<OUTPUT>
  
  If your template is going to generate a lot of text that you are just
  going to print out again anyway,  you can save memory by having
  C<Text::Template> print out the text as it is generated instead of
  making it into a big string and returning the string.  If you supply
  the C<OUTPUT> option to C<fill_in>, the value should be a filehandle.
  The generated text will be printed to this filehandle as it is
  constructed.  For example:
  
  	$template->fill_in(OUTPUT => \*STDOUT, ...);
  
  fills in the C<$template> as usual, but the results are immediately
  printed to STDOUT.  This may result in the output appearing more
  quickly than it would have otherwise.
  
  If you use C<OUTPUT>, the return value from C<fill_in> is still true on
  success and false on failure, but the complete text is not returned to
  the caller.
  
  =item C<PREPEND>
  
  You can have some Perl code prepended automatically to the beginning
  of every program fragment.  See L<C<PREPEND> feature and using
  C<strict> in templates> below.
  
  =item C<DELIMITERS>
  
  If this option is present, its value should be a reference to a list
  of two strings.  The first string is the string that signals the
  beginning of each program fragment, and the second string is the
  string that signals the end of each program fragment.  See
  L<"Alternative Delimiters">, below.  
  
  If you specify C<DELIMITERS> in the call to C<fill_in>, they override
  any delimiters you set when you created the template object with
  C<new>. 
  
  =back
  
  =head1 Convenience Functions
  
  =head2 C<fill_this_in>
  
  The basic way to fill in a template is to create a template object and
  then call C<fill_in> on it.   This is useful if you want to fill in
  the same template more than once.
  
  In some programs, this can be cumbersome.  C<fill_this_in> accepts a
  string, which contains the template, and a list of options, which are
  passed to C<fill_in> as above.  It constructs the template object for
  you, fills it in as specified, and returns the results.  It returns
  C<undef> and sets C<$Text::Template::ERROR> if it couldn't generate
  any results.
  
  An example:
  
  	$Q::name = 'Donald';
  	$Q::amount = 141.61;
  	$Q::part = 'hyoid bone';
  
  	$text = Text::Template->fill_this_in( <<'EOM', PACKAGE => Q);
  	Dear {$name},
  	You owe me \\${sprintf('%.2f', $amount)}.  
  	Pay or I will break your {$part}.
  		Love,
  		Grand Vizopteryx of Irkutsk.
  	EOM
  
  Notice how we included the template in-line in the program by using a
  `here document' with the C<E<lt>E<lt>> notation.
  
  C<fill_this_in> is a deprecated feature.  It is only here for
  backwards compatibility, and may be removed in some far-future version
  in C<Text::Template>.  You should use C<fill_in_string> instead.  It
  is described in the next section.
  
  =head2 C<fill_in_string>
  
  It is stupid that C<fill_this_in> is a class method.  It should have
  been just an imported function, so that you could omit the
  C<Text::Template-E<gt>> in the example above.  But I made the mistake
  four years ago and it is too late to change it.
  
  C<fill_in_string> is exactly like C<fill_this_in> except that it is
  not a method and you can omit the C<Text::Template-E<gt>> and just say
  
  	print fill_in_string(<<'EOM', ...);
  	Dear {$name},
  	  ...
  	EOM
  
  To use C<fill_in_string>, you need to say
  
  	use Text::Template 'fill_in_string';
  
  at the top of your program.   You should probably use
  C<fill_in_string> instead of C<fill_this_in>.
  
  =head2 C<fill_in_file>
  
  If you import C<fill_in_file>, you can say
  
  	$text = fill_in_file(filename, ...);
  
  The C<...> are passed to C<fill_in> as above.  The filename is the
  name of the file that contains the template you want to fill in.  It
  returns the result text. or C<undef>, as usual.
  
  If you are going to fill in the same file more than once in the same
  program you should use the longer C<new> / C<fill_in> sequence instead.
  It will be a lot faster because it only has to read and parse the file
  once.
  
  =head2 Including files into templates
  
  People always ask for this.  ``Why don't you have an include
  function?'' they want to know.  The short answer is this is Perl, and
  Perl already has an include function.  If you want it, you can just put
  
  	{qx{cat filename}}
  
  into your template.  VoilE<agrave>.
  
  If you don't want to use C<cat>, you can write a little four-line
  function that opens a file and dumps out its contents, and call it
  from the template.  I wrote one for you.  In the template, you can say
  
  	{Text::Template::_load_text(filename)}
  
  If that is too verbose, here is a trick.  Suppose the template package
  that you are going to be mentioning in the C<fill_in> call is package
  C<Q>.  Then in the main program, write
  
  	*Q::include = \&Text::Template::_load_text;
  
  This imports the C<_load_text> function into package C<Q> with the
  name C<include>.  From then on, any template that you fill in with
  package C<Q> can say
  
  	{include(filename)}
  
  to insert the text from the named file at that point.  If you are
  using the C<HASH> option instead, just put C<include =E<gt>
  \&Text::Template::_load_text> into the hash instead of importing it
  explicitly.
  
  Suppose you don't want to insert a plain text file, but rather you
  want to include one template within another?  Just use C<fill_in_file>
  in the template itself:
  
  	{Text::Template::fill_in_file(filename)}
  
  You can do the same importing trick if this is too much to type.
  
  =head1 Miscellaneous
  
  =head2 C<my> variables
  
  People are frequently surprised when this doesn't work:
  
  	my $recipient = 'The King';
  	my $text = fill_in_file('formletter.tmpl');
  
  The text C<The King> doesn't get into the form letter.  Why not?
  Because C<$recipient> is a C<my> variable, and the whole point of
  C<my> variables is that they're private and inaccessible except in the
  scope in which they're declared.  The template is not part of that
  scope, so the template can't see C<$recipient>.  
  
  If that's not the behavior you want, don't use C<my>.  C<my> means a
  private variable, and in this case you don't want the variable to be
  private.  Put the variables into package variables in some other
  package, and use the C<PACKAGE> option to C<fill_in>:
  
  	$Q::recipient = $recipient;
  	my $text = fill_in_file('formletter.tmpl', PACKAGE => 'Q');
  
  or pass the names and values in a hash with the C<HASH> option:
  
  	my $text = fill_in_file('formletter.tmpl', HASH => { recipient => $recipient });
  
  =head2 Security Matters
  
  All variables are evaluated in the package you specify with the
  C<PACKAGE> option of C<fill_in>.  if you use this option, and if your
  templates don't do anything egregiously stupid, you won't have to
  worry that evaluation of the little programs will creep out into the
  rest of your program and wreck something.
  
  Nevertheless, there's really no way (except with C<Safe>) to protect
  against a template that says
  
  	{ $Important::Secret::Security::Enable = 0; 
  	  # Disable security checks in this program 
  	}
  
  or
  
  	{ $/ = "ho ho ho";   # Sabotage future uses of <FH>.
  	  # $/ is always a global variable
  	}
  
  or even
  
  	{ system("rm -rf /") }
  
  so B<don't> go filling in templates unless you're sure you know what's
  in them.  If you're worried, or you can't trust the person who wrote
  the template, use the C<SAFE> option.
  
  A final warning: program fragments run a small risk of accidentally
  clobbering local variables in the C<fill_in> function itself.  These
  variables all have names that begin with C<$fi_>, so if you stay away
  from those names you'll be safe.  (Of course, if you're a real wizard
  you can tamper with them deliberately for exciting effects; this is
  actually how C<$OUT> works.)  I can fix this, but it will make the
  package slower to do it, so I would prefer not to.  If you are worried
  about this, send me mail and I will show you what to do about it.
  
  =head2 Alternative Delimiters
  
  Lorenzo Valdettaro pointed out that if you are using C<Text::Template>
  to generate TeX output, the choice of braces as the program fragment
  delimiters makes you suffer suffer suffer.  Starting in version 1.20,
  you can change the choice of delimiters to something other than curly
  braces.
  
  In either the C<new()> call or the C<fill_in()> call, you can specify
  an alternative set of delimiters with the C<DELIMITERS> option.  For
  example, if you would like code fragments to be delimited by C<[@-->
  and C<--@]> instead of C<{> and C<}>, use
  
  	... DELIMITERS => [ '[@--', '--@]' ], ...
  
  Note that these delimiters are I<literal strings>, not regexes.  (I
  tried for regexes, but it complicates the lexical analysis too much.)
  Note also that C<DELIMITERS> disables the special meaning of the
  backslash, so if you want to include the delimiters in the literal
  text of your template file, you are out of luck---it is up to you to
  choose delimiters that do not conflict with what you are doing.  The
  delimiter strings may still appear inside of program fragments as long
  as they nest properly.  This means that if for some reason you
  absolutely must have a program fragment that mentions one of the
  delimiters, like this:
  
  	[@--
  		print "Oh no, a delimiter: --@]\n"
  	--@]
  
  you may be able to make it work by doing this instead:
  
  	[@--
  		# Fake matching delimiter in a comment: [@--
  		print "Oh no, a delimiter: --@]\n"
  	--@]
  
  It may be safer to choose delimiters that begin with a newline
  character.  
  
  Because the parsing of templates is simplified by the absence of
  backslash escapes, using alternative C<DELIMITERS> may speed up the
  parsing process by 20-25%.  This shows that my original choice of C<{>
  and C<}> was very bad. 
  
  =head2 C<PREPEND> feature and using C<strict> in templates
  
  Suppose you would like to use C<strict> in your templates to detect
  undeclared variables and the like.  But each code fragment is a
  separate lexical scope, so you have to turn on C<strict> at the top of
  each and every code fragment:
  
  	{ use strict;
  	  use vars '$foo';
  	  $foo = 14;
  	  ...
  	}
  
  	...
  
  	{ # we forgot to put `use strict' here
  	  my $result = $boo + 12;    # $boo is misspelled and should be $foo
  	  # No error is raised on `$boo'
  	}
  
  Because we didn't put C<use strict> at the top of the second fragment,
  it was only active in the first fragment, and we didn't get any
  C<strict> checking in the second fragment.  Then we misspelled C<$foo>
  and the error wasn't caught.  
  
  C<Text::Template> version 1.22 and higher has a new feature to make
  this easier.  You can specify that any text at all be automatically
  added to the beginning of each program fragment.  
  
  When you make a call to C<fill_in>, you can specify a
  
  	PREPEND => 'some perl statements here'
  
  option; the statements will be prepended to each program fragment for
  that one call only.  Suppose that the C<fill_in> call included a
  
  	PREPEND => 'use strict;'
  
  option, and that the template looked like this:
  
  	{ use vars '$foo';
  	  $foo = 14;
  	  ...
  	}
  
  	...
  
  	{ my $result = $boo + 12;    # $boo is misspelled and should be $foo
  	  ...
  	}
  
  The code in the second fragment would fail, because C<$boo> has not
  been declared.  C<use strict> was implied, even though you did not
  write it explicitly, because the C<PREPEND> option added it for you
  automatically.
  
  There are two other ways to do this.  At the time you create the
  template object with C<new>, you can also supply a C<PREPEND> option,
  in which case the statements will be prepended each time you fill in
  that template.  If the C<fill_in> call has its own C<PREPEND> option,
  this overrides the one specified at the time you created the
  template.  Finally, you can make the class method call
  
  	Text::Template->always_prepend('perl statements');
  
  If you do this, then call calls to C<fill_in> for I<any> template will
  attach the perl statements to the beginning of each program fragment,
  except where overridden by C<PREPEND> options to C<new> or C<fill_in>.
  
  =head2 Prepending in Derived Classes
  
  This section is technical, and you should skip it on the first few
  readings. 
  
  Normally there are three places that prepended text could come from.
  It could come from the C<PREPEND> option in the C<fill_in> call, from
  the C<PREPEND> option in the C<new> call that created the template
  object, or from the argument of the C<always_prepend> call.
  C<Text::Template> looks for these three things in order and takes the
  first one that it finds.
  
  In a subclass of C<Text::Template>, this last possibility is
  ambiguous.  Suppose C<S> is a subclass of C<Text::Template>.  Should 
  
  	Text::Template->always_prepend(...);
  
  affect objects in class C<Derived>?  The answer is that you can have it
  either way.  
  
  The C<always_prepend> value for C<Text::Template> is normally stored
  in  a hash variable named C<%GLOBAL_PREPEND> under the key
  C<Text::Template>.  When C<Text::Template> looks to see what text to
  prepend, it first looks in the template object itself, and if not, it
  looks in C<$GLOBAL_PREPEND{I<class>}> where I<class> is the class to
  which the template object belongs.  If it doesn't find any value, it
  looks in C<$GLOBAL_PREPEND{'Text::Template'}>.  This means that
  objects in class C<Derived> I<will> be affected by
  
  	Text::Template->always_prepend(...);
  
  I<unless> there is also a call to
  
  	Derived->always_prepend(...);
  
  So when you're designing your derived class, you can arrange to have
  your objects ignore C<Text::Template::always_prepend> calls by simply
  putting C<Derived-E<gt>always_prepend('')> at the top of your module.
  
  Of course, there is also a final escape hatch: Templates support a
  C<prepend_text> that is used to look up the appropriate text to be
  prepended at C<fill_in> time.  Your derived class can override this
  method to get an arbitrary effect.
  
  =head2 JavaScript
  
  Jennifer D. St Clair asks:
  
  	> Most of my pages contain JavaScript and Stylesheets.
          > How do I change the template identifier?  
  
  Jennifer is worried about the braces in the JavaScript being taken as
  the delimiters of the Perl program fragments.  Of course, disaster
  will ensue when perl tries to evaluate these as if they were Perl
  programs.  The best choice is to find some unambiguous delimiter
  strings that you can use in your template instead of curly braces, and
  then use the C<DELIMITERS> option.  However, if you can't do this for
  some reason, there are  two easy workarounds:
  
  1. You can put C<\> in front of C<{>, C<}>, or C<\> to remove its
  special meaning.  So, for example, instead of
  
  	    if (br== "n3") { 
  		// etc.
  	    }
  
  you can put
  
  	    if (br== "n3") \{ 
  		// etc.
  	    \}
  
  and it'll come out of the template engine the way you want.
  
  But here is another method that is probably better.  To see how it
  works, first consider what happens if you put this into a template:
  
  	    { 'foo' }
  
  Since it's in braces, it gets evaluated, and obviously, this is going
  to turn into
  
  	    foo
  
  So now here's the trick: In Perl, C<q{...}> is the same as C<'...'>.
  So if we wrote
  
  	    {q{foo}}
  
  it would turn into 
  
  	    foo
  
  So for your JavaScript, just write
  
  	    {q{if (br== "n3") { 
  	  	 // etc.
  	       }}
  	    }
  
  and it'll come out as
  
  	      if (br== "n3") { 
  	  	  // etc.
  	      }
  
  which is what you want.
  
  =head2 Shut Up!
  
  People sometimes try to put an initialization section at the top of
  their templates, like this:
  
  	{ ...
  	  $var = 17;
  	}
  
  Then they complain because there is a C<17> at the top of the output
  that they didn't want to have there.  
  
  Remember that a program fragment is replaced with its own return
  value, and that in Perl the return value of a code block is the value
  of the last expression that was evaluated, which in this case is 17.
  If it didn't do that, you wouldn't be able to write C<{$recipient}>
  and have the recipient filled in.
  
  To prevent the 17 from appearing in the output is very simple:
  
  	{ ...
  	  $var = 17;
  	  '';
  	}
  
  Now the last expression evaluated yields the empty string, which is
  invisible.  If you don't like the way this looks, use
  
  	{ ...
  	  $var = 17;
  	  ($SILENTLY);
  	}
  
  instead.  Presumably, C<$SILENTLY> has no value, so nothing will be
  interpolated.  This is what is known as a `trick'.
  
  =head2 Compatibility
  
  Every effort has been made to make this module compatible with older
  versions.  The only known exceptions follow:
  
  The output format of the default C<BROKEN> subroutine has changed
  twice, most recently between versions 1.31 and 1.40.
  
  Starting in version 1.10, the C<$OUT> variable is arrogated for a
  special meaning.  If you had templates before version 1.10 that
  happened to use a variable named C<$OUT>, you will have to change them
  to use some other variable or all sorts of strangeness will result.
  
  Between versions 0.1b and 1.00 the behavior of the \ metacharacter
  changed.  In 0.1b, \\ was special everywhere, and the template
  processor always replaced it with a single backslash before passing
  the code to Perl for evaluation.  The rule now is more complicated but
  probably more convenient.  See the section on backslash processing,
  below, for a full discussion.
  
  =head2 Backslash Processing
  
  In C<Text::Template> beta versions, the backslash was special whenever
  it appeared before a brace or another backslash.  That meant that
  while C<{"\n"}> did indeed generate a newline, C<{"\\"}> did not
  generate a backslash, because the code passed to Perl for evaluation
  was C<"\"> which is a syntax error.  If you wanted a backslash, you
  would have had to write C<{"\\\\"}>.
  
  In C<Text::Template> versions 1.00 through 1.10, there was a bug:
  Backslash was special everywhere.  In these versions, C<{"\n"}>
  generated the letter C<n>.
  
  The bug has been corrected in version 1.11, but I did not go back to
  exactly the old rule, because I did not like the idea of having to
  write C<{"\\\\"}> to get one backslash.  The rule is now more
  complicated to remember, but probably easier to use.  The rule is now:
  Backslashes are always passed to Perl unchanged I<unless> they occur
  as part of a sequence like C<\\\\\\{> or C<\\\\\\}>.  In these
  contexts, they are special; C<\\> is replaced with C<\>, and C<\{> and
  C<\}> signal a literal brace. 
  
  Examples:
  
  	\{ foo \}
  
  is I<not> evaluated, because the C<\> before the braces signals that
  they should be taken literally.  The result in the output looks like this: 
  
  	{ foo }
  
  This is a syntax error:
  
  	{ "foo}" }
  
  because C<Text::Template> thinks that the code ends at the first C<}>,
  and then gets upset when it sees the second one.  To make this work
  correctly, use
  
  	{ "foo\}" }
  
  This passes C<"foo}"> to Perl for evaluation.  Note there's no C<\> in
  the evaluated code.  If you really want a C<\> in the evaluated code,
  use
  
  	{ "foo\\\}" }
  
  This passes C<"foo\}"> to Perl for evaluation.
  
  Starting with C<Text::Template> version 1.20, backslash processing is
  disabled if you use the C<DELIMITERS> option to specify alternative
  delimiter strings.
  
  =head2 A short note about C<$Text::Template::ERROR>
  
  In the past some people have fretted about `violating the package
  boundary' by examining a variable inside the C<Text::Template>
  package.  Don't feel this way.  C<$Text::Template::ERROR> is part of
  the published, official interface to this package.  It is perfectly OK
  to inspect this variable.  The interface is not going to change.
  
  If it really, really bothers you, you can import a function called
  C<TTerror> that returns the current value of the C<$ERROR> variable.
  So you can say:
  
  	use Text::Template 'TTerror';
  
  	my $template = new Text::Template (SOURCE => $filename);
  	unless ($template) {
  	  my $err = TTerror;
  	  die "Couldn't make template: $err; aborting";
  	}
  
  I don't see what benefit this has over just doing this:
  
  	use Text::Template;
  
  	my $template = new Text::Template (SOURCE => $filename)
  	  or die "Couldn't make template: $Text::Template::ERROR; aborting";
  
  But if it makes you happy to do it that way, go ahead.
  
  =head2 Sticky Widgets in Template Files
  
  The C<CGI> module provides functions for `sticky widgets', which are
  form input controls that retain their values from one page to the
  next.   Sometimes people want to know how to include these widgets
  into their template output.
  
  It's totally straightforward.  Just call the C<CGI> functions from
  inside the template:
  
  	{ $q->checkbox_group(NAME => 'toppings',
  		  	     LINEBREAK => true,
  			     COLUMNS => 3,
  			     VALUES => \@toppings,
  			    );
  	}
  
  =head2 Automatic preprocessing of program fragments
  
  It may be useful to preprocess the program fragments before they are
  evaluated.  See C<Text::Template::Preprocess> for more details.
  
  =head2 Automatic postprocessing of template hunks
  
  It may be useful to process hunks of output before they are appended to
  the result text.  For this, subclass and replace the C<append_text_to_result>
  method.  It is passed a list of pairs with these entries:
  
    handle - a filehandle to which to print the desired output
    out    - a ref to a string to which to append, to use if handle is not given
    text   - the text that will be appended
    type   - where the text came from: TEXT for literal text, PROG for code
  
  =head1 SUPPORT
  
  This software may have bugs.  Suggestions and bug reports are always welcome.
  Send them to C<mjd-perl-template+@plover.com>.  (That is my address, not the
  address of the mailing list.  The mailing list address is a secret.)
  
  =head1 THANKS
  
  Many thanks to the following people for offering support,
  encouragement, advice, bug reports, and all the other good stuff.  
  
  David H. Adler /
  Joel Appelbaum /
  Klaus Arnhold /
  AntE<oacute>nio AragE<atilde>o /
  Kevin Atteson /
  Chris.Brezil /
  Mike Brodhead /
  Tom Brown /
  Dr. Frank Bucolo /
  Tim Bunce /
  Juan E. Camacho /
  Itamar Almeida de Carvalho /
  Joseph Cheek /
  Gene Damon /
  San Deng /
  Bob Dougherty /
  Marek Grac /
  Dan Franklin /
  gary at dls.net /
  Todd A. Green /
  Donald L. Greer Jr. /
  Michelangelo Grigni /
  Zac Hansen /
  Tom Henry /
  Jarko Hietaniemi /
  Matt X. Hunter /
  Robert M. Ioffe /
  Daniel LaLiberte /
  Reuven M. Lerner /
  Trip Lilley / 
  Yannis Livassof /
  Val Luck /
  Kevin Madsen /
  David Marshall /
  James Mastros /
  Joel Meulenberg /
  Jason Moore /
  Sergey Myasnikov /
  Chris Nandor /
  Bek Oberin /
  Steve Palincsar /
  Ron Pero /
  Hans Persson /
  Sean Roehnelt /
  Jonathan Roy /
  Shabbir J. Safdar /
  Jennifer D. St Clair /
  Uwe Schneider /
  Randal L. Schwartz /
  Michael G Schwern /
  Yonat Sharon /
  Brian C. Shensky /
  Niklas Skoglund /
  Tom Snee /
  Fred Steinberg /
  Hans Stoop /
  Michael J. Suzio /
  Dennis Taylor /
  James H. Thompson /
  Shad Todd /
  Lieven Tomme /
  Lorenzo Valdettaro /
  Larry Virden /
  Andy Wardley /
  Archie Warnock /
  Chris Wesley /
  Matt Womer /
  Andrew G Wood /
  Daini Xie /
  Michaely Yeung
  
  Special thanks to:
  
  =over 2
  
  =item Jonathan Roy 
  
  for telling me how to do the C<Safe> support (I spent two years
  worrying about it, and then Jonathan pointed out that it was trivial.)
  
  =item Ranjit Bhatnagar 
  
  for demanding less verbose fragments like they have in ASP, for
  helping me figure out the Right Thing, and, especially, for talking me
  out of adding any new syntax.  These discussions resulted in the
  C<$OUT> feature.
  
  =back
  
  =head2 Bugs and Caveats
  
  C<my> variables in C<fill_in> are still susceptible to being clobbered
  by template evaluation.  They all begin with C<fi_>, so avoid those
  names in your templates.
  
  The line number information will be wrong if the template's lines are
  not terminated by C<"\n">.  You should let me know if this is a
  problem.  If you do, I will fix it.
  
  The C<$OUT> variable has a special meaning in templates, so you cannot
  use it as if it were a regular variable.
  
  There are not quite enough tests in the test suite.
  
  =head1 SOURCE
  
  The development version is on github at L<http://github.com/mschout/perl-text-template>
  and may be cloned from L<git://github.com/mschout/perl-text-template.git>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to bug-text-template@rt.cpan.org or through the web interface at:
   http://rt.cpan.org/Public/Dist/Display.html?Name=Text-Template
  
  =head1 AUTHOR
  
  Mark Jason Dominus, Plover Systems
  
  Please send questions and other remarks about this software to
  C<mjd-perl-template+@plover.com>
  
  You can join a very low-volume (E<lt>10 messages per year) mailing
  list for announcements about this package.  Send an empty note to
  C<mjd-perl-template-request@plover.com> to join.
  
  For updates, visit C<http://www.plover.com/~mjd/perl/Template/>.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Mark Jason Dominus <mjd@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEXT_TEMPLATE

$fatpacked{"Text/Template/Preprocess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_TEMPLATE_PREPROCESS';
  
  package Text::Template::Preprocess;
  $Text::Template::Preprocess::VERSION = '1.47';
  # ABSTRACT: Expand template text with embedded Perl
  
  use Text::Template;
  @ISA = qw(Text::Template);
  
  sub fill_in {
    my $self = shift;
    my (%args) = @_;
    my $pp = $args{PREPROCESSOR} || $self->{PREPROCESSOR} ;
    if ($pp) {
      local $_ = $self->source();
  #    print "# fill_in: before <$_>\n";
      &$pp;
  #    print "# fill_in: after <$_>\n";
      $self->set_source_data($_);
    }
    $self->SUPER::fill_in(@_);
  }
  
  sub preprocessor {
    my ($self, $pp) = @_;
    my $old_pp = $self->{PREPROCESSOR};
    $self->{PREPROCESSOR} = $pp if @_ > 1;  # OK to pass $pp=undef
    $old_pp;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Text::Template::Preprocess - Expand template text with embedded Perl
  
  =head1 VERSION
  
  version 1.47
  
  =head1 SYNOPSIS
  
   use Text::Template::Preprocess;
  
   my $t = Text::Template::Preprocess->new(...);  # identical to Text::Template
  
   # Fill in template, but preprocess each code fragment with pp().
   my $result = $t->fill_in(..., PREPROCESSOR => \&pp);
  
   my $old_pp = $t->preprocessor(\&new_pp);
  
  =head1 DESCRIPTION
  
  C<Text::Template::Preprocess> provides a new C<PREPROCESSOR> option to
  C<fill_in>.  If the C<PREPROCESSOR> option is supplied, it must be a
  reference to a preprocessor subroutine.  When filling out a template,
  C<Text::Template::Preprocessor> will use this subroutine to preprocess
  the program fragment prior to evaluating the code.
  
  The preprocessor subroutine will be called repeatedly, once for each
  program fragment.  The program fragment will be in C<$_>.  The
  subroutine should modify the contents of C<$_> and return.
  C<Text::Template::Preprocess> will then execute contents of C<$_> and
  insert the result into the appropriate part of the template.
  
  C<Text::Template::Preprocess> objects also support a utility method,
  C<preprocessor()>, which sets a new preprocessor for the object.  This
  preprocessor is used for all subsequent calls to C<fill_in> except
  where overridden by an explicit C<PREPROCESSOR> option.
  C<preprocessor()> returns the previous default preprocessor function,
  or undefined if there wasn't one.  When invoked with no arguments,
  C<preprocessor()> returns the object's current default preprocessor
  function without changing it.
  
  In all other respects, C<Text::Template::Preprocess> is identical to
  C<Text::Template>.
  
  =head1 WHY?
  
  One possible purpose:  If your files contain a lot of JavaScript, like
  this:
  
          Plain text here...
          { perl code }
          <script language=JavaScript>
       	      if (br== "n3") { 
  	  	  // etc.
  	      }
          </script>
          { more perl code }
          More plain text...
  
  You don't want C<Text::Template> to confuse the curly braces in the
  JavaScript program with executable Perl code.  One strategy:
  
          sub quote_scripts {
            s(<script(.*?)</script>)(q{$1})gsi;
          }
  
  Then use C<PREPROCESSOR =E<gt> \&quote_scripts>.  This will transform 
  
  =head1 SEE ALSO
  
  L<Text::Template>
  
  =head1 SOURCE
  
  The development version is on github at L<http://github.com/mschout/perl-text-template>
  and may be cloned from L<git://github.com/mschout/perl-text-template.git>
  
  =head1 BUGS
  
  Please report any bugs or feature requests to bug-text-template@rt.cpan.org or through the web interface at:
   http://rt.cpan.org/Public/Dist/Display.html?Name=Text-Template
  
  =head1 AUTHOR
  
  Mark Jason Dominus, Plover Systems
  
  Please send questions and other remarks about this software to
  C<mjd-perl-template+@plover.com>
  
  You can join a very low-volume (E<lt>10 messages per year) mailing
  list for announcements about this package.  Send an empty note to
  C<mjd-perl-template-request@plover.com> to join.
  
  For updates, visit C<http://www.plover.com/~mjd/perl/Template/>.
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Mark Jason Dominus <mjd@cpan.org>.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
TEXT_TEMPLATE_PREPROCESS

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny; # git description: v0.27-8-g8dc27c7
  use 5.006;
  # ABSTRACT: Minimal try/catch with proper preservation of $@
  
  our $VERSION = '0.28';
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN {
    my $su = $INC{'Sub/Util.pm'} && defined &Sub::Util::set_subname;
    my $sn = $INC{'Sub/Name.pm'} && eval { Sub::Name->VERSION(0.08) };
    unless ($su || $sn) {
      $su = eval { require Sub::Util; } && defined &Sub::Util::set_subname;
      unless ($su) {
        $sn = eval { require Sub::Name; Sub::Name->VERSION(0.08) };
      }
    }
  
    *_subname = $su ? \&Sub::Util::set_subname
              : $sn ? \&Sub::Name::subname
              : sub { $_[1] };
    *_HAS_SUBNAME = ($su || $sn) ? sub(){1} : sub(){0};
  }
  
  my %_finally_guards;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    _subname("${caller}::try {...} " => $try)
      if _HAS_SUBNAME;
  
    # set up scope guards to invoke the finally blocks at the end.
    # this should really be a function scope lexical variable instead of
    # file scope + local but that causes issues with perls < 5.20 due to
    # perl rt#119311
    local $_finally_guards{guards} = [
      map { Try::Tiny::ScopeGuard->_new($_) }
      @finally
    ];
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $failed to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # pass $error to the finally blocks
      push @$_, $error for @{$_finally_guards{guards}};
  
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::catch {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    my $caller = caller;
    _subname("${caller}::finally {...} " => $block)
      if _HAS_SUBNAME;
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ("$]" < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - Minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.28
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || "bar";
    my $x = (try { die "foo" }) // "bar";
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  =for stopwords topicalizer
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  argument list. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =for stopwords unhygienically
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygienically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considered experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 SUPPORT
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny>
  (or L<bug-Try-Tiny@rt.cpan.org|mailto:bug-Try-Tiny@rt.cpan.org>).
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  יובל קוג'מן (Yuval Kogman) <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Karen Etheridge Peter Rabbitson Ricardo Signes Mark Fowler Graham Knop Lukas Mai Dagfinn Ilmari Mannsåker Paul Howarth Rudolf Leermakers anaxagoras awalker chromatic Alex cm-perl Andrew Yates David Lowe Glenn Hans Dieter Pearcey Jonathan Yu Marc Mims Stosberg Pali
  
  =over 4
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Mark Fowler <mark@twoshortplanks.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Lukas Mai <l.mai@web.de>
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Rudolf Leermakers <rudolf@hatsuseno.org>
  
  =item *
  
  anaxagoras <walkeraj@gmail.com>
  
  =item *
  
  awalker <awalker@sourcefire.com>
  
  =item *
  
  chromatic <chromatic@wgz.org>
  
  =item *
  
  Alex <alex@koban.(none)>
  
  =item *
  
  cm-perl <cm-perl@users.noreply.github.com>
  
  =item *
  
  Andrew Yates <ayates@haddock.local>
  
  =item *
  
  David Lowe <davidl@lokku.com>
  
  =item *
  
  Glenn Fowler <cebjyre@cpan.org>
  
  =item *
  
  Hans Dieter Pearcey <hdp@weftsoar.net>
  
  =item *
  
  Jonathan Yu <JAWNSY@cpan.org>
  
  =item *
  
  Marc Mims <marc@questright.com>
  
  =item *
  
  Mark Stosberg <mark@stosberg.com>
  
  =item *
  
  Pali <pali@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is Copyright (c) 2009 by יובל קוג'מן (Yuval Kogman).
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"Type/Coercion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION';
  package Type::Coercion;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::VERSION   = '1.002001';
  }
  
  use Eval::TypeTiny qw<>;
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny qw<>;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	fallback   => 1,
  ;
  
  BEGIN {
  	require Type::Tiny;
  	overload->import(
  		q(~~)    => sub { $_[0]->has_coercion_for_value($_[1]) },
  		fallback => 1, # 5.10 loses the fallback otherwise
  	) if Type::Tiny::SUPPORT_SMARTMATCH();
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	
  	if ("Sub::Quote"->can("quote_sub") && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_coercion('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->coerce(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	$params{name} = '__ANON__' unless exists($params{name});
  	my $C = delete($params{type_coercion_map}) || [];
  	my $F = delete($params{frozen});
  	
  	my $self = bless \%params, $class;
  	$self->add_type_coercions(@$C) if @$C;
  	$self->_preserve_type_constraint;
  	Scalar::Util::weaken($self->{type_constraint}); # break ref cycle
  	$self->{frozen} = $F if $F;
  	
  	unless ($self->is_anon)
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$self->name =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $self->name =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid coercion name', $self->name;
  	}
  	
  	return $self;
  }
  
  sub name                   { $_[0]{name} }
  sub display_name           { $_[0]{display_name}      ||= $_[0]->_build_display_name }
  sub library                { $_[0]{library} }
  sub type_constraint        { $_[0]{type_constraint}   ||= $_[0]->_maybe_restore_type_constraint }
  sub type_coercion_map      { $_[0]{type_coercion_map} ||= [] }
  sub moose_coercion         { $_[0]{moose_coercion}    ||= $_[0]->_build_moose_coercion }
  sub compiled_coercion      { $_[0]{compiled_coercion} ||= $_[0]->_build_compiled_coercion }
  sub frozen                 { $_[0]{frozen}            ||= 0 }
  sub coercion_generator     { $_[0]{coercion_generator} }
  sub parameters             { $_[0]{parameters} }
  sub parameterized_from     { $_[0]{parameterized_from} }
  
  sub has_library            { exists $_[0]{library} }
  sub has_type_constraint    { defined $_[0]->type_constraint } # sic
  sub has_coercion_generator { exists $_[0]{coercion_generator} }
  sub has_parameters         { exists $_[0]{parameters} }
  
  sub _preserve_type_constraint
  {
  	my $self = shift;
  	$self->{_compiled_type_constraint_check} = $self->{type_constraint}->compiled_check
  		if $self->{type_constraint};
  }
  
  sub _maybe_restore_type_constraint
  {
  	my $self = shift;
  	if ( my $check = $self->{_compiled_type_constraint_check} )
  	{
  		return Type::Tiny->new(constraint => $check);
  	}
  	return;
  }
  
  sub add
  {
  	my $class = shift;
  	my ($x, $y, $swap) = @_;
  	
  	Types::TypeTiny::TypeTiny->check($x) and return $x->plus_fallback_coercions($y);
  	Types::TypeTiny::TypeTiny->check($y) and return $y->plus_coercions($x);
  	
  	_croak "Attempt to add $class to something that is not a $class"
  		unless blessed($x) && blessed($y) && $x->isa($class) && $y->isa($class);
  	
  	($y, $x) = ($x, $y) if $swap;
  	
  	my %opts;
  	if ($x->has_type_constraint and $y->has_type_constraint and $x->type_constraint == $y->type_constraint)
  	{
  		$opts{type_constraint} = $x->type_constraint;
  	}
  	elsif ($x->has_type_constraint and $y->has_type_constraint)
  	{
  #		require Type::Tiny::Union;
  #		$opts{type_constraint} = "Type::Tiny::Union"->new(
  #			type_constraints => [ $x->type_constraint, $y->type_constraint ],
  #		);
  	}
  	$opts{display_name} ||= "$x+$y";
  	delete $opts{display_name} if $opts{display_name} eq '__ANON__+__ANON__';
  	
  	my $new = $class->new(%opts);
  	$new->add_type_coercions( @{$x->type_coercion_map} );
  	$new->add_type_coercions( @{$y->type_coercion_map} );
  	return $new;
  }
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	
  	if ($self->has_library and not $self->is_anon)
  	{
  		return sprintf("%s::%s", $self->library, $self->name);
  	}
  	
  	return $self->name;
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub _clear_compiled_coercion
  {
  	delete $_[0]{_overload_coderef};
  	delete $_[0]{compiled_coercion};
  }
  
  sub freeze                    { $_[0]{frozen} = 1; $_[0] }
  sub i_really_want_to_unfreeze { $_[0]{frozen} = 0; $_[0] }
  
  sub coerce
  {
  	my $self = shift;
  	return $self->compiled_coercion->(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	my $r = $self->coerce(@_);
  	$self->type_constraint->assert_valid($r)
  		if $self->has_type_constraint;
  	return $r;
  }
  
  sub has_coercion_for_type
  {
  	my $self = shift;
  	my $type = Types::TypeTiny::to_TypeTiny($_[0]);
  	
  	return "0 but true"
  		if $self->has_type_constraint && $type->is_a_type_of($self->type_constraint);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $type->is_a_type_of($c->[$i]);
  	}
  	return;
  }
  
  sub has_coercion_for_value
  {
  	my $self = shift;
  	local $_ = $_[0];
  	
  	return "0 but true"
  		if $self->has_type_constraint && $self->type_constraint->check(@_);
  	
  	my $c = $self->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		return !!1 if $c->[$i]->check(@_);
  	}
  	return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	my @args = @_;
  	
  	_croak "Attempt to add coercion code to a Type::Coercion which has been frozen" if $self->frozen;
  	
  	while (@args)
  	{
  		my $type     = Types::TypeTiny::to_TypeTiny(shift @args);
  		my $coercion = shift @args;
  		
  		_croak "Types must be blessed Type::Tiny objects"
  			unless Types::TypeTiny::TypeTiny->check($type);
  		_croak "Coercions must be code references or strings"
  			unless Types::TypeTiny::StringLike->check($coercion) || Types::TypeTiny::CodeLike->check($coercion);
  		
  		push @{$self->type_coercion_map}, $type, $coercion;
  	}
  	
  	$self->_clear_compiled_coercion;
  	return $self;
  }
  
  sub _build_compiled_coercion
  {
  	my $self = shift;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return sub { $_[0] } unless @mishmash;
  
  	if ($self->can_be_inlined)
  	{
  		return Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $self->inline_coercion('$_[0]')),
  			description => sprintf("compiled coercion '%s'", $self),
  		);
  	}
  
  	# These arrays will be closed over.
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub,
  			$types[$i]->can_be_inlined ? sprintf('if (%s)', $types[$i]->inline_check('$_[0]')) :
  			sprintf('if ($checks[%d]->(@_))', $i);
  		push @sub,
  			!defined($codes[$i])
  				? sprintf('  { return $_[0] }') :
  			Types::TypeTiny::StringLike->check($codes[$i])
  				? sprintf('  { local $_ = $_[0]; return scalar(%s); }', $codes[$i]) :
  			sprintf('  { local $_ = $_[0]; return scalar($codes[%d]->(@_)) }', $i);
  	}
  	
  	push @sub, 'return $_[0];';
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', join qq[\n], @sub),
  		description => sprintf("compiled coercion '%s'", $self),
  		environment => {
  			'@checks' => [ map $_->compiled_check, @types ],
  			'@codes'  => \@codes,
  		},
  	);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	
  	return unless $self->frozen;
  	
  	return
  		if $self->has_type_constraint
  		&& !$self->type_constraint->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type, $converter) = splice(@mishmash, 0, 2);
  		return unless $type->can_be_inlined;
  		return unless Types::TypeTiny::StringLike->check($converter);
  	}
  	return !!1;
  }
  
  sub _source_type_union
  {
  	my $self = shift;
  	
  	my @r;
  	push @r, $self->type_constraint if $self->has_type_constraint;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	while (@mishmash)
  	{
  		my ($type) = splice(@mishmash, 0, 2);
  		push @r, $type;
  	}
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@r, tmp => 1);
  }
  
  sub inline_coercion
  {
  	my $self = shift;
  	my $varname = $_[0];
  	
  	_croak "This coercion cannot be inlined" unless $self->can_be_inlined;
  	
  	my @mishmash = @{$self->type_coercion_map};
  	return "($varname)" unless @mishmash;
  	
  	my (@types, @codes);
  	while (@mishmash)
  	{
  		push @types, shift @mishmash;
  		push @codes, shift @mishmash;
  	}
  	if ($self->has_type_constraint)
  	{
  		unshift @types, $self->type_constraint;
  		unshift @codes, undef;
  	}
  	
  	my @sub;
  	
  	for my $i (0..$#types)
  	{
  		push @sub, sprintf('(%s) ?', $types[$i]->inline_check($varname));
  		push @sub,
  			(defined($codes[$i]) && ($varname eq '$_'))
  				? sprintf('scalar(do { %s }) :', $codes[$i]) :
  			defined($codes[$i])
  				? sprintf('scalar(do { local $_ = %s; %s }) :', $varname, $codes[$i]) :
  			sprintf('%s :', $varname);
  	}
  	
  	push @sub, "$varname";
  	
  	"@sub";
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_coercion_map} = [ $self->freeze->_codelike_type_coercion_map('moose_type') ];
  	$options{type_constraint}   = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion;
  	my $r = "Moose::Meta::TypeCoercion"->new(%options);
  	
  	return $r;
  }
  
  sub _codelike_type_coercion_map
  {
  	my $self = shift;
  	my $modifier = $_[0];
  	
  	my @orig = @{ $self->type_coercion_map };
  	my @new;
  	
  	while (@orig)
  	{
  		my ($type, $converter) = splice(@orig, 0, 2);
  		
  		push @new, $modifier ? $type->$modifier : $type;
  		
  		if (Types::TypeTiny::CodeLike->check($converter))
  		{
  			push @new, $converter;
  		}
  		else
  		{
  			push @new, Eval::TypeTiny::eval_closure(
  				source      => sprintf('sub { local $_ = $_[0]; %s }', $converter),
  				description => sprintf("temporary compiled converter from '%s'", $type),
  			);
  		}
  	}
  	
  	return @new;
  }
  
  sub is_parameterizable
  {
  	shift->has_coercion_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  sub parameterize
  {
  	my $self = shift;
  	return $self unless @_;
  	$self->is_parameterizable
  		or _croak "Constraint '%s' does not accept parameters", "$self";
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  	
  	return ref($self)->new(
  		type_constraint    => $self->type_constraint,
  		type_coercion_map  => [ $self->coercion_generator->($self, $self->type_constraint, @_) ],
  		parameters         => \@_,
  		frozen             => 1,
  		parameterized_from => $self,
  	);
  }
  
  sub _reparameterize
  {
  	my $self = shift;
  	my ($target_type) = @_;
  	
  	$self->is_parameterized or return $self;
  	my $parent = $self->parameterized_from;
  	
  	return ref($self)->new(
  		type_constraint    => $target_type,
  		type_coercion_map  => [ $parent->coercion_generator->($parent, $target_type, @{$self->parameters}) ],
  		parameters         => \@_,
  		frozen             => 1,
  		parameterized_from => $parent,
  	);
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and blessed($self) and $_[0] eq 'Moose::Meta::TypeCoercion')
  	{
  		return !!1;
  	}
  	
  	if ($INC{"Moose.pm"}
  	and blessed($self)
  	and $_[0] =~ /^(Class::MOP|MooseX?)::/)
  	{
  		my $r = $self->moose_coercion->isa(@_);
  		return $r if $r;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub can
  {
  	my $self = shift;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if ($INC{"Moose.pm"}
  	and blessed($self)
  	and my $method = $self->moose_coercion->can(@_))
  	{
  		return sub { $method->(shift->moose_coercion, @_) };
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if ($INC{"Moose.pm"} and blessed($self) and my $method = $self->moose_coercion->can($m))
  	{
  		return $method->($self->moose_coercion, @_);
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  # Private Moose method, but Moo uses this...
  sub _compiled_type_coercion
  {
  	my $self = shift;
  	if (@_)
  	{
  		my $thing = $_[0];
  		if (blessed($thing) and $thing->isa("Type::Coercion"))
  		{
  			$self->add_type_coercions(@{$thing->type_coercion_map});
  		}
  		elsif (Types::TypeTiny::CodeLike->check($thing))
  		{
  			require Types::Standard;
  			$self->add_type_coercions(Types::Standard::Any(), $thing);
  		}
  	}
  	$self->compiled_coercion;
  }
  
  *compile_type_coercion = \&compiled_coercion;
  sub meta { _croak("Not really a Moose::Meta::TypeCoercion. Sorry!") }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion - a set of coercions to a particular target type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  =head2 Constructors
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =item C<< add($c1, $c2) >>
  
  Create a Type::Coercion from two existing Type::Coercion objects.
  
  =back
  
  =head2 Attributes
  
  Attributes are named values that may be passed to the constructor. For
  each attribute, there is a corresponding reader method. For example:
  
     my $c = Type::Coercion->new( type_constraint => Int );
     my $t = $c->type_constraint;  # Int
  
  =head3 Important attributes
  
  These are the attributes you are likely to be most interested in
  providing when creating your own type coercions, and most interested
  in reading when dealing with coercion objects.
  
  =over
  
  =item C<type_constraint>
  
  Weak reference to the target type constraint (i.e. the type constraint which
  the output of coercion coderefs is expected to conform to).
  
  =item C<type_coercion_map>
  
  Arrayref of source-type/code pairs.
  
  =item C<frozen>
  
  Boolean; default false. A frozen coercion cannot have C<add_type_coercions>
  called upon it.
  
  =item C<name>
  
  A name for the coercion. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous coercion.
  
  =item C<display_name>
  
  A name to display for the coercion when stringified. These don't have
  to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<library>
  
  The package name of the type library this coercion is associated with.
  Optional. Informational only: setting this attribute does not install
  the coercion into the package.
  
  =back
  
  =head3 Attributes related to parameterizable and parameterized coercions
  
  The following attributes are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< coercion_generator >>
  
  =item C<< parameters >>
  
  =item C<< parameterized_from >>
  
  =back
  
  =head3 Lazy generated attributes
  
  The following attributes should not be usually passed to the constructor;
  unless you're doing something especially unusual, you should rely on the
  default lazily-built return values.
  
  =over
  
  =item C<< compiled_coercion >>
  
  Coderef to coerce a value (C<< $_[0] >>).
  
  The general point of this attribute is that you should not set it, but
  rely on the lazily-built default. Type::Coerce will usually generate a
  pretty fast coderef, inlining all type constraint checks, etc.
  
  =item C<moose_coercion>
  
  A L<Moose::Meta::TypeCoercion> object equivalent to this one. Don't set this
  manually; rely on the default built one.
  
  =back
  
  =head2 Methods
  
  =head3 Predicate methods
  
  These methods return booleans indicating information about the coercion.
  They are each tightly associated with a particular attribute.
  (See L</"Attributes">.)
  
  =over
  
  =item C<has_type_constraint>, C<has_library>
  
  Simple Moose-style predicate methods indicating the presence or
  absence of an attribute.
  
  =item C<is_anon>
  
  Returns true iff the coercion does not have a C<name>.
  
  =back
  
  The following predicates are used for parameterized coercions, but are not
  fully documented because they may change in the near future:
  
  =over
  
  =item C<< has_coercion_generator >>
  
  =item C<< has_parameters >>
  
  =item C<< is_parameterizable >>
  
  =item C<< is_parameterized >>
  
  =back
  
  =head3 Coercion
  
  The following methods are used for coercing values to a type constraint:
  
  =over
  
  =item C<< coerce($value) >>
  
  Coerce the value to the target type.
  
  Returns the coerced value, or the original value if no coercion was
  possible.
  
  =item C<< assert_coerce($value) >>
  
  Coerce the value to the target type, and throw an exception if the result
  does not validate against the target type constraint.
  
  Returns the coerced value.
  
  =back
  
  =head3 Coercion code definition methods
  
  These methods all return C<< $self >> so are suitable for chaining.
  
  =over
  
  =item C<< add_type_coercions($type1, $code1, ...) >>
  
  Takes one or more pairs of L<Type::Tiny> constraints and coercion code,
  creating an ordered list of source types and coercion codes.
  
  Coercion codes can be expressed as either a string of Perl code (this
  includes objects which overload stringification), or a coderef (or object
  that overloads coderefification). In either case, the value to be coerced
  is C<< $_ >>.
  
  C<< add_type_coercions($coercion_object) >> also works, and can be used
  to copy coercions from another type constraint:
  
     $type->coercion->add_type_coercions($othertype->coercion)->freeze;
  
  =item C<< freeze >>
  
  Sets the C<frozen> attribute to true. Called automatically by L<Type::Tiny>
  sometimes.
  
  =item C<< i_really_want_to_unfreeze >>
  
  If you really want to unfreeze a coercion, call this method.
  
  Don't call this method. It will potentially lead to subtle bugs.
  
  This method is considered unstable; future versions of Type::Tiny may
  alter its behaviour (e.g. to throw an exception if it has been detected
  that unfreezing this particular coercion will cause bugs).
  
  =back
  
  =head3 Parameterization
  
  The following method is used for parameterized coercions, but is not
  fully documented because it may change in the near future:
  
  =over
  
  =item C<< parameterize(@params) >>
  
  =back
  
  =head3 Type coercion introspection methods
  
  These methods allow you to determine a coercion's relationship to type
  constraints:
  
  =over
  
  =item C<< has_coercion_for_type($source_type) >>
  
  Returns true iff this coercion has a coercion from the source type.
  
  Returns the special string C<< "0 but true" >> if no coercion should
  actually be necessary for this type. (For example, if a coercion coerces
  to a theoretical "Number" type, there is probably no coercion necessary
  for values that already conform to the "Integer" type.)
  
  =item C<< has_coercion_for_value($value) >>
  
  Returns true iff the value could be coerced by this coercion.
  
  Returns the special string C<< "0 but true" >> if no coercion would be
  actually be necessary for this value (due to it already meeting the target
  type constraint).
  
  =back
  
  The C<type_constraint> attribute provides a type constraint object for the
  target type constraint of the coercion. See L</"Attributes">.
  
  =head3 Inlining methods
  
  =for stopwords uated
  
  The following methods are used to generate strings of Perl code which
  may be pasted into stringy C<eval>uated subs to perform type coercions:
  
  =over
  
  =item C<< can_be_inlined >>
  
  Returns true iff the coercion can be inlined.
  
  =item C<< inline_coercion($varname) >>
  
  Much like C<inline_coerce> from L<Type::Tiny>.
  
  =back
  
  =head3 Other methods
  
  =over
  
  =item C<< qualified_name >>
  
  For non-anonymous coercions that have a library, returns a qualified
  C<< "MyLib::MyCoercion" >> sort of name. Otherwise, returns the same
  as C<name>.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeCoercion.
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_coercion >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<coerce>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<has_coercion_for_value>.
  
  =back
  
  Previous versions of Type::Coercion would overload the C<< + >> operator
  to call C<add>. Support for this was dropped after 0.040.
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item B<< Attempt to add coercion code to a Type::Coercion which has been frozen >>
  
  Type::Tiny type constraints are designed as immutable objects. Once you've
  created a constraint, rather than modifying it you generally create child
  constraints to do what you need.
  
  Type::Coercion objects, on the other hand, are mutable. Coercion routines
  can be added at any time during the object's lifetime.
  
  Sometimes Type::Tiny needs to freeze a Type::Coercion object to prevent this.
  In L<Moose> and L<Mouse> code this is likely to happen as soon as you use a
  type constraint in an attribute.
  
  Workarounds:
  
  =over
  
  =item *
  
  Define as many of your coercions as possible within type libraries, not
  within the code that uses the type libraries. The type library will be
  evaluated relatively early, likely before there is any reason to freeze
  a coercion.
  
  =item *
  
  If you do need to add coercions to a type within application code outside
  the type library, instead create a subtype and add coercions to that. The
  C<plus_coercions> method provided by L<Type::Tiny> should make this simple.
  
  =back
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Types::Standard>.
  
  L<Type::Coercion::Union>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_COERCION

$fatpacked{"Type/Coercion/FromMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_FROMMOOSE';
  package Type::Coercion::FromMoose;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::FromMoose::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::FromMoose::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	my @from;
  	if ($self->type_constraint)
  	{
  		my $moose = $self->type_constraint->{moose_type};
  		@from = @{ $moose->coercion->type_coercion_map } if $moose && $moose->has_coercion;
  	}
  	else
  	{
  		_croak "The type constraint attached to this coercion has been garbage collected... PANIC";
  	}
  	
  	my @return;
  	while (@from)
  	{
  		my ($type, $code) = splice(@from, 0, 2);
  		$type = Moose::Util::TypeConstraints::find_type_constraint($type)
  			unless ref $type;
  		push @return, Types::TypeTiny::to_TypeTiny($type), $code;
  	}
  	
  	return \@return;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::FromMoose not currently supported" if @_;
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	if ($self->type_constraint)
  	{
  		my $moose = $self->type_constraint->{moose_type};
  		return $moose->coercion if $moose && $moose->has_coercion;
  	}
  	
  	$self->SUPER::_build_moose_coercion(@_);
  }
  
  sub can_be_inlined
  {
  	0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::FromMoose - a set of coercions borrowed from Moose
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  Moose.
  
  This is mostly for internal purposes.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_FROMMOOSE

$fatpacked{"Type/Coercion/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_COERCION_UNION';
  package Type::Coercion::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Coercion::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Coercion::Union::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Coercion;
  our @ISA = 'Type::Coercion';
  
  sub _preserve_type_constraint
  {
  	my $self = shift;
  	$self->{_union_of} = $self->{type_constraint}->type_constraints
  		if $self->{type_constraint};
  }
  
  sub _maybe_restore_type_constraint
  {
  	my $self = shift;
  	if ( my $union = $self->{_union_of} )
  	{
  		return Type::Tiny::Union->new(type_constraints => $union);
  	}
  	return;
  }
  
  sub type_coercion_map
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	$type->isa('Type::Tiny::Union')
  		or _croak "Type::Coercion::Union must be used in conjunction with Type::Tiny::Union";
  	
  	my @c;
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		push @c, @{$tc->coercion->type_coercion_map};
  	}
  	return \@c;
  }
  
  sub add_type_coercions
  {
  	my $self = shift;
  	_croak "Adding coercions to Type::Coercion::Union not currently supported" if @_;
  }
  
  sub _build_moose_coercion
  {
  	my $self = shift;
  	
  	my %options = ();
  	$options{type_constraint} = $self->type_constraint if $self->has_type_constraint;
  	
  	require Moose::Meta::TypeCoercion::Union;
  	my $r = "Moose::Meta::TypeCoercion::Union"->new(%options);
  	
  	return $r;
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	
  	Types::TypeTiny::TypeTiny->assert_valid(my $type = $self->type_constraint);
  	
  	for my $tc (@$type)
  	{
  		next unless $tc->has_coercion;
  		return !!0 unless $tc->coercion->can_be_inlined;
  	}
  	
  	!!1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Coercion::Union - a set of coercions to a union type constraint
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This package inherits from L<Type::Coercion>; see that for most documentation.
  The major differences are that C<add_type_coercions> always throws an
  exception, and the C<type_coercion_map> is automatically populated from
  the child constraints of the union type constraint.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Coercion>.
  
  L<Moose::Meta::TypeCoercion::Union>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_COERCION_UNION

$fatpacked{"Type/Library.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_LIBRARY';
  package Type::Library;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Library::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Library::VERSION   = '1.002001';
  }
  
  use Eval::TypeTiny qw< eval_closure >;
  use Scalar::Util qw< blessed refaddr >;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny >;
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  BEGIN { *NICE_PROTOTYPES = ($] >= 5.014) ? sub () { !!1 } : sub () { !!0 } };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  {
  	my $subname;
  	my %already; # prevent renaming established functions
  	sub _subname ($$)
  	{
  		$subname =
  			eval { require Sub::Util } ? \&Sub::Util::set_subname :
  			eval { require Sub::Name } ? \&Sub::Name::subname :
  			0
  			if not defined $subname;
  		!$already{refaddr($_[1])}++ and return($subname->(@_))
  			if $subname;
  		return $_[1];
  	}
  }
  
  sub _exporter_validate_opts
  {
  	my $class = shift;
  	
  	no strict "refs";
  	my $into  = $_[0]{into};
  	push @{"$into\::ISA"}, $class if $_[0]{base};
  	
  	return $class->SUPER::_exporter_validate_opts(@_);
  }
  
  sub _exporter_expand_tag
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	$name eq 'types'     and return map [ "$_"        => $value ], $class->type_names;
  	$name eq 'is'        and return map [ "is_$_"     => $value ], $class->type_names;
  	$name eq 'assert'    and return map [ "assert_$_" => $value ], $class->type_names;
  	$name eq 'to'        and return map [ "to_$_"     => $value ], $class->type_names;
  	$name eq 'coercions' and return map [ "$_"        => $value ], $class->coercion_names;
  	
  	if ($name eq 'all')
  	{
  		no strict "refs";
  		return (
  			map(
  				[ "+$_" => $value ],
  				$class->type_names,
  			),
  			map(
  				[ $_ => $value ],
  				$class->coercion_names,
  				@{"$class\::EXPORT"},
  				@{"$class\::EXPORT_OK"},
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_expand_tag(@_);
  }
  
  sub _mksub
  {
  	my $class = shift;
  	my ($type, $post_method) = @_;
  	$post_method ||= q();
  	
  	my $source = $type->is_parameterizable
  		? sprintf(
  			q{
  				sub (%s) {
  					return $_[0]->complete($type) if ref($_[0]) eq 'Type::Tiny::_HalfOp';
  					my $params; $params = shift if ref($_[0]) eq q(ARRAY);
  					my $t = $params ? $type->parameterize(@$params) : $type;
  					@_ && wantarray ? return($t%s, @_) : return $t%s;
  				}
  			},
  			NICE_PROTOTYPES ? q(;$) : q(;@),
  			$post_method,
  			$post_method,
  		)
  		: sprintf(
  			q{ sub () { $type%s if $] } },
  			$post_method,
  		);
  		
  	return _subname(
  		$type->qualified_name,
  		eval_closure(
  			source      => $source,
  			description => sprintf("exportable function '%s'", $type),
  			environment => {'$type' => \$type},
  		),
  	);
  }
  
  sub _exporter_permitted_regexp
  {
  	my $class = shift;
  	
  	my $inherited = $class->SUPER::_exporter_permitted_regexp(@_);
  	my $types = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->type_names;
  	my $coercions = join "|", map quotemeta, sort {
  		length($b) <=> length($a) or $a cmp $b
  	} $class->coercion_names;
  	
  	qr{^(?:
  		$inherited
  		| (?: (?:is_|to_|assert_)? (?:$types) )
  		| (?:$coercions)
  	)$}xms;
  }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	if ($name =~ /^\+(.+)/ and $class->has_type($1))
  	{
  		my $type   = $1;
  		my $value2 = +{%{$value||{}}};
  		
  		return map $class->_exporter_expand_sub($_, $value2, $globals),
  			$type, "is_$type", "assert_$type", "to_$type";
  	}
  	
  	if (my $type = $class->get_type($name))
  	{
  		my $post_method = q();
  		$post_method = '->mouse_type' if $globals->{mouse};
  		$post_method = '->moose_type' if $globals->{moose};
  		return ($name => $class->_mksub($type, $post_method)) if $post_method;
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub _exporter_install_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $sym) = @_;
  	
  	my $package = $globals->{into};
  	
  	if (!ref $package and my $type = $class->get_type($name))
  	{
  		my ($prefix) = grep defined, $value->{-prefix}, $globals->{prefix}, q();
  		my ($suffix) = grep defined, $value->{-suffix}, $globals->{suffix}, q();
  		my $as = $prefix . ($value->{-as} || $name) . $suffix;
  		
  		$INC{'Type/Registry.pm'}
  			? 'Type::Registry'->for_class($package)->add_type($type, $as)
  			: ($Type::Registry::DELAYED{$package}{$as} = $type);
  	}
  	
  	$class->SUPER::_exporter_install_sub(@_);
  }
  
  sub _exporter_fail
  {
  	my $class = shift;
  	my ($name, $value, $globals) = @_;
  	
  	my $into = $globals->{into}
  		or _croak("Parameter 'into' not supplied");
  	
  	if ($globals->{declare})
  	{
  		my $declared = sub (;$)
  		{
  			my $params; $params = shift if ref($_[0]) eq "ARRAY";
  			my $type = $into->get_type($name);
  			unless ($type)
  			{
  				_croak "Cannot parameterize a non-existant type" if $params;
  				$type = $name;
  			}
  			
  			my $t = $params ? $type->parameterize(@$params) : $type;
  			@_ && wantarray ? return($t, @_) : return $t;
  		};
  		
  		return(
  			$name,
  			_subname(
  				"$class\::$name",
  				NICE_PROTOTYPES ? sub (;$) { goto $declared } : sub (;@) { goto $declared },
  			),
  		);
  	}
  	
  	return $class->SUPER::_exporter_fail(@_);
  }
  
  sub meta
  {
  	no strict "refs";
  	no warnings "once";
  	return $_[0] if blessed $_[0];
  	${"$_[0]\::META"} ||= bless {}, $_[0];
  }
  
  sub add_type
  {
  	my $meta  = shift->meta;
  	my $class = blessed($meta);
  	
  	my $type =
  		ref($_[0]) =~ /^Type::Tiny\b/  ? $_[0] :
  		blessed($_[0])                 ? to_TypeTiny($_[0]) :
  		ref($_[0]) eq q(HASH)          ? "Type::Tiny"->new(library => $class, %{$_[0]}) :
  		"Type::Tiny"->new(library => $class, @_);
  	my $name = $type->{name};
  	
  	$meta->{types} ||= {};
  	_croak 'Type %s already exists in this library', $name if $meta->has_type($name);
  	_croak 'Type %s conflicts with coercion of same name', $name if $meta->has_coercion($name);
  	_croak 'Cannot add anonymous type to a library' if $type->is_anon;
  	$meta->{types}{$name} = $type;
  	
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $to_type = $type->has_coercion && $type->coercion->frozen
  		? $type->coercion->compiled_coercion
  		: sub ($) { $type->coerce($_[0]) };
  	
  	*{"$class\::$name"}        = $class->_mksub($type);
  	*{"$class\::is_$name"}     = _subname "$class\::is_$name", $type->compiled_check;
  	*{"$class\::to_$name"}     = _subname "$class\::to_$name", $to_type;
  	*{"$class\::assert_$name"} = _subname "$class\::assert_$name", $type->_overload_coderef;
  	
  	return $type;
  }
  
  sub get_type
  {
  	my $meta = shift->meta;
  	$meta->{types}{$_[0]};
  }
  
  sub has_type
  {
  	my $meta = shift->meta;
  	exists $meta->{types}{$_[0]};
  }
  
  sub type_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{types} };
  }
  
  sub add_coercion
  {
  	require Type::Coercion;
  	my $meta = shift->meta;
  	my $c    = blessed($_[0]) ? $_[0] : "Type::Coercion"->new(@_);
  	my $name = $c->name;
  
  	$meta->{coercions} ||= {};
  	_croak 'Coercion %s already exists in this library', $name if $meta->has_coercion($name);
  	_croak 'Coercion %s conflicts with type of same name', $name if $meta->has_type($name);
  	_croak 'Cannot add anonymous type to a library' if $c->is_anon;
  	$meta->{coercions}{$name} = $c;
  
  	no strict "refs";
  	no warnings "redefine", "prototype";
  	
  	my $class = blessed($meta);
  	*{"$class\::$name"} = $class->_mksub($c);
  	
  	return $c;
  }
  
  sub get_coercion
  {
  	my $meta = shift->meta;
  	$meta->{coercions}{$_[0]};
  }
  
  sub has_coercion
  {
  	my $meta = shift->meta;
  	exists $meta->{coercions}{$_[0]};
  }
  
  sub coercion_names
  {
  	my $meta = shift->meta;
  	keys %{ $meta->{coercions} };
  }
  
  sub make_immutable
  {
  	my $meta  = shift->meta;
  	my $class = ref($meta);
  	
  	for my $type (values %{$meta->{types}})
  	{
  		$type->coercion->freeze;
  		
  		no strict "refs";
  		no warnings "redefine", "prototype";
  		
  		my $to_type = $type->has_coercion && $type->coercion->frozen
  			? $type->coercion->compiled_coercion
  			: sub ($) { $type->coerce($_[0]) };
  		my $name = $type->name;
  		
  		*{"$class\::to_$name"} = _subname "$class\::to_$name", $to_type;
  	}
  	
  	1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX::Types-like
  
  =head1 NAME
  
  Type::Library - tiny, yet Moo(se)-compatible type libraries
  
  =head1 SYNOPSIS
  
  =for test_synopsis
  BEGIN { die "SKIP: crams multiple modules into single example" };
  
     package Types::Mine {
        use Scalar::Util qw(looks_like_number);
        use Type::Library -base;
        use Type::Tiny;
        
        my $NUM = "Type::Tiny"->new(
           name       => "Number",
           constraint => sub { looks_like_number($_) },
           message    => sub { "$_ ain't a number" },
        );
        
        __PACKAGE__->meta->add_type($NUM);
        
        __PACKAGE__->meta->make_immutable;
     }
        
     package Ermintrude {
        use Moo;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Bullwinkle {
        use Moose;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
     
     package Maisy {
        use Mouse;
        use Types::Mine qw(Number);
        has favourite_number => (is => "ro", isa => Number);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Library> is a tiny class for creating MooseX::Types-like type
  libraries which are compatible with Moo, Moose and Mouse.
  
  If you're reading this because you want to create a type library, then
  you're probably better off reading L<Type::Tiny::Manual::Libraries>.
  
  =head2 Methods
  
  A type library is a singleton class. Use the C<meta> method to get a blessed
  object which other methods can get called on. For example:
  
     Types::Mine->meta->add_type($foo);
  
  =begin trustme
  
  =item meta
  
  =end trustme
  
  =over
  
  =item C<< add_type($type) >> or C<< add_type(%opts) >>
  
  Add a type to the library. If C<< %opts >> is given, then this method calls
  C<< Type::Tiny->new(%opts) >> first, and adds the resultant type.
  
  Adding a type named "Foo" to the library will automatically define four
  functions in the library's namespace:
  
  =over
  
  =item C<< Foo >>
  
  Returns the Type::Tiny object.
  
  =item C<< is_Foo($value) >>
  
  Returns true iff $value passes the type constraint.
  
  =item C<< assert_Foo($value) >>
  
  Returns $value iff $value passes the type constraint. Dies otherwise.
  
  =item C<< to_Foo($value) >>
  
  Coerces the value to the type.
  
  =back
  
  =item C<< get_type($name) >>
  
  Gets the C<Type::Tiny> object corresponding to the name.
  
  =item C<< has_type($name) >>
  
  Boolean; returns true if the type exists in the library.
  
  =item C<< type_names >>
  
  List all types defined by the library.
  
  =item C<< add_coercion($c) >> or C<< add_coercion(%opts) >>
  
  Add a standalone coercion to the library. If C<< %opts >> is given, then
  this method calls C<< Type::Coercion->new(%opts) >> first, and adds the
  resultant coercion.
  
  Adding a coercion named "FooFromBar" to the library will automatically
  define a function in the library's namespace:
  
  =over
  
  =item C<< FooFromBar >>
  
  Returns the Type::Coercion object.
  
  =back
  
  =item C<< get_coercion($name) >>
  
  Gets the C<Type::Coercion> object corresponding to the name.
  
  =item C<< has_coercion($name) >>
  
  Boolean; returns true if the coercion exists in the library.
  
  =item C<< coercion_names >>
  
  List all standalone coercions defined by the library.
  
  =item C<< import(@args) >>
  
  Type::Library-based libraries are exporters.
  
  =item C<< make_immutable >>
  
  A shortcut for calling C<< $type->coercion->freeze >> on every
  type constraint in the library.
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< NICE_PROTOTYPES >>
  
  If this is true, then Type::Library will give parameterizable type constraints
  slightly the nicer prototype of C<< (;$) >> instead of the default C<< (;@) >>.
  This allows constructs like:
  
     ArrayRef[Int] | HashRef[Int]
  
  ... to "just work".
  
  =back
  
  =head2 Export
  
  Type libraries are exporters. For the purposes of the following examples,
  assume that the C<Types::Mine> library defines types C<Number> and C<String>.
  
     # Exports nothing.
     # 
     use Types::Mine;
     
     # Exports a function "String" which is a constant returning
     # the String type constraint.
     #
     use Types::Mine qw( String );
     
     # Exports both String and Number as above.
     #
     use Types::Mine qw( String Number );
     
     # Same.
     #
     use Types::Mine qw( :types );
     
     # Exports a sub "is_String" so that "is_String($foo)" is equivalent
     # to "String->check($foo)".
     #
     use Types::Mine qw( is_String );
     
     # Exports "is_String" and "is_Number".
     #
     use Types::Mine qw( :is );
     
     # Exports a sub "assert_String" so that "assert_String($foo)" is
     # equivalent to "String->assert_return($foo)".
     #
     use Types::Mine qw( assert_String );
     
     # Exports "assert_String" and "assert_Number".
     #
     use Types::Mine qw( :assert );
     
     # Exports a sub "to_String" so that "to_String($foo)" is equivalent
     # to "String->coerce($foo)".
     #
     use Types::Mine qw( to_String );
     
     # Exports "to_String" and "to_Number".
     #
     use Types::Mine qw( :to );
     
     # Exports "String", "is_String", "assert_String" and "coerce_String".
     #
     use Types::Mine qw( +String );
     
     # Exports everything.
     #
     use Types::Mine qw( :all );
  
  Type libraries automatically inherit from L<Exporter::Tiny>; see the
  documentation of that module for tips and tricks importing from libraries.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  
TYPE_LIBRARY

$fatpacked{"Type/Params.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARAMS';
  package Type::Params;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Params::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Params::VERSION   = '1.002001';
  }
  
  use B qw();
  use Eval::TypeTiny;
  use Scalar::Util qw(refaddr);
  use Error::TypeTiny;
  use Error::TypeTiny::Assertion;
  use Error::TypeTiny::WrongNumberOfParameters;
  use Types::Standard -types;
  use Types::TypeTiny qw(CodeLike ArrayLike to_TypeTiny);
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  our @EXPORT    = qw( compile compile_named );
  our @EXPORT_OK = qw( multisig validate validate_named Invocant );
  
  sub english_list {
  	require Type::Utils;
  	goto \&Type::Utils::english_list;
  }
  
  my $QUOTE = ($^V < 5.010 && exists(&B::cstring))
  	? \&B::cstring
  	: \&B::perlstring;   # is buggy on Perl 5.8
  
  {
  	my $Invocant;
  	sub Invocant () {
  		$Invocant ||= do {
  			require Type::Tiny::Union;
  			require Types::Standard;
  			'Type::Tiny::Union'->new(
  				name             => 'Invocant',
  				type_constraints => [
  					Types::Standard::Object(),
  					Types::Standard::ClassName(),
  				],
  			);
  		};
  	}
  }
  
  sub _mkslurpy
  {
  	my ($name, $type, $tc, $i) = @_;
  	$name = 'local $_' if $name eq '$_';
  	
  	$type eq '@'
  		? sprintf(
  			'%s = [ @_[%d..$#_] ];',
  			$name,
  			$i,
  		)
  		: sprintf(
  			'%s = (($#_-%d)%%2)==0 ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf("Odd number of elements in %%s", %s)) : +{ @_[%d..$#_] };',
  			$name,
  			$i,
  			$QUOTE->("$tc"),
  			$i,
  		);
  }
  
  sub compile
  {
  	my (@code, %env);
  	push @code, '#placeholder', '#placeholder';  # @code[0,1]
  	
  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg        = -1;
  	my $saw_slurpy = 0;
  	my $min_args   = 0;
  	my $max_args   = 0;
  	my $saw_opt    = 0;
  	
  	my $return_default_list = !!1;
  	$code[0] = 'my (%tmp, $tmp);';
  	PARAM: for my $param (@_) {
  		if (HashRef->check($param)) {
  			$code[0] = 'my (@R, %tmp, $tmp);';
  			$return_default_list = !!0;
  			last PARAM;
  		}
  		elsif (not Bool->check($param)) {
  			if ($param->has_coercion) {
  				$code[0] = 'my (@R, %tmp, $tmp);';
  				$return_default_list = !!0;
  				last PARAM;
  			}
  		}
  	}
  		
  	while (@_)
  	{
  		++$arg;
  		my $constraint = shift;
  		my $is_optional;
  		my $really_optional;
  		my $is_slurpy;
  		my $varname;
  		
  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}
  		
  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny(
  				$constraint->{slurpy}
  					or Error::TypeTiny::croak("Slurpy parameter malformed")
  			);
  			push @code,
  				$constraint->is_a_type_of(Dict)     ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Map)      ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(Tuple)    ? _mkslurpy('$_', '@', $constraint => $arg) :
  				$constraint->is_a_type_of(HashRef)  ? _mkslurpy('$_', '%', $constraint => $arg) :
  				$constraint->is_a_type_of(ArrayRef) ? _mkslurpy('$_', '@', $constraint => $arg) :
  				Error::TypeTiny::croak("Slurpy parameter not of type HashRef or ArrayRef");
  			$varname = '$_';
  			$is_slurpy++;
  			$saw_slurpy++;
  		}
  		else
  		{
  			Error::TypeTiny::croak("Parameter following slurpy parameter") if $saw_slurpy;
  			
  			$is_optional     = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			$really_optional = $is_optional && $constraint->parent->{uniq} eq Optional->{uniq} && $constraint->type_parameter;
  			
  			if ($is_optional)
  			{
  				push @code, sprintf(
  					'return %s if $#_ < %d;',
  					$return_default_list ? '@_' : '@R',
  					$arg,
  				);
  				$saw_opt++;
  				$max_args++;
  			}
  			else
  			{
  				Error::TypeTiny::croak("Non-Optional parameter following Optional parameter") if $saw_opt;
  				$min_args++;
  				$max_args++;
  			}
  			
  			$varname = sprintf '$_[%d]', $arg;
  		}
  		
  		if ($constraint->has_coercion and $constraint->coercion->can_be_inlined)
  		{
  			push @code, sprintf(
  				'$tmp%s = %s;',
  				($is_optional ? '{x}' : ''),
  				$constraint->coercion->inline_coercion($varname)
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		elsif ($constraint->has_coercion)
  		{
  			$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  			push @code, sprintf(
  				'$tmp%s = $coerce[%d]->(%s);',
  				($is_optional ? '{x}' : ''),
  				$arg,
  				$varname,
  			);
  			$varname = '$tmp'.($is_optional ? '{x}' : '');
  		}
  		
  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$really_optional
  					? $constraint->type_parameter->inline_check($varname)
  					: $constraint->inline_check($varname),
  				$constraint->{uniq},
  				$QUOTE->($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $really_optional
  				? $constraint->type_parameter->compiled_check
  				: $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				$QUOTE->($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_[%d]}', $arg),
  			);
  		}
  		
  		unless ($return_default_list) {
  			push @code, sprintf 'push @R, %s;', $varname;
  		}
  	}
  	
  	if ($min_args == $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ != %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  		);
  	}
  	elsif ($min_args < $max_args and not $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d, maximum => %d) if @_ < %d || @_ > %d;',
  			$min_args,
  			$max_args,
  			$min_args,
  			$max_args,
  		);
  	}
  	elsif ($min_args and $saw_slurpy)
  	{
  		$code[1] = sprintf(
  			'"Error::TypeTiny::WrongNumberOfParameters"->throw(got => scalar(@_), minimum => %d) if @_ < %d;',
  			$min_args,
  			$min_args,
  		);
  	}
  	
  	if ($return_default_list) {
  		push @code, '@_;';
  	}
  	else {
  		push @code, '@R;';
  	}
  	
  	my $source  = "sub { no warnings; ".join("\n", @code)." };";
  	
  	return $source if $options{want_source};
  	
  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);
  	
  	return {
  		min_args   => $min_args,
  		max_args   => $saw_slurpy ? undef : $max_args,
  		closure    => $closure,
  	} if $options{want_details};
  	
  	return $closure;
  }
  
  sub compile_named
  {
  	my (@code, %env);
  	
  	@code = 'my (%R, %tmp, $tmp);';
  	push @code, '#placeholder';   # $code[1]
  	
  	my %options    = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my $arg = -1;
  	my $had_slurpy;
  	
  	push @code, 'my %in = ((@_==1) && ref($_[0]) eq "HASH") ? %{$_[0]} : (@_ % 2) ? "Error::TypeTiny::WrongNumberOfParameters"->throw(message => "Odd number of elements in hash") : @_;';
  	
  	while (@_) {
  		++$arg;
  		my ($name, $constraint) = splice(@_, 0, 2);
  		
  		my $is_optional;
  		my $really_optional;
  		my $is_slurpy;
  		my $varname;
  		
  		if (Bool->check($constraint))
  		{
  			$constraint = $constraint ? Any : Optional[Any];
  		}
  		
  		if (HashRef->check($constraint))
  		{
  			$constraint = to_TypeTiny($constraint->{slurpy});
  			++$is_slurpy;
  			++$had_slurpy;
  		}
  		else
  		{
  			$is_optional     = grep $_->{uniq} == Optional->{uniq}, $constraint->parents;
  			$really_optional = $is_optional && $constraint->parent->{uniq} eq Optional->{uniq} && $constraint->type_parameter;
  			
  			$constraint = $constraint->type_parameter if $really_optional;
  		}
  		
  		unless ($is_optional or $is_slurpy) {
  			push @code, sprintf(
  				'exists($in{%s}) or "Error::TypeTiny::WrongNumberOfParameters"->throw(message => sprintf "Missing required parameter: %%s", %s);',
  				$QUOTE->($name),
  				$QUOTE->($name),
  			);
  		}
  		
  		my $need_to_close_if = 0;
  		
  		if ($is_slurpy) {
  			$varname = '\\%in';
  		}
  		elsif ($is_optional) {
  			push @code, sprintf('if (exists($in{%s})) {', $QUOTE->($name));
  			push @code, sprintf('$tmp = delete($in{%s});', $QUOTE->($name));
  			$varname = '$tmp';
  			++$need_to_close_if;
  		}
  		else {
  			push @code, sprintf('$tmp = delete($in{%s});', $QUOTE->($name));
  			$varname = '$tmp';
  		}
  		
  		if ($constraint->has_coercion) {
  			if ($constraint->coercion->can_be_inlined) {
  				push @code, sprintf(
  					'$tmp = %s;',
  					$constraint->coercion->inline_coercion($varname)
  				);
  			}
  			else {
  				$env{'@coerce'}[$arg] = $constraint->coercion->compiled_coercion;
  				push @code, sprintf(
  					'$tmp = $coerce[%d]->(%s);',
  					$arg,
  					$varname,
  				);
  			}
  			$varname = '$tmp';
  		}
  		
  		if ($constraint->can_be_inlined)
  		{
  			push @code, sprintf(
  				'(%s) or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				$constraint->inline_check($varname),
  				$constraint->{uniq},
  				$QUOTE->($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_{%s}}', $QUOTE->($name)),
  			);
  		}
  		else
  		{
  			$env{'@check'}[$arg] = $constraint->compiled_check;
  			push @code, sprintf(
  				'%s or Type::Tiny::_failed_check(%d, %s, %s, varname => %s);',
  				sprintf(sprintf '$check[%d]->(%s)', $arg, $varname),
  				$constraint->{uniq},
  				$QUOTE->($constraint),
  				$varname,
  				$is_slurpy ? 'q{$SLURPY}' : sprintf('q{$_{%s}}', $QUOTE->($name)),
  			);
  		}
  		
  		push @code, sprintf('$R{%s} = %s;', $QUOTE->($name), $varname);
  		
  		push @code, '}' if $need_to_close_if;
  	}
  	
  	if (!$had_slurpy) {
  		push @code, 'keys(%in) and "Error::TypeTiny"->throw(message => sprintf "Unrecognized parameter%s: %s", keys(%in)>1?"s":"", Type::Params::english_list(sort keys %in));'
  	}
  	
  	push @code, '\\%R;';
  	
  	my $source  = "sub { no warnings; ".join("\n", @code)." };";
  	return $source if $options{want_source};
  	
  	my $closure = eval_closure(
  		source      => $source,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => \%env,
  	);
  	
  	return {
  		min_args   => undef,  # always going to be 1 or 0
  		max_args   => undef,  # should be possible to figure out if no slurpy param
  		closure    => $closure,
  	} if $options{want_details};
  	
  	return $closure;
  }
  
  my %compiled;
  sub validate
  {
  	my $arr = shift;
  	my $sub = (
  		$compiled{ join ":", map($_->{uniq}||"\@$_->{slurpy}", @_) }
  			||= compile({ caller_level => 1 }, @_)
  	);
  	@_ = @$arr;
  	goto $sub;
  }
  
  my %compiled_named;
  sub validate_named
  {
  	my $arr = shift;
  	my $sub = (
  		$compiled_named{ join ":", map(ref($_)?($_->{uniq}||"\@$_->{slurpy}"):$QUOTE->($_), @_) }
  			||= compile_named({ caller_level => 1 }, @_)
  	);
  	@_ = @$arr;
  	goto $sub;
  }
  
  sub multisig
  {
  	my %options = (ref($_[0]) eq "HASH" && !$_[0]{slurpy}) ? %{+shift} : ();
  	my @multi = map {
  		CodeLike->check($_)  ? { closure => $_ } :
  		ArrayLike->check($_) ? compile({ want_details => 1 }, @$_) :
  		$_;
  	} @_;
  	
  	my @code = 'sub { my $r; ';
  	
  	for my $i (0 .. $#multi)
  	{
  		my $flag = sprintf('${^TYPE_PARAMS_MULTISIG} = %d', $i);
  		my $sig  = $multi[$i];
  		my @cond;
  		push @cond, sprintf('@_ >= %s', $sig->{min_args}) if defined $sig->{min_args};
  		push @cond, sprintf('@_ <= %s', $sig->{max_args}) if defined $sig->{max_args};
  		if (defined $sig->{max_args} and defined $sig->{min_args}) {
  			@cond = sprintf('@_ == %s', $sig->{min_args})
  				if $sig->{max_args} == $sig->{min_args};
  		}
  		push @code, sprintf('if (%s){', join(' and ', @cond)) if @cond;
  		push @code, sprintf('eval { $r = [ $multi[%d]{closure}->(@_) ]; %s };', $i, $flag);
  		push @code, 'return(@$r) if $r;';
  		push @code, '}' if @cond;
  	}
  	
  	push @code, '"Error::TypeTiny"->throw(message => "Parameter validation failed");';
  	push @code, '}';
  	
  	eval_closure(
  		source      => \@code,
  		description => sprintf("parameter validation for '%s'", [caller(1+($options{caller_level}||0))]->[3] || '__ANON__'),
  		environment => { '@multi' => \@multi },
  	);
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords evals invocant
  
  =head1 NAME
  
  Type::Params - Params::Validate-like parameter validation using Type::Tiny type constraints and coercions
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Params qw( compile );
   use Types::Standard qw( slurpy Str ArrayRef Num );
     
   sub deposit_monies
   {
      state $check = compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $check->(@_);
      
      my $account = Local::BankAccount->new($sort_code, $account_number);
      $account->deposit($_) for @$monies;
   }
   
   deposit_monies("12-34-56", "11223344", 1.2, 3, 99.99);
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type::Params uses L<Type::Tiny> constraints to validate the parameters to a
  sub. It takes the slightly unorthodox approach of separating validation
  into two stages:
  
  =over
  
  =item 1.
  
  Compiling the parameter specification into a coderef; then
  
  =item 2.
  
  Using the coderef to validate parameters.
  
  =back
  
  The first stage is slow (it might take a couple of milliseconds), but you
  only need to do it the first time the sub is called. The second stage is
  fast; according to my benchmarks faster even than the XS version of
  L<Params::Validate>.
  
  If you're using a modern version of Perl, you can use the C<state> keyword
  which was a feature added to Perl in 5.10. If you're stuck on Perl 5.8, the
  example from the SYNOPSIS could be rewritten as:
  
   my $deposit_monies_check;
   sub deposit_monies
   {
      $deposit_monies_check ||= compile( Str, Str, slurpy ArrayRef[Num] );
      my ($sort_code, $account_number, $monies) = $deposit_monies_check->(@_);
      
      ...;
   }
  
  Not quite as neat, but not awful either.
  
  There's a shortcut reducing it to one step:
  
   use Type::Params qw( validate validate_named );
   
   sub deposit_monies
   {
      my ($sort_code, $account_number, $monies) = 
         validate( \@_, Str, Str, slurpy ArrayRef[Num] );
      
      ...;
   }
  
  Type::Params has a few tricks up its sleeve to make sure performance doesn't
  suffer too much with the shortcut, but it's never going to be as fast as the
  two stage compile/execute.
  
  =begin trustme
  
  Dude, these functions are documented!
  
  =item compile
  
  =item validate
  
  =item compile_named
  
  =item validate_named
  
  =item Invocant
  
  =item multisig
  
  =end trustme
  
  =head1 COOKBOOK
  
  =head2 Positional Parameters
  
     sub nth_root
     {
        state $check = compile( Num, Num );
        my ($x, $n) = $check->(@_);
        
        return $x ** (1 / $n);
     }
  
  =head2 Method Calls
  
  Type::Params exports an additional keyword C<Invocant> on request. This is
  a type constraint accepting blessed objects and also class names.
  
     use Types::Standard qw( ClassName Object Str Int );
     use Type::Params qw( compile Invocant );
     
     # a class method
     sub new_from_json
     {
        state $check = compile( ClassName, Str );
        my ($class, $json) = $check->(@_);
        
        $class->new( from_json($json) );
     }
     
     # an object method
     sub dump
     {
        state $check = compile( Object, Int );
        my ($self, $limit) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     # can be called as either and object or class method
     sub run
     {
        state $check = compile( Invocant );
        my ($proto) = $check->(@_);
        
        my $self = ref($proto) ? $proto : $default_instance;
        $self->_run;
     }
  
  Of course, some people like to use C<shift> for the invocant:
  
     sub dump
     {
        my $self = shift;
        
        state $check = compile( Int );
        my ($limit) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
  
  =head2 Optional Parameters
  
     use Types::Standard qw( Object Optional Int );
     
     sub dump
     {
        state $check = compile( Object, Optional[Int] );
        my ($self, $limit) = $check->(@_);
        $limit //= 0;
        
        local $Data::Dumper::Maxdepth = $limit;
        print Data::Dumper::Dumper($self);
     }
     
     $obj->dump(1);      # ok
     $obj->dump();       # ok
     $obj->dump(undef);  # dies
  
  =head2 Slurpy Parameters
  
     use Types::Standard qw( slurpy ClassName HashRef );
     
     sub new
     {
        state $check = compile( ClassName, slurpy HashRef );
        my ($class, $ref) = $check->(@_);
        bless $ref => $class;
     }
     
     __PACKAGE__->new(foo => 1, bar => 2);
  
  The following types from L<Types::Standard> can be made slurpy:
  C<ArrayRef>, C<Tuple>, C<HashRef>, C<Map>, C<Dict>. Hash-like types
  will die if an odd number of elements are slurped in.
  
  A check may only have one slurpy parameter, and it must be the last
  parameter.
  
  Having a slurpy parameter will slightly slow down your checks.
  
  =head2 Named Parameters
  
  You can use C<compile_named> to accept a hash of named parameters
  
     use Type::Params qw(compile_named);
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub dump
     {
        state $check = compile_named(
           var    => Ref,
           limit  => Optional[Int],
        );
        my $arg = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }
     
     dump({ var => $foo, limit => 1 });    # ok (hashref)
     dump(  var => $foo, limit => 1  );    # ok (hash)
     dump(  var => $foo  );                # ok (no optional parameter)
     dump(  limit => 1  );                 # dies
  
  Prior to Type::Tiny 1.002000, the recommendation was to use a slurpy
  C<Dict>. This still works, though the error messages you get might not
  be quite so nice, and you don't get the automatic detection of hash
  versus hashref in the input C<< @_ >>. Oh, and it's usually slower.
  
     use Type::Params qw(compile);
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub dump
     {
        state $check = compile(
           slurpy Dict[
              var    => Ref,
              limit  => Optional[Int],
           ],
        );
        my ($arg) = $check->(@_);
        
        local $Data::Dumper::Maxdepth = $arg->{limit};
        print Data::Dumper::Dumper($arg->{var});
     }
     
     dump(  var => $foo, limit => 1  );    # ok (hash)
     dump(  var => $foo  );                # ok (no optional parameter)
     dump(  limit => 1  );                 # dies
  
  =head2 Mixed Positional and Named Parameters
  
  For this, you can still use the C<< slurpy Dict >> hack...
  
     use Types::Standard qw( slurpy Dict Ref Optional Int );
     
     sub my_print
     {
        state $check = compile(
           Str,
           slurpy Dict[
              colour => Optional[Str],
              size   => Optional[Int],
           ],
        );
        my ($string, $arg) = $check->(@_);
        
        ...;
     }
     
     my_print("Hello World", colour => "blue");
  
  =head2 Coercions
  
  Coercions will automatically be applied for I<all> type constraints that have
  a coercion associated.
  
     use Type::Utils;
     use Types::Standard qw( Int Num );
     
     my $RoundedInt = declare as Int;
     coerce $RoundedInt, from Num, q{ int($_) };
     
     sub set_age
     {
        state $check = compile( Object, $RoundedInt );
        my ($self, $age) = $check->(@_);
        
        $self->{age} = $age;
     }
     
     $obj->set_age(32.5);   # ok; coerced to "32".
  
  Coercions carry over into structured types such as C<ArrayRef> automatically:
  
     sub delete_articles
     {
        state $check = compile( Object, slurpy ArrayRef[$RoundedInt] );
        my ($db, $articles) = $check->(@_);
        
        $db->select_article($_)->delete for @$articles;
     }
     
     # delete articles 1, 2 and 3
     delete_articles($my_db, 1.1, 2.2, 3.3);
  
  If type C<Foo> has coercions from C<Str> and C<ArrayRef> and you want to
  B<prevent> coercion, then use:
  
     state $check = compile( Foo->no_coercions );
  
  Or if you just want to prevent coercion from C<Str>, use:
  
     state $check = compile( Foo->minus_coercions(Str) );
  
  Or maybe add an extra coercion:
  
     state $check = compile(
        Foo->plus_coercions(Int, q{ Foo->new_from_number($_) }),
     );
  
  Note that the coercion is specified as a string of Perl code. This is usually
  the fastest way to do it, but a coderef is also accepted. Either way, the
  value to be coerced is C<< $_ >>.
  
  Having any coercions will slightly slow down your checks.
  
  =head2 Alternatives
  
  Type::Params can export a C<multisig> function that compiles multiple
  alternative signatures into one, and uses the first one that works:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        [ HashRef, Num ],
        [ CodeRef ],
     );
     
     my ($int, $arrayref) = $check->( 1, [] );
     my ($hashref, $num)  = $check->( {}, 1.1 );
     my ($code)           = $check->( sub { 1 } );
     
     $check->( sub { 1 }, 1.1 );  # throws an exception
  
  Coercions, slurpy parameters, etc still work.
  
  The magic global C<< ${^TYPE_PARAMS_MULTISIG} >> is set to the index of
  the first signature which succeeded.
  
  The present implementation involves compiling each signature independently,
  and trying them each (in their given order!) in an C<eval> block. The only
  slightly intelligent part is that it checks if C<< scalar(@_) >> fits into
  the signature properly (taking into account optional and slurpy parameters),
  and skips evals which couldn't possibly succeed.
  
  It's also possible to list coderefs as alternatives in C<multisig>:
  
     state $check = multisig(
        [ Int, ArrayRef ],
        sub { ... },
        [ HashRef, Num ],
        [ CodeRef ],
        compile_named( needle => Value, haystack => Ref ),
     );
  
  The coderef is expected to die if that alternative should be abandoned (and
  the next alternative tried), or return the list of accepted parameters. Here's
  a full example:
  
     sub get_from {
        state $check = multisig(
           [ Int, ArrayRef ],
           [ Str, HashRef ],
           sub {
              my ($meth, $obj);
              die unless is_Object($obj);
              die unless $obj->can($meth);
              return ($meth, $obj);
           },
        );
        
        my ($needle, $haystack) = $check->(@_);
        
        for (${^TYPE_PARAMS_MULTISIG) {
           return $haystack->[$needle] if $_ == 0;
           return $haystack->{$needle} if $_ == 1;
           return $haystack->$needle   if $_ == 2;
        }
     }
     
     get_from(0, \@array);      # returns $array[0]
     get_from('foo', \%hash);   # returns $hash{foo}
     get_from('foo', $obj);     # returns $obj->foo
  
  =head2 Defaults
  
  Type::Params does not currently offer a built-in way to set defaults
  for a parameter. Setting defaults manually is not especially difficult.
  
     sub print_coloured {
        state $check = compile( Str, Optional[Str] );
        
        my ($text, $colour) = $check->(@_);
        $colour //= "black";
        
        ...;
     }
  
  I occasionally get requests for this to work:
  
     sub print_coloured {
        state $check = compile( Str, Default[Str, "black"] );
        
        my ($text, $colour) = $check->(@_);
        
        ...;
     }
  
  But honestly, I don't find that any clearer.
  
  =head1 COMPARISON WITH PARAMS::VALIDATE
  
  L<Type::Params> is not really a drop-in replacement for L<Params::Validate>;
  the API differs far too much to claim that. Yet it performs a similar task,
  so it makes sense to compare them.
  
  =over
  
  =item *
  
  Type::Params will tend to be faster if you've got a sub which is called
  repeatedly, but may be a little slower than Params::Validate for subs that
  are only called a few times. This is because it does a bunch of work the
  first time your sub is called to make subsequent calls a lot faster.
  
  =item *
  
  Params::Validate doesn't appear to have a particularly natural way of
  validating a mix of positional and named parameters.
  
  =item *
  
  Type::Utils allows you to coerce parameters. For example, if you expect
  a L<Path::Tiny> object, you could coerce it from a string.
  
  =item *
  
  Params::Validate allows you to supply defaults for missing parameters;
  Type::Params does not, but you may be able to use coercion from Undef.
  
  =item *
  
  If you are primarily writing object-oriented code, using Moose or similar,
  and you are using Type::Tiny type constraints for your attributes, then
  using Type::Params allows you to use the same constraints for method calls.
  
  =item *
  
  Type::Params comes bundled with Types::Standard, which provides a much
  richer vocabulary of types than the type validation constants that come
  with Params::Validate. For example, Types::Standard provides constraints
  like C<< ArrayRef[Int] >> (an arrayref of integers), while the closest from
  Params::Validate is C<< ARRAYREF >>, which you'd need to supplement with
  additional callbacks if you wanted to check that the arrayref contained
  integers.
  
  Whatsmore, Type::Params doesn't just work with Types::Standard, but also
  any other Type::Tiny type constraints.
  
  =back
  
  =head1 COMPARISON WITH PARAMS::VALIDATIONCOMPILER
  
  L<Params::ValidationCompiler> does basically the same thing as
  L<Type::Params>.
  
  =over
  
  =item *
  
  Params::ValidationCompiler and Type::Params are likely to perform fairly
  similarly. In most cases, recent versions of Type::Params seem to be
  I<slightly> faster, but except in very trivial cases, you're unlikely to
  notice the speed difference. Speed probably shouldn't be a factor when
  choosing between them.
  
  =item *
  
  Type::Params's syntax is more compact:
  
     state $check = compile(Object, Optional[Int], slurpy ArrayRef);
  
  Versus:
  
     state $check = validation_for(
        params => [
           { type => Object },
           { type => Int,      optional => 1 },
           { type => ArrayRef, slurpy => 1 },
        ],
     );
  
  =item *
  
  L<Params::ValidationCompiler> offers defaults.
  
  =item *
  
  L<Params::ValidationCompiler> probably has slightly better exceptions.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>, L<Type::Coercion>, L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARAMS

$fatpacked{"Type/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_PARSER';
  package Type::Parser;
  
  use strict;
  use warnings;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.002001';
  
  # Token types
  # 
  sub TYPE      () { "TYPE" };
  sub QUOTELIKE () { "QUOTELIKE" };
  sub STRING    () { "STRING" };
  sub CLASS     () { "CLASS" };
  sub L_BRACKET () { "L_BRACKET" };
  sub R_BRACKET () { "R_BRACKET" };
  sub COMMA     () { "COMMA" };
  sub SLURPY    () { "SLURPY" };
  sub UNION     () { "UNION" };
  sub INTERSECT () { "INTERSECT" };
  sub NOT       () { "NOT" };
  sub L_PAREN   () { "L_PAREN" };
  sub R_PAREN   () { "R_PAREN" };
  sub MYSTERY   () { "MYSTERY" };
  
  our @EXPORT_OK = qw( eval_type _std_eval parse extract_type );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  Evaluate: {
  	
  	sub parse
  	{
  		my $str = $_[0];
  		my $parser = "Type::Parser::AstBuilder"->new(input => $str);
  		$parser->build;
  		wantarray ? ($parser->ast, $parser->remainder) : $parser->ast;
  	}
  	
  	sub extract_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		wantarray ? (_eval_type($parsed, $reg), $tail) : _eval_type($parsed, $reg);
  	}
  	
  	sub eval_type
  	{
  		my ($str, $reg) = @_;
  		my ($parsed, $tail) = parse($str);
  		_croak("Unexpected tail on type expression: $tail") if $tail =~ /\S/sm;
  		return _eval_type($parsed, $reg);
  	}
  	
  	my $std;
  	sub _std_eval
  	{
  		require Type::Registry;
  		unless ($std)
  		{
  			$std = "Type::Registry"->new;
  			$std->add_types(-Standard);
  		}
  		eval_type($_[0], $std);
  	}
  	
  	sub _eval_type
  	{
  		my ($node, $reg) = @_;
  		
  		$node = _simplify_expression($node);
  		
  		if ($node->{type} eq "list")
  		{
  			return map _eval_type($_, $reg), @{$node->{list}};
  		}
  		
  		if ($node->{type} eq "union")
  		{
  			return $reg->make_union(
  				map _eval_type($_, $reg), @{$node->{union}}
  			);
  		}
  		
  		if ($node->{type} eq "intersect")
  		{
  			return $reg->make_intersection(
  				map _eval_type($_, $reg), @{$node->{intersect}}
  			);
  		}
  		
  		if ($node->{type} eq "slurpy")
  		{
  			return +{ slurpy => _eval_type($node->{of}, $reg) };
  		}
  		
  		if ($node->{type} eq "complement")
  		{
  			return _eval_type($node->{of}, $reg)->complementary_type;
  		}
  		
  		if ($node->{type} eq "parameterized")
  		{
  			my $base = _eval_type($node->{base}, $reg);
  			
  			return $base unless $base->is_parameterizable || $node->{params};
  			return $base->parameterize($node->{params} ? _eval_type($node->{params}, $reg) : ());
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq CLASS)
  		{
  			my $class = substr(
  				$node->{token}->spelling,
  				0,
  				length($node->{token}->spelling) - 2
  			);
  			return $reg->make_class_type($class);
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq QUOTELIKE)
  		{
  			return eval($node->{token}->spelling); #ARGH
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq STRING)
  		{
  			return $node->{token}->spelling;
  		}
  		
  		if ($node->{type} eq "primary" and $node->{token}->type eq TYPE)
  		{
  			my $t = $node->{token}->spelling;
  			my $r = ($t =~ /^(.+)::(\w+)$/)
  				? $reg->foreign_lookup($t, 1)
  				: $reg->simple_lookup($t, 1);
  			$r or _croak("%s is not a known type constraint", $node->{token}->spelling);
  			return $r;
  		}
  	}
  	
  	sub _simplify_expression
  	{
  		my $expr = shift;
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq COMMA)
  		{
  			return _simplify("list", COMMA, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq UNION)
  		{
  			return _simplify("union", UNION, $expr);
  		}
  		
  		if ($expr->{type} eq "expression" and $expr->{op}[0] eq INTERSECT)
  		{
  			return _simplify("intersect", INTERSECT, $expr);
  		}
  		
  		return $expr;
  	}
  	
  	sub _simplify
  	{
  		my $type = shift;
  		my $op   = shift;
  		
  		my @list;
  		for my $expr ($_[0]{lhs}, $_[0]{rhs})
  		{
  			if ($expr->{type} eq "expression" and $expr->{op}[0] eq $op)
  			{
  				my $simple = _simplify($type, $op, $expr);
  				push @list, @{ $simple->{$type} };
  			}
  			else
  			{
  				push @list, $expr;
  			}
  		}
  		
  		return { type => $type, $type => \@list };
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::AstBuilder;
  	
  	sub new
  	{
  		my $class = shift;
  		bless { @_ }, $class;
  	}
  	
  	our %precedence = (
  #		Type::Parser::COMMA()     , 1 ,
  		Type::Parser::UNION()     , 2 ,
  		Type::Parser::INTERSECT() , 3 ,
  		Type::Parser::NOT()       , 4 ,
  	);
  	
  	sub _parse_primary
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		$tokens->assert_not_empty;
  		
  		if ($tokens->peek(0)->type eq Type::Parser::NOT)
  		{
  			$tokens->eat(Type::Parser::NOT);
  			$tokens->assert_not_empty;
  			return {
  				type  => "complement",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::SLURPY)
  		{
  			$tokens->eat(Type::Parser::SLURPY);
  			$tokens->assert_not_empty;
  			return {
  				type  => "slurpy",
  				of    => $self->_parse_primary,
  			};
  		}
  		
  		if ($tokens->peek(0)->type eq Type::Parser::L_PAREN)
  		{
  			$tokens->eat(Type::Parser::L_PAREN);
  			my $r = $self->_parse_expression;
  			$tokens->eat(Type::Parser::R_PAREN);
  			return $r;
  		}
  		
  		if ($tokens->peek(1)
  		and $tokens->peek(0)->type eq Type::Parser::TYPE
  		and $tokens->peek(1)->type eq Type::Parser::L_BRACKET)
  		{
  			my $base = { type  => "primary", token => $tokens->eat(Type::Parser::TYPE) };
  			$tokens->eat(Type::Parser::L_BRACKET);
  			$tokens->assert_not_empty;
  			
  			local $precedence{ Type::Parser::COMMA() } = 1;
  			
  			my $params = undef;
  			if ($tokens->peek(0)->type eq Type::Parser::R_BRACKET)
  			{
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			else
  			{
  				$params = $self->_parse_expression;
  				$params = { type => "list", list => [$params] } unless $params->{type} eq "list";
  				$tokens->eat(Type::Parser::R_BRACKET);
  			}
  			return {
  				type   => "parameterized",
  				base   => $base,
  				params => $params,
  			};
  		}
  		
  		my $type = $tokens->peek(0)->type;
  		if ($type eq Type::Parser::TYPE
  		or  $type eq Type::Parser::QUOTELIKE
  		or  $type eq Type::Parser::STRING
  		or  $type eq Type::Parser::CLASS)
  		{
  			return { type  => "primary", token => $tokens->eat };
  		}
  		
  		Type::Parser::_croak("Unexpected token in primary type expression; got '%s'", $tokens->peek(0)->spelling);
  	}
  	
  	sub _parse_expression_1
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		my ($lhs, $min_p) = @_;
  		while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} >= $min_p)
  		{
  			my $op  = $tokens->eat;
  			my $rhs = $self->_parse_primary;
  			
  			while (!$tokens->empty and defined($precedence{$tokens->peek(0)->type}) and $precedence{$tokens->peek(0)->type} > $precedence{$op->type})
  			{
  				my $lookahead = $tokens->peek(0);
  				$rhs = $self->_parse_expression_1($rhs, $precedence{$lookahead->type});
  			}
  			
  			$lhs = {
  				type => "expression",
  				op   => $op,
  				lhs  => $lhs,
  				rhs  => $rhs,
  			};
  		}
  		return $lhs;
  	}
  	
  	sub _parse_expression
  	{
  		my $self   = shift;
  		my $tokens = $self->{tokens};
  		
  		return $self->_parse_expression_1($self->_parse_primary, 0);
  	}
  	
  	sub build
  	{
  		my $self = shift;
  		$self->{tokens} = "Type::Parser::TokenStream"->new(remaining => $self->{input});
  		$self->{ast}    = $self->_parse_expression;
  	}
  	
  	sub ast
  	{
  		$_[0]{ast};
  	}
  	
  	sub remainder
  	{
  		$_[0]{tokens}->remainder;
  	}
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::Token;
  	sub type     { $_[0][0] }
  	sub spelling { $_[0][1] }
  }
  
  {
  	package # hide from CPAN
  	Type::Parser::TokenStream;
  	
  	use Scalar::Util qw(looks_like_number);
  	
  	sub new
  	{
  		my $class = shift;
  		bless { stack => [], done => [], @_ }, $class;
  	}
  	
  	sub peek
  	{
  		my $self  = shift;
  		my $ahead = $_[0];
  		
  		while ($self->_stack_size <= $ahead and length $self->{remaining})
  		{
  			$self->_stack_extend;
  		}
  		
  		my @tokens = grep ref, @{ $self->{stack} };
  		return $tokens[$ahead];
  	}
  	
  	sub empty
  	{
  		my $self = shift;
  		not $self->peek(0);
  	}
  	
  	sub eat
  	{
  		my $self = shift;
  		$self->_stack_extend unless $self->_stack_size;
  		my $r;
  		while (defined(my $item = shift @{$self->{stack}}))
  		{
  			push @{ $self->{done} }, $item;
  			if (ref $item)
  			{
  				$r = $item;
  				last;
  			}
  		}
  		
  		if (@_ and $_[0] ne $r->type)
  		{
  			unshift @{$self->{stack}}, pop @{$self->{done}};
  			Type::Parser::_croak("Expected $_[0]; got ".$r->type);
  		}
  		
  		return $r;
  	}
  	
  	sub assert_not_empty
  	{
  		my $self = shift;
  		Type::Parser::_croak("Expected token; got empty string") if $self->empty;
  	}
  	
  	sub _stack_size
  	{
  		my $self = shift;
  		scalar grep ref, @{ $self->{stack} };
  	}
  	
  	sub _stack_extend
  	{
  		my $self = shift;
  		push @{ $self->{stack} }, $self->_read_token;
  		my ($space) = ($self->{remaining} =~ m/^([\s\n\r]*)/sm);
  		return unless length $space;
  		push @{ $self->{stack} }, $space;
  		substr($self->{remaining}, 0, length $space) = "";
  	}
  	
  	sub remainder
  	{
  		my $self = shift;
  		return join "",
  			map { ref($_) ? $_->spelling : $_ }
  			(@{$self->{stack}}, $self->{remaining})
  	}
  	
  	my %punctuation = (
  		'['       => bless([ Type::Parser::L_BRACKET, "[" ], "Type::Parser::Token"),
  		']'       => bless([ Type::Parser::R_BRACKET, "]" ], "Type::Parser::Token"),
  		'('       => bless([ Type::Parser::L_PAREN,   "[" ], "Type::Parser::Token"),
  		')'       => bless([ Type::Parser::R_PAREN,   "]" ], "Type::Parser::Token"),
  		','       => bless([ Type::Parser::COMMA,     "," ], "Type::Parser::Token"),
  		'=>'      => bless([ Type::Parser::COMMA,     "=>" ], "Type::Parser::Token"),
  		'slurpy'  => bless([ Type::Parser::SLURPY,    "slurpy" ], "Type::Parser::Token"),
  		'|'       => bless([ Type::Parser::UNION,     "|" ], "Type::Parser::Token"),
  		'&'       => bless([ Type::Parser::INTERSECT, "&" ], "Type::Parser::Token"),
  		'~'       => bless([ Type::Parser::NOT,       "~" ], "Type::Parser::Token"),
  	);
  	
  	sub _read_token
  	{
  		my $self = shift;
  		
  		return if $self->{remaining} eq "";
  		
  		# Punctuation
  		# 
  		
  		if ($self->{remaining} =~ /^( => | [()\]\[|&~,] )/xsm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			return $punctuation{$spelling};
  		}
  		
  		if ($self->{remaining} =~ /\A\s*[q'"]/sm)
  		{
  			require Text::Balanced;
  			if (my $quotelike = Text::Balanced::extract_quotelike($self->{remaining}))
  			{
  				return bless([ Type::Parser::QUOTELIKE, $quotelike ], "Type::Parser::Token"),;
  			}
  		}
  		
  		if ($self->{remaining} =~ /^([+-]?[\w:.+]+)/sm)
  		{
  			my $spelling = $1;
  			substr($self->{remaining}, 0, length $spelling) = "";
  			
  			if ($spelling =~ /::$/sm)
  			{
  				return bless([ Type::Parser::CLASS, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif (looks_like_number($spelling))
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($self->{remaining} =~ /^\s*=>/sm) # peek ahead
  			{
  				return bless([ Type::Parser::STRING, $spelling ], "Type::Parser::Token"),;
  			}
  			elsif ($spelling eq "slurpy")
  			{
  				return $punctuation{$spelling};
  			}
  			
  			return bless([ Type::Parser::TYPE, $spelling ], "Type::Parser::Token");
  		}
  		
  		my $rest = $self->{remaining};
  		$self->{remaining} = "";
  		return bless([ Type::Parser::MYSTERY, $rest ], "Type::Parser::Token");
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords non-whitespace
  
  =head1 NAME
  
  Type::Parser - parse type constraint strings
  
  =head1 SYNOPSIS
  
   use v5.10;
   use strict;
   use warnings;
   
   use Type::Parser qw( eval_type );
   use Type::Registry;
   
   my $reg = Type::Registry->for_me;
   $reg->add_types("Types::Standard");
   
   my $type = eval_type("Int | ArrayRef[Int]", $reg);
   
   $type->check(10);        # true
   $type->check([1..4]);    # true
   $type->check({foo=>1});  # false
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Generally speaking, you probably don't want to be using this module directly.
  Instead use the C<< lookup >> method from L<Type::Registry> which wraps it.
  
  =head2 Functions
  
  =over
  
  =item C<< parse($string) >>
  
  Parse the type constraint string into something like an AST.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< extract_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  If called in list context, also returns any "tail" found on the original string.
  
  =item C<< eval_type($string, $registry) >>
  
  Compile a type constraint string into a L<Type::Tiny> object.
  
  Throws an error if the "tail" contains any non-whitespace character.
  
  =back
  
  =head2 Constants
  
  The following constants correspond to values returned by C<< $token->type >>.
  
  =over
  
  =item C<< TYPE >>
  
  =item C<< QUOTELIKE >>
  
  =item C<< STRING >>
  
  =item C<< CLASS >>
  
  =item C<< L_BRACKET >>
  
  =item C<< R_BRACKET >>
  
  =item C<< COMMA >>
  
  =item C<< SLURPY >>
  
  =item C<< UNION >>
  
  =item C<< INTERSECT >>
  
  =item C<< NOT >>
  
  =item C<< L_PAREN >>
  
  =item C<< R_PAREN >>
  
  =item C<< MYSTERY >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Registry>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_PARSER

$fatpacked{"Type/Registry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_REGISTRY';
  package Type::Registry;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Registry::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Registry::VERSION   = '1.002001';
  }
  
  use Exporter::Tiny qw( mkopt );
  use Scalar::Util qw( refaddr );
  use Type::Parser qw( eval_type );
  use Types::TypeTiny qw( CodeLike ArrayLike to_TypeTiny );
  
  our @ISA = 'Exporter::Tiny';
  our @EXPORT_OK = qw(t);
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _exporter_expand_sub
  {
  	my $class = shift;
  	my ($name, $value, $globals, $permitted) = @_;
  	
  	if ($name eq "t")
  	{
  		my $caller = $globals->{into};
  		my $reg = $class->for_class(
  			ref($caller) ? sprintf('HASH(0x%08X)', refaddr($caller)) : $caller
  		);
  		return t => sub (;$) { @_ ? $reg->lookup(@_) : $reg };
  	}
  	
  	return $class->SUPER::_exporter_expand_sub(@_);
  }
  
  sub new
  {
  	my $class = shift;
  	ref($class) and _croak("Not an object method");
  	bless {}, $class;
  }
  
  {
  	my %registries;
  	
  	sub for_class
  	{
  		my $class = shift;
  		my ($for) = @_;
  		$registries{$for} ||= $class->new;
  	}
  	
  	sub for_me
  	{
  		my $class = shift;
  		my $for   = caller;
  		$registries{$for} ||= $class->new;
  	}
  }
  
  sub add_types
  {
  	my $self = shift;
  	my $opts = mkopt(\@_);
  	for my $opt (@$opts)
  	{
  		my ($library, $types) = @_;
  		$library =~ s/^-/Types::/;
  		
  		{
  			local $SIG{__DIE__} = sub {};
  			eval "require $library";
  		};
  		
  		my %hash;
  		
  		if ($library->isa("Type::Library") or $library eq 'Types::TypeTiny')
  		{
  			$types ||= [qw/-types/];
  			ArrayLike->check($types)
  				or _croak("Expected arrayref following '%s'; got %s", $library, $types);
  			
  			$library->import({into => \%hash}, @$types);
  			$hash{$_} = &{$hash{$_}}() for keys %hash;
  		}
  		elsif ($library->isa("MooseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MooseX::Types type constraint library. No import options currently supported", $library);
  			
  			require Moose::Util::TypeConstraints;
  			my $moosextypes = $library->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Moose::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		elsif ($library->isa("MouseX::Types::Base"))
  		{
  			$types ||= [];
  			ArrayLike->check($types) && (@$types == 0)
  				or _croak("Library '%s' is a MouseX::Types type constraint library. No import options currently supported", $library);
  			
  			require Mouse::Util::TypeConstraints;
  			my $moosextypes = $library->type_storage;
  			for my $name (sort keys %$moosextypes)
  			{
  				my $tt = to_TypeTiny(
  					Mouse::Util::TypeConstraints::find_type_constraint($moosextypes->{$name})
  				);
  				$hash{$name} = $tt;
  			}
  		}
  		else
  		{
  			_croak("%s is not a type library", $library);
  		}
  		
  		for my $key (sort keys %hash)
  		{
  			exists($self->{$key})
  				and $self->{$key}{uniq} != $hash{$key}{uniq}
  				and _croak("Duplicate type name: %s", $key);
  			$self->{$key} = $hash{$key};
  		}
  	}
  	$self;
  }
  
  sub add_type
  {
  	my $self = shift;
  	my ($type, $name) = @_;
  	$type = to_TypeTiny($type);
  	$name ||= do {
  		$type->is_anon
  			and _croak("Expected named type constraint; got anonymous type constraint");
  		$type->name;
  	};
  	
  	exists($self->{$name})
  		and $self->{$name}{uniq} != $type->{uniq}
  		and _croak("Duplicate type name: %s", $name);
  	
  	$self->{$name} = $type;
  	$self;
  }
  
  sub alias_type
  {
  	my $self = shift;
  	my ($old, @new) = @_;
  	my $lookup = eval { $self->lookup($old) }
  		or _croak("Expected existing type constraint name; got '$old'");
  	$self->{$_} = $lookup for @new;
  	$self;
  }
  
  sub simple_lookup
  {
  	my $self = shift;
  	
  	my ($tc) = @_;
  	$tc =~ s/(^\s+|\s+$)//g;
  	
  	if (exists $self->{$tc})
  	{
  		return $self->{$tc};
  	}
  	
  	return;
  }
  
  sub foreign_lookup
  {
  	my $self = shift;
  	
  	return $_[1] ? () : $self->simple_lookup($_[0], 1)
  		unless $_[0] =~ /^(.+)::(\w+)$/;
  	
  	my $library  = $1;
  	my $typename = $2;
  	
  	{
  		local $SIG{__DIE__} = sub {};
  		eval "require $library;";
  	};
  	
  	if ( $library->isa('MooseX::Types::Base') )
  	{
  		require Moose::Util::TypeConstraints;
  		my $type = Moose::Util::TypeConstraints::find_type_constraint(
  			$library->get_type($typename)
  		) or return;
  		return to_TypeTiny($type);
  	}
  	
  	if ( $library->isa('MouseX::Types::Base') )
  	{
  		require Mouse::Util::TypeConstraints;
  		my $sub  = $library->can($typename) or return;
  		my $type = Mouse::Util::TypeConstraints::find_type_constraint($sub->()) or return;
  		return to_TypeTiny($type);
  	}
  	
  	if ( $library->can("get_type") )
  	{
  		my $type = $library->get_type($typename);
  		return to_TypeTiny($type);
  	}
  	
  	return;
  }
  
  sub lookup
  {
  	my $self = shift;
  	
  	$self->simple_lookup(@_) or eval_type($_[0], $self);
  }
  
  sub make_union
  {
  	my $self = shift;
  	my (@types) = @_;
  	
  	require Type::Tiny::Union;
  	return "Type::Tiny::Union"->new(type_constraints => \@types);
  }
  
  sub make_intersection
  {
  	my $self = shift;
  	my (@types) = @_;
  	
  	require Type::Tiny::Intersection;
  	return "Type::Tiny::Intersection"->new(type_constraints => \@types);
  }
  
  sub make_class_type
  {
  	my $self = shift;
  	my ($class) = @_;
  	
  	require Type::Tiny::Class;
  	return "Type::Tiny::Class"->new(class => $class);
  }
  
  sub make_role_type
  {
  	my $self = shift;
  	my ($role) = @_;
  	
  	require Type::Tiny::Role;
  	return "Type::Tiny::Role"->new(role => $role);
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($method) = (our $AUTOLOAD =~ /(\w+)$/);
  	my $type = $self->simple_lookup($method);
  	return $type if $type;
  	_croak(q[Can't locate object method "%s" via package "%s"], $method, ref($self));
  }
  
  # Prevent AUTOLOAD being called for DESTROY!
  sub DESTROY
  {
  	return;
  }
  
  DELAYED: {
  	our %DELAYED;
  	for my $package (sort keys %DELAYED)
  	{
  		my $reg   = __PACKAGE__->for_class($package);
  		my $types = $DELAYED{$package};
  		
  		for my $name (sort keys %$types)
  		{
  			$reg->add_type($types->{$name}, $name);
  		}
  	}
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords optlist
  
  =head1 NAME
  
  Type::Registry - a glorified hashref for looking up type constraints
  
  =head1 SYNOPSIS
  
  =for test_synopsis no warnings qw(misc);
  
     package Foo::Bar;
     
     use Type::Registry;
     
     my $reg = "Type::Registry"->for_me;  # a registry for Foo::Bar
     
     # Register all types from Types::Standard
     $reg->add_types(-Standard);
     
     # Register just one type from Types::XSD
     $reg->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     $reg->add_types("MyApp::Types");
     
     # Create a type alias
     $reg->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = $reg->lookup("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  Alternatively:
  
     package Foo::Bar;
     
     use Type::Registry qw( t );
     
     # Register all types from Types::Standard
     t->add_types(-Standard);
     
     # Register just one type from Types::XSD
     t->add_types(-XSD => ["NonNegativeInteger"]);
     
     # Register all types from MyApp::Types
     t->add_types("MyApp::Types");
     
     # Create a type alias
     t->alias_type("NonNegativeInteger" => "Count");
     
     # Look up a type constraint
     my $type = t("ArrayRef[Count]");
     
     $type->check([1, 2, 3.14159]);  # croaks
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A type registry is basically just a hashref mapping type names to type
  constraint objects.
  
  =head2 Constructors
  
  =over
  
  =item C<< new >>
  
  Create a new glorified hashref.
  
  =item C<< for_class($class) >>
  
  Create or return the existing glorified hashref associated with the given
  class.
  
  Note that any type constraint you have imported from Type::Library-based
  type libraries will be automatically available in your class' registry.
  
  =item C<< for_me >>
  
  Create or return the existing glorified hashref associated with the caller.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< add_types(@libraries) >>
  
  The libraries list is treated as an "optlist" (a la L<Data::OptList>).
  
  Strings are the names of type libraries; if the first character is a
  hyphen, it is expanded to the "Types::" prefix. If followed by an
  arrayref, this is the list of types to import from that library.
  Otherwise, imports all types from the library.
  
     use Type::Registry qw(t);
     
     t->add_types(-Standard);  # OR: t->add_types("Types::Standard");
     
     t->add_types(
        -TypeTiny => ['HashLike'],
        -Standard => ['HashRef' => { -as => 'RealHash' }],
     );
  
  L<MooseX::Types> (and experimentally, L<MouseX::Types>) libraries can
  also be added this way, but I<< cannot be followed by an arrayref of
  types to import >>.
  
  =item C<< add_type($type, $name) >>
  
  The long-awaited singular form of C<add_types>. Given a type constraint
  object, adds it to the registry with a given name. The name may be
  omitted, in which case C<< $type->name >> is called, and Type::Registry
  will throw an error if C<< $type >> is anonymous. If a name is explicitly
  given, Type::Registry cares not one wit whether the type constraint is
  anonymous.
  
  This method can even add L<MooseX::Types> and L<MouseX::Types> type
  constraints; indeed anything that can be handled by L<Types::TypeTiny>'s
  C<to_TypeTiny> function. (Bear in mind that to_TypeTiny I<always> results
  in an anonymous type constraint, so C<< $name >> will be required.)
  
  =item C<< alias_type($oldname, $newname) >>
  
  Create an alias for an existing type.
  
  =item C<< simple_lookup($name) >>
  
  Look up a type in the registry by name. 
  
  Returns undef if not found.
  
  =item C<< foreign_lookup($name) >>
  
  Like C<simple_lookup>, but if the type name contains "::", will attempt
  to load it from a type library. (And will attempt to load that module.)
  
  =item C<< lookup($name) >>
  
  Look up by name, with a DSL.
  
     t->lookup("Int|ArrayRef[Int]")
  
  The DSL can be summed up as:
  
     X               type from this registry
     My::Lib::X      type from a type library
     ~X              complementary type
     X | Y           union
     X & Y           intersection
     X[...]          parameterized type
     slurpy X        slurpy type
     Foo::Bar::      class type
  
  Croaks if not found.
  
  =item C<< make_union(@constraints) >>,
  C<< make_intersection(@constraints) >>,
  C<< make_class_type($class) >>,
  C<< make_role_type($role) >>
  
  Convenience methods for creating certain common type constraints.
  
  =item C<< AUTOLOAD >>
  
  Overloaded to call C<lookup>.
  
     $registry->Str;  # like $registry->lookup("Str")
  
  =back
  
  =head2 Functions
  
  =over
  
  =item C<< t >>
  
  This class can export a function C<< t >> which acts like
  C<< "Type::Registry"->for_class($importing_class) >>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Library>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_REGISTRY

$fatpacked{"Type/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY';
  package Type::Tiny;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::AUTHORITY   = 'cpan:TOBYINK';
  	$Type::Tiny::VERSION     = '1.002001';
  	$Type::Tiny::XS_VERSION  = '0.011';
  }
  
  use Eval::TypeTiny ();
  use Scalar::Util qw( blessed weaken refaddr isweak );
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  sub _swap { $_[2] ? @_[1,0] : @_[0,1] }
  
  BEGIN {
  	($] < 5.010001)
  		? eval q{ sub SUPPORT_SMARTMATCH () { !!0 } }
  		: eval q{ sub SUPPORT_SMARTMATCH () { !!1 } };
  	($] >= 5.014)
  		? eval q{ sub _FIXED_PRECEDENCE () { !!1 } }
  		: eval q{ sub _FIXED_PRECEDENCE () { !!0 } };
  };
  
  BEGIN {
  	my $try_xs =
  		exists($ENV{PERL_TYPE_TINY_XS}) ? !!$ENV{PERL_TYPE_TINY_XS} :
  		exists($ENV{PERL_ONLY})         ?  !$ENV{PERL_ONLY} :
  		1;
  	
  	my $use_xs = 0;
  	$try_xs and eval {
  		require Type::Tiny::XS;
  		'Type::Tiny::XS'->VERSION($Type::Tiny::XS_VERSION);
  		$use_xs++;
  	};
  	
  	*_USE_XS = $use_xs
  		? sub () { !!1 }
  		: sub () { !!0 };
  	
  	*_USE_MOUSE = $try_xs
  		? sub () { $INC{'Mouse/Util.pm'} and Mouse::Util::MOUSE_XS() }
  		: sub () { !!0 };
  };
  
  sub __warn__ {
  	my ($msg, $thing) = @_==2 ? @_ : (Thing => @_);
  	my $string = do {
  		blessed($thing) && $thing->isa('Type::Tiny::Union') ? sprintf('Union[%s]', join q{, }, map $_->name, @{$thing->type_constraints}) :
  		blessed($thing) && $thing->isa('Type::Tiny') ? $thing->name :
  		blessed($thing) && $thing->isa('Type::Tiny::_HalfOp') ? sprintf('HalfOp[ q{%s}, %s, %s ]', $thing->{op}, $thing->{type}->name, $thing->{param}) :
  		!defined($thing) ? 'NIL' :
  		"$thing"
  	};
  	warn "$msg => $string\n";
  	$thing;
  }
  
  use overload
  	q("")      => sub { caller =~ m{^(Moo::HandleMoose|Sub::Quote)} ? overload::StrVal($_[0]) : $_[0]->display_name },
  	q(bool)    => sub { 1 },
  	q(&{})     => "_overload_coderef",
  	q(|)       => sub {
  		my @tc = _swap @_;
  		if (!_FIXED_PRECEDENCE && $_[2]) {
  			if (blessed $tc[0]) {
  				if (blessed $tc[0] eq "Type::Tiny::_HalfOp") {
  					my $type  = $tc[0]->{type};
  					my $param = $tc[0]->{param};
  					my $op    = $tc[0]->{op};
  					require Type::Tiny::Union;
  					return "Type::Tiny::_HalfOp"->new(
  						$op,
  						$param,
  						"Type::Tiny::Union"->new(type_constraints => [$type, $tc[1]]),
  					);
  				}
  			}
  			elsif (ref $tc[0] eq 'ARRAY') {
  				require Type::Tiny::_HalfOp;
  				return "Type::Tiny::_HalfOp"->new('|', @tc);
  			}
  	}
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(type_constraints => \@tc)
  	},
  	q(&)       => sub {
  		my @tc = _swap @_;
  		if (!_FIXED_PRECEDENCE && $_[2]) {
  			if (blessed $tc[0]) {
  				if (blessed $tc[0] eq "Type::Tiny::_HalfOp") {
  					my $type  = $tc[0]->{type};
  					my $param = $tc[0]->{param};
  					my $op    = $tc[0]->{op};
  					require Type::Tiny::Intersection;
  					return "Type::Tiny::_HalfOp"->new(
  						$op,
  						$param,
  						"Type::Tiny::Intersection"->new(type_constraints => [$type, $tc[1]]),
  					);
  				}
  			}
  			elsif (ref $tc[0] eq 'ARRAY') {
  				require Type::Tiny::_HalfOp;
  				return "Type::Tiny::_HalfOp"->new('&', @tc);
  			}
  	}
  		require Type::Tiny::Intersection;
  		"Type::Tiny::Intersection"->new(type_constraints => \@tc)
  	},
  	q(~)       => sub { shift->complementary_type },
  	q(==)      => sub { $_[0]->equals($_[1]) },
  	q(!=)      => sub { not $_[0]->equals($_[1]) },
  	q(<)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(_swap @_) },
  	q(>)       => sub { my $m = $_[0]->can('is_subtype_of'); $m->(reverse _swap @_) },
  	q(<=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(_swap @_) },
  	q(>=)      => sub { my $m = $_[0]->can('is_a_type_of');  $m->(reverse _swap @_) },
  	q(eq)      => sub { "$_[0]" eq "$_[1]" },
  	q(cmp)     => sub { $_[2] ? ("$_[1]" cmp "$_[0]") : ("$_[0]" cmp "$_[1]") },
  	fallback   => 1,
  ;
  BEGIN {
  	overload->import(
  		q(~~)    => sub { $_[0]->check($_[1]) },
  		fallback => 1, # 5.10 loses the fallback otherwise
  	) if Type::Tiny::SUPPORT_SMARTMATCH;
  }
  
  sub _overload_coderef
  {
  	my $self = shift;
  	$self->message unless exists $self->{message};
  	
  #	if ($self->has_parent && $self->_is_null_constraint)
  #	{
  #		$self->{_overload_coderef} ||= $self->parent->_overload_coderef;
  #	}
  #	els
  	if (!exists($self->{message}) && exists(&Sub::Quote::quote_sub) && $self->can_be_inlined)
  	{
  		$self->{_overload_coderef} = Sub::Quote::quote_sub($self->inline_assert('$_[0]'))
  			if !$self->{_overload_coderef} || !$self->{_sub_quoted}++;
  	}
  	else
  	{
  		$self->{_overload_coderef} ||= sub { $self->assert_return(@_) };
  	}
  	
  	$self->{_overload_coderef};
  }
  
  our %ALL_TYPES;
  
  my $QFS;
  my $uniq = 1;
  my $subname;
  sub new
  {
  	my $class  = shift;
  	my %params = (@_==1) ? %{$_[0]} : @_;
  	
  	if (exists $params{constraint}
  	and not ref $params{constraint}
  	and not exists $params{constraint_generator}
  	and not exists $params{inline_generator})
  	{
  		my $code = $params{constraint};
  		$params{constraint} = Eval::TypeTiny::eval_closure(
  			source      => sprintf('sub ($) { %s }', $code),
  			description => "anonymous check",
  		);
  		$params{inlined} ||= sub {
  			my ($type) = @_;
  			my $inlined = $_ eq '$_' ? "do { $code }" : "do { local \$_ = $_; $code }";
  			$type->has_parent ? (undef, $inlined) : $inlined;
  		};
  	}
  	
  	if (exists $params{parent})
  	{
  		$params{parent} = ref($params{parent}) =~ /^Type::Tiny\b/
  			? $params{parent}
  			: Types::TypeTiny::to_TypeTiny($params{parent});
  		
  		_croak "Parent must be an instance of %s", __PACKAGE__
  			unless blessed($params{parent}) && $params{parent}->isa(__PACKAGE__);
  	}
  	
  	$params{name} = "__ANON__" unless exists $params{name};
  	$params{uniq} = $uniq++;
  	
  	if ($params{name} ne "__ANON__")
  	{
  		# First try a fast ASCII-only expression, but fall back to Unicode
  		$params{name} =~ /^_{0,2}[A-Z][A-Za-z0-9_]+$/sm
  			or eval q( use 5.008; $params{name} =~ /^_{0,2}\p{Lu}[\p{L}0-9_]+$/sm )
  			or _croak '"%s" is not a valid type name', $params{name};
  	}
  	
  	if (exists $params{coercion} and !ref $params{coercion} and $params{coercion})
  	{
  		$params{parent}->has_coercion
  			or _croak "coercion => 1 requires type to have a direct parent with a coercion";
  		
  		$params{coercion} = $params{parent}->coercion->type_coercion_map;
  	}
  	
  	if (!exists $params{inlined}
  	and exists $params{constraint}
  	and ( !exists $params{parent} or $params{parent}->can_be_inlined )
  	and $QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($params{constraint}) || [] };
  		
  		$params{inlined} = sub {
  			my ($self, $var) = @_;
  			my $code = Sub::Quote::inlinify(
  				$perlstring,
  				$var,
  				$var eq q($_) ? '' : "local \$_ = $var;",
  				1,
  			);
  			$code = sprintf('%s and %s', $self->parent->inline_check($var), $code) if $self->has_parent;
  			return $code;
  		} if $perlstring && !$captures;
  	}
  	
  	my $self = bless \%params, $class;
  	
  	unless ($params{tmp})
  	{
  		my $uniq = $self->{uniq};
  		
  		$ALL_TYPES{$uniq} = $self;
  		weaken( $ALL_TYPES{$uniq} );
  		
  		package # no index
  			Moo::HandleMoose;
  		my $tmp = $self;
  		Scalar::Util::weaken($tmp);
  		$Moo::HandleMoose::TYPE_MAP{$self} = sub { $tmp };
  	}
  	
  	if (ref($params{coercion}) eq q(CODE))
  	{
  		require Types::Standard;
  		my $code = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(Types::Standard::Any(), $code);
  	}
  	elsif (ref($params{coercion}) eq q(ARRAY))
  	{
  		my $arr = delete($params{coercion});
  		$self->{coercion} = $self->_build_coercion;
  		$self->coercion->add_type_coercions(@$arr);
  	}
  	
  	if ($params{my_methods})
  	{
  		$subname =
  			eval { require Sub::Util } ? \&Sub::Util::set_subname :
  			eval { require Sub::Name } ? \&Sub::Name::subname :
  			0
  			if not defined $subname;
  		if ($subname)
  		{
  			$subname->(
  				sprintf("%s::my_%s", $self->qualified_name, $_),
  				$params{my_methods}{$_},
  			) for keys %{$params{my_methods}};
  		}
  	}
  	
  	return $self;
  }
  
  sub DESTROY
  {
  	my $self = shift;
  	delete( $ALL_TYPES{$self->{uniq}} );
  	package # no index
  		Moo::HandleMoose;
  	delete( $Moo::HandleMoose::TYPE_MAP{$self} );
  	return;
  }
  
  sub _clone
  {
  	my $self = shift;
  	my %opts;
  	$opts{$_} = $self->{$_} for qw< name display_name message >;
  	$self->create_child_type(%opts);
  }
  
  our $DD;
  sub _dd
  {
  	@_ = $_ unless @_;
  	my ($value) = @_;
  	
  	goto $DD if ref($DD) eq q(CODE);
  	
  	require B;
  	
  	!defined $value ? 'Undef' :
  	!ref $value     ? sprintf('Value %s', B::perlstring($value)) :
  	do {
  		my $N = 0 + (defined($DD) ? $DD : 72);
  		require Data::Dumper;
  		local $Data::Dumper::Indent   = 0;
  		local $Data::Dumper::Useqq    = 1;
  		local $Data::Dumper::Terse    = 1;
  		local $Data::Dumper::Sortkeys = 1;
  		local $Data::Dumper::Maxdepth = 2;
  		my $str = Data::Dumper::Dumper($value);
  		$str = substr($str, 0, $N - 12).'...'.substr($str, -1, 1)
  			if length($str) >= $N;
  		"Reference $str";
  	}
  }
  
  sub _loose_to_TypeTiny
  {
  	map +(
  		ref($_)
  			? Types::TypeTiny::to_TypeTiny($_)
  			: do { require Type::Utils; Type::Utils::dwim_type($_) }
  	), @_;
  }
  
  sub name                     { $_[0]{name} }
  sub display_name             { $_[0]{display_name}   ||= $_[0]->_build_display_name }
  sub parent                   { $_[0]{parent} }
  sub constraint               { $_[0]{constraint}     ||= $_[0]->_build_constraint }
  sub compiled_check           { $_[0]{compiled_type_constraint} ||= $_[0]->_build_compiled_check }
  sub coercion                 { $_[0]{coercion}       ||= $_[0]->_build_coercion }
  sub message                  { $_[0]{message} }
  sub library                  { $_[0]{library} }
  sub inlined                  { $_[0]{inlined} }
  sub constraint_generator     { $_[0]{constraint_generator} }
  sub inline_generator         { $_[0]{inline_generator} }
  sub name_generator           { $_[0]{name_generator} ||= $_[0]->_build_name_generator }
  sub coercion_generator       { $_[0]{coercion_generator} }
  sub parameters               { $_[0]{parameters} }
  sub moose_type               { $_[0]{moose_type}     ||= $_[0]->_build_moose_type }
  sub mouse_type               { $_[0]{mouse_type}     ||= $_[0]->_build_mouse_type }
  sub deep_explanation         { $_[0]{deep_explanation} }
  sub my_methods               { $_[0]{my_methods}     ||= $_[0]->_build_my_methods }
  
  sub has_parent               { exists $_[0]{parent} }
  sub has_library              { exists $_[0]{library} }
  sub has_coercion             {        $_[0]{coercion} and !!@{ $_[0]{coercion}->type_coercion_map } }
  sub has_inlined              { exists $_[0]{inlined} }
  sub has_constraint_generator { exists $_[0]{constraint_generator} }
  sub has_inline_generator     { exists $_[0]{inline_generator} }
  sub has_coercion_generator   { exists $_[0]{coercion_generator} }
  sub has_parameters           { exists $_[0]{parameters} }
  sub has_message              { defined $_[0]{message} }
  sub has_deep_explanation     { exists $_[0]{deep_explanation} }
  
  sub _default_message         { $_[0]{_default_message} ||= $_[0]->_build_default_message }
  
  sub _assert_coercion
  {
  	my $self = shift;
  	_croak "No coercion for this type constraint"
  		unless $self->has_coercion && @{$self->coercion->type_coercion_map};
  	return $self->coercion;
  }
  
  my $null_constraint = sub { !!1 };
  
  sub _build_display_name
  {
  	shift->name;
  }
  
  sub _build_constraint
  {
  	return $null_constraint;
  }
  
  sub _is_null_constraint
  {
  	shift->constraint == $null_constraint;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion;
  	my $self = shift;
  	my %opts = (type_constraint => $self);
  	$opts{display_name} = "to_$self" unless $self->is_anon;
  	return "Type::Coercion"->new(%opts);
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	return sub { sprintf '%s did not pass type constraint', _dd($_[0]) } if "$self" eq "__ANON__";
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s"', _dd($_[0]), $name };
  }
  
  sub _build_name_generator
  {
  	my $self = shift;
  	return sub {
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	};
  }
  
  sub _build_compiled_check
  {
  	my $self = shift;
  	
  	if ($self->_is_null_constraint and $self->has_parent)
  	{
  		return $self->parent->compiled_check;
  	}
  	
  	return Eval::TypeTiny::eval_closure(
  		source      => sprintf('sub ($) { %s }', $self->inline_check('$_[0]')),
  		description => sprintf("compiled check '%s'", $self),
  	) if $self->can_be_inlined;
  	
  	my @constraints;
  	push @constraints, $self->parent->compiled_check if $self->has_parent;
  	push @constraints, $self->constraint if !$self->_is_null_constraint;
  	return $null_constraint unless @constraints;
  	
  	return sub ($)
  	{
  		local $_ = $_[0];
  		for my $c (@constraints)
  		{
  			return unless $c->(@_);
  		}
  		return !!1;
  	};
  }
  
  sub equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if refaddr($self) == refaddr($other);
  	
  	return !!1 if $self->has_parent  && $self->_is_null_constraint  && $self->parent==$other;
  	return !!1 if $other->has_parent && $other->_is_null_constraint && $other->parent==$self;
  	
  	return !!1 if refaddr($self->compiled_check) == refaddr($other->compiled_check);
  	
  	return $self->qualified_name eq $other->qualified_name
  		if $self->has_library && !$self->is_anon && $other->has_library && !$other->is_anon;
  	
  	return $self->inline_check('$x') eq $other->inline_check('$x')
  		if $self->can_be_inlined && $other->can_be_inlined;
  	
  	return;
  }
  
  sub is_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->equals($other) or $self->parent->is_subtype_of($other);
  }
  
  sub is_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_subtype_of($self);
  }
  
  sub is_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->equals($other) or $self->is_subtype_of($other);
  }
  
  sub strictly_equals
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	$self->{uniq} == $other->{uniq};
  }
  
  sub is_strictly_subtype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  
  #	my $this = $self;
  #	while (my $parent = $this->parent)
  #	{
  #		return !!1 if $parent->strictly_equals($other);
  #		$this = $parent;
  #	}
  #	return;
  
  	return unless $self->has_parent;
  	$self->parent->strictly_equals($other) or $self->parent->is_strictly_subtype_of($other);
  }
  
  sub is_strictly_supertype_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$other->is_strictly_subtype_of($self);
  }
  
  sub is_strictly_a_type_of
  {
  	my ($self, $other) = _loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	$self->strictly_equals($other) or $self->is_strictly_subtype_of($other);
  }
  
  sub qualified_name
  {
  	my $self = shift;
  	(exists $self->{library} and $self->name ne "__ANON__")
  		? "$self->{library}::$self->{name}"
  		: $self->{name};
  }
  
  sub is_anon
  {
  	my $self = shift;
  	$self->name eq "__ANON__";
  }
  
  sub parents
  {
  	my $self = shift;
  	return unless $self->has_parent;
  	return ($self->parent, $self->parent->parents);
  }
  
  sub find_parent
  {
  	my $self = shift;
  	my ($test) = @_;
  	
  	local ($_, $.);
  	my $type  = $self;
  	my $count = 0;
  	while ($type)
  	{
  		if ($test->($_=$type, $.=$count))
  		{
  			return wantarray ? ($type, $count) : $type;
  		}
  		else
  		{
  			$type = $type->parent;
  			$count++;
  		}
  	}
  	
  	return;
  }
  
  sub check
  {
  	my $self = shift;
  	($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  }
  
  sub _strict_check
  {
  	my $self = shift;
  	local $_ = $_[0];
  
  	my @constraints =
  		reverse
  		map  { $_->constraint }
  		grep { not $_->_is_null_constraint }
  		($self, $self->parents);
  	
  	for my $c (@constraints)
  	{
  		return unless $c->(@_);
  	}
  	
  	return !!1;
  }
  
  sub get_message
  {
  	my $self = shift;
  	local $_ = $_[0];
  	$self->has_message
  		? $self->message->(@_)
  		: $self->_default_message->(@_);
  }
  
  sub validate
  {
  	my $self = shift;
  	
  	return undef if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	return $self->get_message(@_);
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	if ($self->has_parent)
  	{
  		my $parent = $self->parent->validate_explain($value, $varname);
  		return [ sprintf('"%s" is a subtype of "%s"', $self, $self->parent), @$parent ] if $parent;
  	}
  	
  	my $message = sprintf(
  		'%s%s',
  		$self->get_message($value),
  		$varname eq q{$_} ? '' : sprintf(' (in %s)', $varname),
  	);
  	
  	if ($self->is_parameterized and $self->parent->has_deep_explanation)
  	{
  		my $deep = $self->parent->deep_explanation->($self, $value, $varname);
  		return [ $message, @$deep ] if $deep;
  	}
  	
  	return [ $message, sprintf('"%s" is defined as: %s', $self, $self->_perlcode) ];
  }
  
  my $b;
  sub _perlcode
  {
  	my $self = shift;
  	
  	return $self->inline_check('$_')
  		if $self->can_be_inlined;
  	
  	$b ||= do {
  		require B::Deparse;
  		my $tmp = "B::Deparse"->new;
  		$tmp->ambient_pragmas(strict => "all", warnings => "all") if $tmp->can('ambient_pragmas');
  		$tmp;
  	};
  	
  	my $code = $b->coderef2text($self->constraint);
  	$code =~ s/\s+/ /g;
  	return "sub $code";
  }
  
  sub assert_valid
  {
  	my $self = shift;
  	
  	return !!1 if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub assert_return
  {
  	my $self = shift;
  	
  	return $_[0] if ($self->{compiled_type_constraint} ||= $self->_build_compiled_check)->(@_);
  	
  	local $_ = $_[0];
  	$self->_failed_check("$self", $_);
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	return $self->parent->can_be_inlined
  		if $self->has_parent && $self->_is_null_constraint;
  	return !!1
  		if !$self->has_parent && $self->_is_null_constraint;
  	return $self->has_inlined;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	_croak 'Cannot inline type constraint check for "%s"', $self
  		unless $self->can_be_inlined;
  	
  	return $self->parent->inline_check(@_)
  		if $self->has_parent && $self->_is_null_constraint;
  	return '(!!1)'
  		if !$self->has_parent && $self->_is_null_constraint;
  	
  	local $_ = $_[0];
  	my @r = $self->inlined->($self, @_);
  	if (@r and not defined $r[0])
  	{
  		_croak 'Inlining type constraint check for "%s" returned undef!', $self
  			unless $self->has_parent;
  		$r[0] = $self->parent->inline_check(@_);
  	}
  	my $r = join " && " => map { /[;{}]/ ? "do { $_ }" : "($_)" } @r;
  	return @r==1 ? $r : "($r)";
  }
  
  sub inline_assert
  {
  	require B;
  	my $self = shift;
  	my $varname = $_[0];
  	my $code = sprintf(
  		q[do { no warnings "void"; %s ? %s : Type::Tiny::_failed_check(%d, %s, %s) };],
  		$self->inline_check(@_),
  		$varname,
  		$self->{uniq},
  		B::perlstring("$self"),
  		$varname,
  	);
  	return $code;
  }
  
  sub _failed_check
  {
  	require Error::TypeTiny::Assertion;
  	
  	my ($self, $name, $value, %attrs) = @_;
  	$self = $ALL_TYPES{$self} unless ref $self;
  	
  	my $exception_class = delete($attrs{exception_class}) || "Error::TypeTiny::Assertion";
  	
  	if ($self)
  	{
  		$exception_class->throw(
  			message => $self->get_message($value),
  			type    => $self,
  			value   => $value,
  			%attrs,
  		);
  	}
  	else
  	{
  		$exception_class->throw(
  			message => sprintf('%s did not pass type constraint "%s"', _dd($value), $name),
  			value   => $value,
  			%attrs,
  		);
  	}
  }
  
  sub coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->coerce(@_);
  }
  
  sub assert_coerce
  {
  	my $self = shift;
  	$self->_assert_coercion->assert_coerce(@_);
  }
  
  sub is_parameterizable
  {
  	shift->has_constraint_generator;
  }
  
  sub is_parameterized
  {
  	shift->has_parameters;
  }
  
  my %param_cache;
  sub parameterize
  {
  	my $self = shift;
  	
  	$self->is_parameterizable
  		or @_ ? _croak("Type '%s' does not accept parameters", "$self") : return($self);
  	
  	@_ = map Types::TypeTiny::to_TypeTiny($_), @_;
  
  	# Generate a key for caching parameterized type constraints,
  	# but only if all the parameters are strings or type constraints.
  	my $key;
  	if ( not grep(ref($_) && !Types::TypeTiny::TypeTiny->check($_), @_) )
  	{
  		require B;
  		$key = join ":", map(Types::TypeTiny::TypeTiny->check($_) ? $_->{uniq} : B::perlstring($_), $self, @_);
  	}
  	
  	return $param_cache{$key} if defined $key && defined $param_cache{$key};
  	
  	local $Type::Tiny::parameterize_type = $self;
  	local $_ = $_[0];
  	my $P;
  	
  	my ($constraint, $compiled) = $self->constraint_generator->(@_);
  	
  	if (Types::TypeTiny::TypeTiny->check($constraint))
  	{
  		$P = $constraint;
  	}
  	else
  	{
  		my %options = (
  			constraint   => $constraint,
  			display_name => $self->name_generator->($self, @_),
  			parameters   => [@_],
  		);
  		$options{compiled_type_constraint} = $compiled
  			if $compiled;
  		$options{inlined} = $self->inline_generator->(@_)
  			if $self->has_inline_generator;
  		exists $options{$_} && !defined $options{$_} && delete $options{$_}
  			for keys %options;
  		
  		$P = $self->create_child_type(%options);
  		
  		my $coercion;
  		$coercion = $self->coercion_generator->($self, $P, @_)
  			if $self->has_coercion_generator;
  		$P->coercion->add_type_coercions( @{$coercion->type_coercion_map} )
  			if $coercion;
  	}
  	
  	if (defined $key)
  	{
  		$param_cache{$key} = $P;
  		weaken($param_cache{$key});
  	}
  	
  	$P->coercion->freeze;
  	
  	return $P;
  }
  
  sub child_type_class
  {
  	__PACKAGE__;
  }
  
  sub create_child_type
  {
  	my $self = shift;
  	return $self->child_type_class->new(parent => $self, @_);
  }
  
  sub complementary_type
  {
  	my $self = shift;
  	my $r    = ($self->{complementary_type} ||= $self->_build_complementary_type);
  	weaken($self->{complementary_type}) unless isweak($self->{complementary_type});
  	return $r;
  }
  
  sub _build_complementary_type
  {
  	my $self = shift;
  	my %opts = (
  		constraint   => sub { not $self->check($_) },
  		display_name => sprintf("~%s", $self),
  	);
  	$opts{display_name} =~ s/^\~{2}//;
  	$opts{inlined} = sub { shift; "not(".$self->inline_check(@_).")" }
  		if $self->can_be_inlined;
  	return "Type::Tiny"->new(%opts);
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	require Moose::Meta::TypeConstraint;
  	return "Moose::Meta::TypeConstraint"->new(%opts);
  }
  
  sub _build_moose_type
  {
  	my $self = shift;
  	
  	my $r;
  	if ($self->{_is_core})
  	{
  		require Moose::Util::TypeConstraints;
  		$r = Moose::Util::TypeConstraints::find_type_constraint($self->name);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		Scalar::Util::weaken($r->{"Types::TypeTiny::to_TypeTiny"});
  	}
  	else
  	{
  		my $wrapped_inlined = sub {
  			shift;
  			$self->inline_check(@_);
  		};
  		
  		my %opts;
  		$opts{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  		$opts{parent}     = $self->parent->moose_type if $self->has_parent;
  		$opts{constraint} = $self->constraint         unless $self->_is_null_constraint;
  		$opts{message}    = $self->message            if $self->has_message;
  		$opts{inlined}    = $wrapped_inlined          if $self->has_inlined;
  		
  		$r = $self->_instantiate_moose_type(%opts);
  		$r->{"Types::TypeTiny::to_TypeTiny"} = $self;
  		$self->{moose_type} = $r;  # prevent recursion
  		$r->coercion($self->coercion->moose_coercion) if $self->has_coercion;
  	}
  		
  	return $r;
  }
  
  sub _build_mouse_type
  {
  	my $self = shift;
  	
  	my %options;
  	$options{name}       = $self->qualified_name     if $self->has_library && !$self->is_anon;
  	$options{parent}     = $self->parent->mouse_type if $self->has_parent;
  	$options{constraint} = $self->constraint         unless $self->_is_null_constraint;
  	$options{message}    = $self->message            if $self->has_message;
  		
  	require Mouse::Meta::TypeConstraint;
  	my $r = "Mouse::Meta::TypeConstraint"->new(%options);
  	
  	$self->{mouse_type} = $r;  # prevent recursion
  	$r->_add_type_coercions(
  		$self->coercion->freeze->_codelike_type_coercion_map('mouse_type')
  	) if $self->has_coercion;
  	
  	return $r;
  }
  
  sub _process_coercion_list
  {
  	my $self = shift;
  	
  	my @pairs;
  	while (@_)
  	{
  		my $next = shift;
  		if (blessed($next) and $next->isa('Type::Coercion') and $next->is_parameterized)
  		{
  			push @pairs => (
  				@{ $next->_reparameterize($self)->type_coercion_map }
  			);
  		}
  		elsif (blessed($next) and $next->can('type_coercion_map'))
  		{
  			push @pairs => (
  				@{ $next->type_coercion_map },
  			);
  		}
  		elsif (ref($next) eq q(ARRAY))
  		{
  			unshift @_, @$next;
  		}
  		else
  		{
  			push @pairs => (
  				Types::TypeTiny::to_TypeTiny($next),
  				shift,
  			);
  		}
  	}
  	
  	return @pairs;
  }
  
  sub plus_coercions
  {
  	my $self = shift;
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		$self->_process_coercion_list(@_),
  		@{$self->coercion->type_coercion_map},
  	);
  	$new->coercion->freeze;
  	return $new;
  }
  
  sub plus_fallback_coercions
  {
  	my $self = shift;
  	
  	my $new = $self->_clone;
  	$new->coercion->add_type_coercions(
  		@{$self->coercion->type_coercion_map},
  		$self->_process_coercion_list(@_),
  	);
  	$new->coercion->freeze;
  	return $new;
  }
  
  sub minus_coercions
  {
  	my $self = shift;
  	
  	my $new = $self->_clone;
  	my @not = grep Types::TypeTiny::TypeTiny->check($_), $self->_process_coercion_list($new, @_);
  	
  	my @keep;
  	my $c = $self->coercion->type_coercion_map;
  	for (my $i = 0; $i <= $#$c; $i += 2)
  	{
  		my $keep_this = 1;
  		NOT: for my $n (@not)
  		{
  			if ($c->[$i] == $n)
  			{
  				$keep_this = 0;
  				last NOT;
  			}
  		}
  		
  		push @keep, $c->[$i], $c->[$i+1] if $keep_this;
  	}
  	
  	$new->coercion->add_type_coercions(@keep);
  	$new->coercion->freeze;
  	return $new;
  }
  
  sub no_coercions
  {
  	my $new = shift->_clone;
  	$new->coercion->freeze;
  	$new;
  }
  
  sub coercibles
  {
  	my $self = shift;
  	$self->has_coercion ? $self->coercion->_source_type_union : $self;
  }
  
  sub isa
  {
  	my $self = shift;
  	
  	if ($INC{"Moose.pm"} and ref($self) and $_[0] =~ /^(?:Class::MOP|MooseX?::Meta)::(.+)$/)
  	{
  		my $meta = $1;
  		
  		return !!1                             if $meta eq 'TypeConstraint';
  		return $self->is_parameterized         if $meta eq 'TypeConstraint::Parameterized';
  		return $self->is_parameterizable       if $meta eq 'TypeConstraint::Parameterizable';
  		return $self->isa('Type::Tiny::Union') if $meta eq 'TypeConstraint::Union';
  		
  		my $inflate = $self->moose_type;
  		return $inflate->isa(@_);
  	}
  	
  	if ($INC{"Mouse.pm"} and ref($self) and $_[0] eq 'Mouse::Meta::TypeConstraint')
  	{
  		return !!1;
  	}
  	
  	$self->SUPER::isa(@_);
  }
  
  sub _build_my_methods
  {
  	return {};
  }
  
  sub _lookup_my_method
  {
  	my $self = shift;
  	my ($name) = @_;
  	
  	if ($self->my_methods->{$name})
  	{
  		return $self->my_methods->{$name};
  	}
  	
  	if ($self->has_parent)
  	{
  		return $self->parent->_lookup_my_method(@_);
  	}
  	
  	return;
  }
  
  sub can
  {
  	my $self = shift;
  	
  	return !!0 if $_[0] eq 'type_parameter' && blessed($_[0]) && $_[0]->has_parameters;
  	
  	my $can = $self->SUPER::can(@_);
  	return $can if $can;
  	
  	if (ref($self))
  	{
  		if ($INC{"Moose.pm"})
  		{
  			my $method = $self->moose_type->can(@_);
  			return sub { shift->moose_type->$method(@_) } if $method;
  		}
  		if ($_[0] =~ /\Amy_(.+)\z/)
  		{
  			my $method = $self->_lookup_my_method($1);
  			return $method if $method;
  		}
  	}
  	
  	return;
  }
  
  sub AUTOLOAD
  {
  	my $self = shift;
  	my ($m) = (our $AUTOLOAD =~ /::(\w+)$/);
  	return if $m eq 'DESTROY';
  	
  	if (ref($self))
  	{
  		if ($INC{"Moose.pm"})
  		{
  			my $method = $self->moose_type->can($m);
  			return $self->moose_type->$method(@_) if $method;
  		}
  		if ($m =~ /\Amy_(.+)\z/)
  		{
  			my $method = $self->_lookup_my_method($1);
  			return $self->$method(@_) if $method;
  		}
  	}
  	
  	_croak q[Can't locate object method "%s" via package "%s"], $m, ref($self)||$self;
  }
  
  sub DOES
  {
  	my $self = shift;
  	
  	return !!1 if  ref($self) && $_[0] =~ m{^ Type::API::Constraint (?: ::Coercible | ::Inlinable )? $}x;
  	return !!1 if !ref($self) && $_[0] eq 'Type::API::Constraint::Constructor';
  	
  	"UNIVERSAL"->can("DOES") ? $self->SUPER::DOES(@_) : $self->isa(@_);
  }
  
  sub _has_xsub
  {
  	require B;
  	!!B::svref_2object( shift->compiled_check )->XSUB;
  }
  
  sub of                         { shift->parameterize(@_) }
  sub where                      { shift->create_child_type(constraint => @_) }
  
  # fill out Moose-compatible API
  sub inline_environment         { +{} }
  sub _inline_check              { shift->inline_check(@_) }
  sub _compiled_type_constraint  { shift->compiled_check(@_) }
  sub meta                       { _croak("Not really a Moose::Meta::TypeConstraint. Sorry!") }
  sub compile_type_constraint    { shift->compiled_check }
  sub _actually_compile_type_constraint   { shift->_build_compiled_check }
  sub hand_optimized_type_constraint      { shift->{hand_optimized_type_constraint} }
  sub has_hand_optimized_type_constraint  { exists(shift->{hand_optimized_type_constraint}) }
  sub type_parameter             { (shift->parameters || [])->[0] }
  
  # some stuff for Mouse-compatible API
  sub __is_parameterized         { shift->is_parameterized(@_) }
  sub _add_type_coercions        { shift->coercion->add_type_coercions(@_) };
  sub _as_string                 { shift->qualified_name(@_) }
  sub _compiled_type_coercion    { shift->coercion->compiled_coercion(@_) };
  sub _identity                  { refaddr(shift) };
  sub _unite                     { require Type::Tiny::Union; "Type::Tiny::Union"->new(type_constraints => \@_) };
  
  # Hooks for Type::Tie
  sub TIESCALAR  { require Type::Tie; unshift @_, 'Type::Tie::SCALAR'; goto \&Type::Tie::SCALAR::TIESCALAR };
  sub TIEARRAY   { require Type::Tie; unshift @_, 'Type::Tie::ARRAY';  goto \&Type::Tie::ARRAY::TIEARRAY };
  sub TIEHASH    { require Type::Tie; unshift @_, 'Type::Tie::HASH';   goto \&Type::Tie::HASH::TIEHASH };
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords Moo(se)-compatible MooseX MouseX MooX Moose-compat invocant
  
  =head1 NAME
  
  Type::Tiny - tiny, yet Moo(se)-compatible type constraint
  
  =head1 SYNOPSIS
  
     use Scalar::Util qw(looks_like_number);
     use Type::Tiny;
     
     my $NUM = "Type::Tiny"->new(
        name       => "Number",
        constraint => sub { looks_like_number($_) },
        message    => sub { "$_ ain't a number" },
     );
     
     package Ermintrude {
        use Moo;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Bullwinkle {
        use Moose;
        has favourite_number => (is => "ro", isa => $NUM);
     }
     
     package Maisy {
        use Mouse;
        has favourite_number => (is => "ro", isa => $NUM);
     }
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> is a tiny class for creating Moose-like type constraint
  objects which are compatible with Moo, Moose and Mouse.
  
  Maybe now we won't need to have separate MooseX, MouseX and MooX versions
  of everything? We can but hope...
  
  This documents the internals of L<Type::Tiny>. L<Type::Tiny::Manual> is
  a better starting place if you're new.
  
  =head2 Constructor
  
  =over
  
  =item C<< new(%attributes) >>
  
  Moose-style constructor function.
  
  =back
  
  =head2 Attributes
  
  Attributes are named values that may be passed to the constructor. For
  each attribute, there is a corresponding reader method. For example:
  
     my $type = Type::Tiny->new( name => "Foo" );
     print $type->name, "\n";   # says "Foo"
  
  =head3 Important attributes
  
  These are the attributes you are likely to be most interested in
  providing when creating your own type constraints, and most interested
  in reading when dealing with type constraint objects.
  
  =over
  
  =item C<< constraint >>
  
  Coderef to validate a value (C<< $_ >>) against the type constraint.
  The coderef will not be called unless the value is known to pass any
  parent type constraint (see C<parent> below).
  
  Alternatively, a string of Perl code checking C<< $_ >> can be passed
  as a parameter to the constructor, and will be converted to a coderef.
  
  Defaults to C<< sub { 1 } >> - i.e. a coderef that passes all values.
  
  =item C<< parent >>
  
  Optional attribute; parent type constraint. For example, an "Integer"
  type constraint might have a parent "Number".
  
  If provided, must be a Type::Tiny object.
  
  =item C<< inlined >>
  
  A coderef which returns a string of Perl code suitable for inlining this
  type. Optional.
  
  If C<constraint> (above) is a coderef generated via L<Sub::Quote>, then
  Type::Tiny I<may> be able to automatically generate C<inlined> for you.
  If C<constraint> (above) is a string, it will be able to.
  
  =item C<< name >>
  
  The name of the type constraint. These need to conform to certain naming
  rules (they must begin with an uppercase letter and continue using only
  letters, digits 0-9 and underscores).
  
  Optional; if not supplied will be an anonymous type constraint.
  
  =item C<< display_name >>
  
  A name to display for the type constraint when stringified. These don't
  have to conform to any naming rules. Optional; a default name will be
  calculated from the C<name>.
  
  =item C<< library >>
  
  The package name of the type library this type is associated with.
  Optional. Informational only: setting this attribute does not install
  the type into the package.
  
  =item C<< message >>
  
  Coderef that returns an error message when C<< $_ >> does not validate
  against the type constraint. Optional (there's a vaguely sensible default.)
  
  =item C<< coercion >>
  
  A L<Type::Coercion> object associated with this type.
  
  Generally speaking this attribute should not be passed to the constructor;
  you should rely on the default lazily-built coercion object.
  
  You may pass C<< coercion => 1 >> to the constructor to inherit coercions
  from the constraint's parent. (This requires the parent constraint to have
  a coercion.)
  
  =item C<< my_methods >>
  
  Experimenal hashref of additional methods that can be called on the type
  constraint object.
  
  =back
  
  =head3 Attributes related to parameterizable and parameterized types
  
  The following additional attributes are used for parameterizable (e.g.
  C<ArrayRef>) and parameterized (e.g. C<< ArrayRef[Int] >>) type
  constraints. Unlike Moose, these aren't handled by separate subclasses.
  
  =over
  
  =item C<< constraint_generator >>
  
  Coderef that generates a new constraint coderef based on parameters.
  Alternatively, the constraint generator can return a fully-formed
  Type::Tiny object, in which case the C<name_generator>, C<inline_generator>,
  and C<coercion_generator> attributes documented below are ignored.
  
  Optional; providing a generator makes this type into a parameterizable
  type constraint.
  
  =item C<< name_generator >>
  
  A coderef which generates a new display_name based on parameters.
  Optional; the default is reasonable.
  
  =item C<< inline_generator >>
  
  A coderef which generates a new inlining coderef based on parameters.
  
  =item C<< coercion_generator >>
  
  A coderef which generates a new L<Type::Coercion> object based on parameters.
  
  =item C<< deep_explanation >>
  
  This API is not finalized. Coderef used by L<Error::TypeTiny::Assertion> to
  peek inside parameterized types and figure out why a value doesn't pass the
  constraint.
  
  =item C<< parameters >>
  
  In parameterized types, returns an arrayref of the parameters.
  
  =back
  
  =head3 Lazy generated attributes
  
  The following attributes should not be usually passed to the constructor;
  unless you're doing something especially unusual, you should rely on the
  default lazily-built return values.
  
  =over
  
  =item C<< compiled_check >>
  
  Coderef to validate a value (C<< $_[0] >>) against the type constraint.
  This coderef is expected to also handle all validation for the parent
  type constraints.
  
  =item C<< complementary_type >>
  
  A complementary type for this type. For example, the complementary type
  for an integer type would be all things that are not integers, including
  floating point numbers, but also alphabetic strings, arrayrefs, filehandles,
  etc.
  
  =item C<< moose_type >>, C<< mouse_type >>
  
  Objects equivalent to this type constraint, but as a
  L<Moose::Meta::TypeConstraint> or L<Mouse::Meta::TypeConstraint>.
  
  It should rarely be necessary to obtain a L<Moose::Meta::TypeConstraint>
  object from L<Type::Tiny> because the L<Type::Tiny> object itself should
  be usable pretty much anywhere a L<Moose::Meta::TypeConstraint> is expected.
  
  =back
  
  =head2 Methods
  
  =head3 Predicate methods
  
  These methods return booleans indicating information about the type
  constraint. They are each tightly associated with a particular attribute.
  (See L</"Attributes">.)
  
  =over
  
  =item C<has_parent>, C<has_library>, C<has_inlined>, C<has_constraint_generator>, C<has_inline_generator>, C<has_coercion_generator>, C<has_parameters>, C<has_message>, C<has_deep_explanation>
  
  Simple Moose-style predicate methods indicating the presence or
  absence of an attribute.
  
  =item C<has_coercion>
  
  Predicate method with a little extra DWIM. Returns false if the coercion is
  a no-op.
  
  =item C<< is_anon >>
  
  Returns true iff the type constraint does not have a C<name>.
  
  =item C<< is_parameterized >>, C<< is_parameterizable >>
  
  Indicates whether a type has been parameterized (e.g. C<< ArrayRef[Int] >>)
  or could potentially be (e.g. C<< ArrayRef >>).
  
  =back
  
  =head3 Validation and coercion
  
  The following methods are used for coercing and validating values
  against a type constraint:
  
  =over
  
  =item C<< check($value) >>
  
  Returns true iff the value passes the type constraint.
  
  =item C<< validate($value) >>
  
  Returns the error message for the value; returns an explicit undef if the
  value passes the type constraint.
  
  =item C<< assert_valid($value) >>
  
  Like C<< check($value) >> but dies if the value does not pass the type
  constraint.
  
  Yes, that's three very similar methods. Blame L<Moose::Meta::TypeConstraint>
  whose API I'm attempting to emulate. :-)
  
  =item C<< assert_return($value) >>
  
  Like C<< assert_valid($value) >> but returns the value if it passes the type
  constraint.
  
  This seems a more useful behaviour than C<< assert_valid($value) >>. I would
  have just changed C<< assert_valid($value) >> to do this, except that there
  are edge cases where it could break Moose compatibility.
  
  =item C<< get_message($value) >>
  
  Returns the error message for the value; even if the value passes the type
  constraint.
  
  =item C<< validate_explain($value, $varname) >>
  
  Like C<validate> but instead of a string error message, returns an arrayref
  of strings explaining the reasoning why the value does not meet the type
  constraint, examining parent types, etc.
  
  The C<< $varname >> is an optional string like C<< '$foo' >> indicating the
  name of the variable being checked.
  
  =item C<< coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type.
  
  =item C<< assert_coerce($value) >>
  
  Attempt to coerce C<< $value >> to this type. Throws an exception if this is
  not possible.
  
  =back
  
  =head3 Child type constraint creation and parameterization
  
  These methods generate new type constraint objects that inherit from the
  constraint they are called upon:
  
  =over
  
  =item C<< create_child_type(%attributes) >>
  
  Construct a new Type::Tiny object with this object as its parent.
  
  =item C<< where($coderef) >>
  
  Shortcut for creating an anonymous child type constraint. Use it like
  C<< HashRef->where(sub { exists($_->{name}) }) >>. That said, you can
  get a similar result using overloaded C<< & >>:
  
     HashRef & sub { exists($_->{name}) }
  
  Like the C<< constraint >> attribute, this will accept a string of Perl
  code:
  
     HashRef->where('exists($_->{name})')
  
  =item C<< child_type_class >>
  
  The class that create_child_type will construct by default.
  
  =item C<< parameterize(@parameters) >>
  
  Creates a new parameterized type; throws an exception if called on a
  non-parameterizable type.
  
  =item C<< of(@parameters) >>
  
  A cute alias for C<parameterize>. Use it like C<< ArrayRef->of(Int) >>.
  
  =item C<< plus_coercions($type1, $code1, ...) >>
  
  Shorthand for creating a new child type constraint with the same coercions
  as this one, but then adding some extra coercions (at a higher priority than
  the existing ones).
  
  =item C<< plus_fallback_coercions($type1, $code1, ...) >>
  
  Like C<plus_coercions>, but added at a lower priority.
  
  =item C<< minus_coercions($type1, ...) >>
  
  Shorthand for creating a new child type constraint with fewer type coercions.
  
  =item C<< no_coercions >>
  
  Shorthand for creating a new child type constraint with no coercions at all.
  
  =back
  
  =head3 Type relationship introspection methods
  
  These methods allow you to determine a type constraint's relationship to
  other type constraints in an organised hierarchy:
  
  =over
  
  =item C<< equals($other) >>, C<< is_subtype_of($other) >>, C<< is_supertype_of($other) >>, C<< is_a_type_of($other) >>
  
  Compare two types. See L<Moose::Meta::TypeConstraint> for what these all mean.
  (OK, Moose doesn't define C<is_supertype_of>, but you get the idea, right?)
  
  Note that these have a slightly DWIM side to them. If you create two
  L<Type::Tiny::Class> objects which test the same class, they're considered
  equal. And:
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_subtype_of( $subtype_of_Num );  # true
  
  =item C<< strictly_equals($other) >>, C<< is_strictly_subtype_of($other) >>, C<< is_strictly_supertype_of($other) >>, C<< is_strictly_a_type_of($other) >>
  
  Stricter versions of the type comparison functions. These only care about
  explicit inheritance via C<parent>.
  
     my $subtype_of_Num = Types::Standard::Num->create_child_type;
     my $subtype_of_Int = Types::Standard::Int->create_child_type;
     $subtype_of_Int->is_strictly_subtype_of( $subtype_of_Num );  # false
  
  =item C<< parents >>
  
  Returns a list of all this type constraint's ancestor constraints. For
  example, if called on the C<Str> type constraint would return the list
  C<< (Value, Defined, Item, Any) >>.
  
  B<< Due to a historical misunderstanding, this differs from the Moose
  implementation of the C<parents> method. In Moose, C<parents> only returns the
  immediate parent type constraints, and because type constraints only have
  one immediate parent, this is effectively an alias for C<parent>. The
  extension module L<MooseX::Meta::TypeConstraint::Intersection> is the only
  place where multiple type constraints are returned; and they are returned
  as an arrayref in violation of the base class' documentation. I'm keeping
  my behaviour as it seems more useful. >>
  
  =item C<< find_parent($coderef) >>
  
  Loops through the parent type constraints I<< including the invocant
  itself >> and returns the nearest ancestor type constraint where the
  coderef evaluates to true. Within the coderef the ancestor currently
  being checked is C<< $_ >>. Returns undef if there is no match.
  
  In list context also returns the number of type constraints which had
  been looped through before the matching constraint was found.
  
  =item C<< coercibles >>
  
  Return a type constraint which is the union of type constraints that can be
  coerced to this one (including this one). If this type constraint has no
  coercions, returns itself.
  
  =item C<< type_parameter >>
  
  In parameterized type constraints, returns the first item on the list of
  parameters; otherwise returns undef. For example:
  
     ( ArrayRef[Int] )->type_parameter;    # returns Int
     ( ArrayRef[Int] )->parent;            # returns ArrayRef
  
  Note that parameterizable type constraints can perfectly legitimately take
  multiple parameters (several off the parameterizable type constraints in
  L<Types::Standard> do). This method only returns the first such parameter.
  L</"Attributes related to parameterizable and parameterized types">
  documents the C<parameters> attribute, which returns an arrayref of all
  the parameters.
  
  =back
  
  =head3 Inlining methods
  
  =for stopwords uated
  
  The following methods are used to generate strings of Perl code which
  may be pasted into stringy C<eval>uated subs to perform type checks:
  
  =over
  
  =item C<< can_be_inlined >>
  
  Returns boolean indicating if this type can be inlined.
  
  =item C<< inline_check($varname) >>
  
  Creates a type constraint check for a particular variable as a string of
  Perl code. For example:
  
     print( Types::Standard::Num->inline_check('$foo') );
  
  prints the following output:
  
     (!ref($foo) && Scalar::Util::looks_like_number($foo))
  
  For Moose-compat, there is an alias C<< _inline_check >> for this method.
  
  =item C<< inline_assert($varname) >>
  
  Much like C<inline_check> but outputs a statement of the form:
  
     die ... unless ...;
  
  Note that if this type has a custom error message, the inlined code will
  I<ignore> this custom message!!
  
  =back
  
  =head3 Other methods
  
  =over
  
  =item C<< qualified_name >>
  
  For non-anonymous type constraints that have a library, returns a qualified
  C<< "MyLib::MyType" >> sort of name. Otherwise, returns the same as C<name>.
  
  =item C<< isa($class) >>, C<< can($method) >>, C<< AUTOLOAD(@args) >>
  
  If Moose is loaded, then the combination of these methods is used to mock
  a Moose::Meta::TypeConstraint.
  
  If Mouse is loaded, then C<isa> mocks Mouse::Meta::TypeConstraint.
  
  =item C<< DOES($role) >>
  
  Overridden to advertise support for various roles.
  
  See also L<Type::API::Constraint>, etc.
  
  =item C<< TIESCALAR >>, C<< TIEARRAY >>, C<< TIEHASH >>
  
  These are provided as hooks that wrap L<Type::Tie>. (Type::Tie is distributed
  separately, and can be used with non-Type::Tiny type constraints too.) They
  allow the following to work:
  
     use Types::Standard qw(Int);
     tie my @list, Int;
     push @list, 123, 456;   # ok
     push @list, "Hello";    # dies
  
  =back
  
  The following methods exist for Moose/Mouse compatibility, but do not do
  anything useful.
  
  =over
  
  =item C<< compile_type_constraint >>
  
  =item C<< hand_optimized_type_constraint >>
  
  =item C<< has_hand_optimized_type_constraint >>
  
  =item C<< inline_environment >>
  
  =item C<< meta >>
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Stringification is overloaded to return the qualified name.
  
  =item *
  
  Boolification is overloaded to always return true.
  
  =item *
  
  Coderefification is overloaded to call C<assert_return>.
  
  =item *
  
  On Perl 5.10.1 and above, smart match is overloaded to call C<check>.
  
  =item *
  
  The C<< == >> operator is overloaded to call C<equals>.
  
  =item *
  
  The C<< < >> and C<< > >> operators are overloaded to call C<is_subtype_of>
  and C<is_supertype_of>.
  
  =item *
  
  The C<< ~ >> operator is overloaded to call C<complementary_type>.
  
  =item *
  
  The C<< | >> operator is overloaded to build a union of two type constraints.
  See L<Type::Tiny::Union>.
  
  =item *
  
  The C<< & >> operator is overloaded to build the intersection of two type
  constraints. See L<Type::Tiny::Intersection>.
  
  =back
  
  Previous versions of Type::Tiny would overload the C<< + >> operator to
  call C<plus_coercions> or C<plus_fallback_coercions> as appropriate.
  Support for this was dropped after 0.040.
  
  =head2 Constants
  
  =over
  
  =item C<< Type::Tiny::SUPPORT_SMARTMATCH >>
  
  Indicates whether the smart match overload is supported on your
  version of Perl.
  
  =back
  
  =head2 Package Variables
  
  =over
  
  =item C<< $Type::Tiny::DD >>
  
  This undef by default but may be set to a coderef that Type::Tiny
  and related modules will use to dump data structures in things like
  error messages.
  
  Otherwise Type::Tiny uses it's own routine to dump data structures.
  C<< $DD >> may then be set to a number to limit the lengths of the
  dumps. (Default limit is 72.)
  
  This is a package variable (rather than get/set class methods) to allow
  for easy localization.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SUPPORT
  
  B<< IRC: >> support is available through in the I<< #moops >> channel
  on L<irc.perl.org|http://www.irc.perl.org/channels.html>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>, L<Type::API>.
  
  L<Type::Library>, L<Type::Utils>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>, L<Type::Tiny::Intersection>.
  
  L<Moose::Meta::TypeConstraint>,
  L<Mouse::Meta::TypeConstraint>.
  
  L<Type::Params>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 THANKS
  
  Thanks to Matt S Trout for advice on L<Moo> integration.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY

$fatpacked{"Type/Tiny/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_CLASS';
  package Type::Tiny::Class;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Type::Tiny::Class::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Class::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	return $proto->class->new(@_) if blessed $proto; # DWIM
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Class type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Class type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Class type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply class name" unless exists $opts{class};
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $xsub = Type::Tiny::XS::get_coderef_for("InstanceOf[".$opts{class}."]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	elsif (Type::Tiny::_USE_MOUSE)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("generate_isa_predicate_for");
  		$opts{compiled_type_constraint} = $maker->($opts{class}) if $maker;
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub class       { $_[0]{class} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self  = shift;
  	my $class = $self->class;
  	return sub { blessed($_) and $_->isa($class) };
  }
  
  sub _build_inlined
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $xsub = Type::Tiny::XS::get_subname_for("InstanceOf[$class]");
  		return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  	}
  	
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and $var->isa(q[$class])};
  	};
  }
  
  sub _build_default_message
  {
  	no warnings 'uninitialized';
  	my $self = shift;
  	my $c = $self->class;
  	return sub { sprintf '%s did not pass type constraint (not isa %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not isa %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Class;
  	return "Moose::Meta::TypeConstraint::Class"->new(%opts, class => $self->class);
  }
  
  sub plus_constructors
  {
  	my $self = shift;
  	
  	unless (@_)
  	{
  		require Types::Standard;
  		push @_, Types::Standard::HashRef(), "new";
  	}
  	
  	require B;
  	require Types::TypeTiny;
  	
  	my $class = B::perlstring($self->class);
  	
  	my @r;
  	while (@_)
  	{
  		my $source = shift;
  		Types::TypeTiny::TypeTiny->check($source)
  			or _croak "Expected type constraint; got $source";
  		
  		my $constructor = shift;
  		Types::TypeTiny::StringLike->check($constructor)
  			or _croak "Expected string; got $constructor";
  		
  		push @r, $source, sprintf('%s->%s($_)', $class, $constructor);
  	}
  	
  	return $self->plus_coercions(\@r);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self  = shift;
  	my $class = $self->class;
  	
  	# Some classes (I'm looking at you, Math::BigFloat) include a class in
  	# their @ISA to inherit methods, but then override isa() to return false,
  	# so that they don't appear to be a subclass.
  	#
  	# In these cases, we don't want to list the parent class as a parent
  	# type constraint.
  	#
  	my @isa = grep $class->isa($_), do { no strict "refs"; no warnings; @{"$class\::ISA"} };
  	
  	if (@isa == 0)
  	{
  		require Types::Standard;
  		return Types::Standard::Object();
  	}
  	
  	if (@isa == 1)
  	{
  		return ref($self)->new(class => $isa[0])
  	}
  	
  	require Type::Tiny::Intersection;
  	"Type::Tiny::Intersection"->new(
  		type_constraints => [ map ref($self)->new(class => $_), @isa ],
  	);
  }
  
  *__get_linear_isa_dfs = eval { require mro }
  	? \&mro::get_linear_isa
  	: sub {
  		no strict 'refs';
  		
  		my $classname = shift;
  		my @lin = ($classname);
  		my %stored;
  		
  		foreach my $parent (@{"$classname\::ISA"})
  		{
  			my $plin = __get_linear_isa_dfs($parent);
  			foreach (@$plin) {
  				next if exists $stored{$_};
  				push(@lin, $_);
  				$stored{$_} = 1;
  			}
  		}
  		
  		return \@lin;
  	};
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	my @isa = @{ __get_linear_isa_dfs(ref $value) };
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	require Type::Utils;
  	return [
  		sprintf('"%s" requires that the reference isa %s', $self, $self->class),
  		sprintf('The reference%s isa %s', $display_var, Type::Utils::english_list(@isa)),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Class - type constraints based on the "isa" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->isa("Some::Class") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Constructor
  
  =over
  
  =item C<new>
  
  When the constructor is called on an I<instance> of Type::Tiny::Class, it
  passes the call through to the constructor of the class for the constraint.
  So for example:
  
     my $type = Type::Tiny::Class->new(class => "Foo::Bar");
     my $obj  = $type->new(hello => "World");
     say ref($obj);   # prints "Foo::Bar"
  
  This little bit of DWIM was borrowed from L<MooseX::Types::TypeDecorator>,
  but Type::Tiny doesn't take the idea quite as far.
  
  =back
  
  =head2 Attributes
  
  =over
  
  =item C<class>
  
  The class for the constraint.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is automatically calculated, and cannot be passed to the constructor.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< plus_constructors($source, $method_name) >>
  
  Much like C<plus_coercions> but adds coercions that go via a constructor.
  (In fact, this is implemented as a wrapper for C<plus_coercions>.)
  
  Example:
  
     package MyApp::Minion;
     
     use Moose; extends "MyApp::Person";
     
     use Types::Standard qw( HashRef Str );
     use Type::Utils qw( class_type );
     
     my $Person = class_type({ class => "MyApp::Person" });
     
     has boss => (
        is     => "ro",
        isa    => $Person->plus_constructors(
           HashRef,     "new",
           Str,         "_new_from_name",
        ),
        coerce => 1,
     );
     
     package main;
     
     MyApp::Minion->new(
        ...,
        boss => "Bob",  ## via MyApp::Person->_new_from_name
     );
     
     MyApp::Minion->new(
        ...,
        boss => { name => "Bob" },  ## via MyApp::Person->new
     );
  
  Because coercing C<HashRef> via constructor is a common desire, if
  you call C<plus_constructors> with no arguments at all, this is the
  default.
  
     $classtype->plus_constructors(Types::Standard::HashRef, "new")
     $classtype->plus_constructors()  ## identical to above
  
  This is handy for Moose/Mouse/Moo-based classes.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Class>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_CLASS

$fatpacked{"Type/Tiny/Duck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_DUCK';
  package Type::Tiny::Duck;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Duck::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Duck::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Duck type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Duck type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Duck type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of methods" unless exists $opts{methods};
  	
  	$opts{methods} = [$opts{methods}] unless ref $opts{methods};
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $methods = join ",", sort(@{$opts{methods}});
  		my $xsub    = Type::Tiny::XS::get_coderef_for("HasMethods[$methods]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	elsif (Type::Tiny::_USE_MOUSE)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("generate_can_predicate_for");
  		$opts{compiled_type_constraint} = $maker->($opts{methods}) if $maker;
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub methods     { $_[0]{methods} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self    = shift;
  	my @methods = @{$self->methods};
  	return sub { blessed($_[0]) and not grep(!$_[0]->can($_), @methods) };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my @methods = @{$self->methods};
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $methods = join ",", sort(@{$self->methods});
  		my $xsub    = Type::Tiny::XS::get_subname_for("HasMethods[$methods]");
  		return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  	}
  	
  	sub {
  		my $var = $_[1];
  		local $" = q{ };
  		# If $var is $_ or $_->{foo} or $foo{$_} or somesuch, then we
  		# can't use it within the grep expression, so we need to save
  		# it into a temporary variable ($tmp).
  		($var =~ /\$_/)
  			? qq{ Scalar::Util::blessed($var) and not do { my \$tmp = $var; grep(!\$tmp->can(\$_), qw/@methods/) } }
  			: qq{ Scalar::Util::blessed($var) and not grep(!$var->can(\$_), qw/@methods/) };
  	};
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	require Moose::Meta::TypeConstraint::DuckType;
  	return "Moose::Meta::TypeConstraint::DuckType"->new(%opts, methods => $self->methods);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the reference can %s',
  			$self,
  			Type::Utils::english_list(map qq["$_"], @{$self->methods}),
  		),
  		map  sprintf('The reference cannot "%s"', $_),
  		grep !$value->can($_),
  		@{$self->methods}
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Duck - type constraints based on the "can" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->can("method") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<methods>
  
  An arrayref of method names.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::DuckType>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_DUCK

$fatpacked{"Type/Tiny/Enum.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ENUM';
  package Type::Tiny::Enum;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Enum::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Enum::VERSION   = '1.002001';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => 'values';
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new
  {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Enum type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Enum type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Enum type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of values" unless exists $opts{values};
  	
  	my %tmp =
  		map { $_ => 1 }
  		@{ ref $opts{values} eq "ARRAY" ? $opts{values} : [$opts{values}] };
  	$opts{values} = [sort keys %tmp];
  	
  	if (Type::Tiny::_USE_XS and not grep /[^-\w]/, @{$opts{values}})
  	{
  		my $enum = join ",", @{$opts{values}};
  		my $xsub = Type::Tiny::XS::get_coderef_for("Enum[$enum]");
  		$opts{compiled_type_constraint} = $xsub if $xsub;
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub values      { $_[0]{values} }
  sub constraint  { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	sprintf("Enum[%s]", join q[,], @$self);
  }
  
  sub _build_constraint
  {
  	my $self = shift;
  	
  	my $regexp = join "|", map quotemeta, @$self;
  	return sub { defined and m{\A(?:$regexp)\z} };
  }
  
  sub can_be_inlined
  {
  	!!1;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my $enum = join ",", @{$self->values};
  		my $xsub = Type::Tiny::XS::get_subname_for("Enum[$enum]");
  		return "$xsub\($_[0]\)" if $xsub;
  	}
  	
  	my $regexp = join "|", map quotemeta, @$self;
  	$_[0] eq '$_'
  		? "(defined and !ref and m{\\A(?:$regexp)\\z})"
  		: "(defined($_[0]) and !ref($_[0]) and $_[0] =~ m{\\A(?:$regexp)\\z})";
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	require Moose::Meta::TypeConstraint::Enum;
  	return "Moose::Meta::TypeConstraint::Enum"->new(%opts, values => $self->values);
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Str();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	!defined($value) ? [
  		sprintf(
  			'"%s" requires that the value is defined',
  			$self,
  		),
  	] :
  	@$self < 13 ? [
  		sprintf(
  			'"%s" requires that the value is equal to %s',
  			$self,
  			Type::Utils::english_list(\"or", map B::perlstring($_), @$self),
  		),
  	] :
  	[
  		sprintf(
  			'"%s" requires that the value is one of an enumerated list of strings',
  			$self,
  		),
  	];
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Enum - string enum type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Enum type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<values>
  
  Arrayref of allowable value strings. Non-string values (e.g. objects with
  overloading) will be stringified in the constructor.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Str, and cannot be passed to the
  constructor.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<values>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Enum>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ENUM

$fatpacked{"Type/Tiny/Intersection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_INTERSECTION';
  package Type::Tiny::Intersection;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Intersection::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Intersection::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Intersection type constraints cannot have a parent constraint" if exists $opts{parent};
  	_croak "Intersection type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Intersection type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my @constraints = @{$opts{type_constraints}};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "AllOf[%s]", join(',', @known)
  			);
  			$opts{compiled_type_constraint} = $xsub if $xsub;
  		}
  	}
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[&], @$self;
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) || return for @checks;
  		return !!1;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	
  	if (Type::Tiny::_USE_XS and !exists $self->{xs_sub})
  	{
  		$self->{xs_sub} = undef;
  		
  		my @constraints = @{$self->type_constraints};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
  				sprintf "AllOf[%s]", join(',', @known)
  			);
  		}
  	}
  	
  	if (Type::Tiny::_USE_XS and $self->{xs_sub}) {
  		return "$self->{xs_sub}\($_[0]\)";
  	}
  	
  	sprintf '(%s)', join " and ", map $_->inline_check($_[0]), @$self;
  }
  
  sub has_parent
  {
  	!!@{ $_[0]{type_constraints} };
  }
  
  sub parent
  {
  	$_[0]{type_constraints}[0];
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	for my $type (@$self)
  	{
  		my $deep = $type->validate_explain($value, $varname);
  		return [
  			sprintf(
  				'"%s" requires that the value pass %s',
  				$self,
  				Type::Utils::english_list(map qq["$_"], @$self),
  			),
  			@$deep,
  		] if $deep;
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Intersection - intersection type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Intersection type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the
  intersection is itself an intersection type constraint, this is "exploded"
  into the new intersection.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  (Technically any of the types in the intersection could be treated as a
  parent type; we choose the first arbitrarily.)
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<MooseX::Meta::TypeConstraint::Intersection>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_INTERSECTION

$fatpacked{"Type/Tiny/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_ROLE';
  package Type::Tiny::Role;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Role::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Role::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed weaken >;
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  require Type::Tiny;
  our @ISA = 'Type::Tiny';
  
  my %cache;
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Role type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Role type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Role type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply role name" unless exists $opts{role};
  	
  	return $proto->SUPER::new(%opts);
  }
  
  sub role        { $_[0]{role} }
  sub inlined     { $_[0]{inlined} ||= $_[0]->_build_inlined }
  
  sub has_inlined { !!1 }
  
  sub _build_constraint
  {
  	my $self = shift;
  	my $role = $self->role;
  	return sub { blessed($_) and do { my $method = $_->can('DOES')||$_->can('isa'); $_->$method($role) } };
  }
  
  sub _build_inlined
  {
  	my $self = shift;
  	my $role = $self->role;
  	sub {
  		my $var = $_[1];
  		qq{Scalar::Util::blessed($var) and do { my \$method = $var->can('DOES')||$var->can('isa'); $var->\$method(q[$role]) }};
  	};
  }
  
  sub _build_default_message
  {
  	my $self = shift;
  	my $c = $self->role;
  	return sub { sprintf '%s did not pass type constraint (not DOES %s)', Type::Tiny::_dd($_[0]), $c } if $self->is_anon;
  	my $name = "$self";
  	return sub { sprintf '%s did not pass type constraint "%s" (not DOES %s)', Type::Tiny::_dd($_[0]), $name, $c };
  }
  
  sub has_parent
  {
  	!!1;
  }
  
  sub parent
  {
  	require Types::Standard;
  	Types::Standard::Object();
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	return ["Not a blessed reference"] unless blessed($value);
  	return ["Reference provides no DOES method to check roles"] unless $value->can('DOES');
  	
  	my $display_var = $varname eq q{$_} ? '' : sprintf(' (in %s)', $varname);
  	
  	return [
  		sprintf('"%s" requires that the reference does %s', $self, $self->role),
  		sprintf("The reference%s doesn't %s", $display_var, $self->role),
  	];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Role - type constraints based on the "DOES" method
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Type constraints of the general form C<< { $_->DOES("Some::Role") } >>.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<role>
  
  The role for the constraint.
  
  Note that this package doesn't subscribe to any particular flavour of roles
  (L<Moose::Role>, L<Mouse::Role>, L<Moo::Role>, L<Role::Tiny>, etc). It simply
  trusts the object's C<DOES> method (see L<UNIVERSAL>).
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Parent is always Types::Standard::Object, and cannot be passed to the
  constructor.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  L<Moose::Meta::TypeConstraint::Role>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_ROLE

$fatpacked{"Type/Tiny/Union.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY_UNION';
  package Type::Tiny::Union;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::Union::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::Union::VERSION   = '1.002001';
  }
  
  use Scalar::Util qw< blessed >;
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use overload q[@{}] => sub { $_[0]{type_constraints} ||= [] };
  
  use Type::Tiny ();
  our @ISA = 'Type::Tiny';
  
  sub new {
  	my $proto = shift;
  	
  	my %opts = (@_==1) ? %{$_[0]} : @_;
  	_croak "Union type constraints cannot have a parent constraint passed to the constructor" if exists $opts{parent};
  	_croak "Union type constraints cannot have a constraint coderef passed to the constructor" if exists $opts{constraint};
  	_croak "Union type constraints cannot have a inlining coderef passed to the constructor" if exists $opts{inlined};
  	_croak "Need to supply list of type constraints" unless exists $opts{type_constraints};
  	
  	$opts{type_constraints} = [
  		map { $_->isa(__PACKAGE__) ? @$_ : $_ }
  		map Types::TypeTiny::to_TypeTiny($_),
  		@{ ref $opts{type_constraints} eq "ARRAY" ? $opts{type_constraints} : [$opts{type_constraints}] }
  	];
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my @constraints = @{$opts{type_constraints}};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "AnyOf[%s]", join(',', @known)
  			);
  			$opts{compiled_type_constraint} = $xsub if $xsub;
  		}
  	}
  
  	my $self = $proto->SUPER::new(%opts);
  	$self->coercion if grep $_->has_coercion, @$self;
  	return $self;
  }
  
  sub type_constraints { $_[0]{type_constraints} }
  sub constraint       { $_[0]{constraint} ||= $_[0]->_build_constraint }
  
  sub _build_display_name
  {
  	my $self = shift;
  	join q[|], @$self;
  }
  
  sub _build_coercion
  {
  	require Type::Coercion::Union;
  	my $self = shift;
  	return "Type::Coercion::Union"->new(type_constraint => $self);
  }
  
  sub _build_constraint
  {
  	my @checks = map $_->compiled_check, @{+shift};
  	return sub
  	{
  		my $val = $_;
  		$_->($val) && return !!1 for @checks;
  		return;
  	}
  }
  
  sub can_be_inlined
  {
  	my $self = shift;
  	not grep !$_->can_be_inlined, @$self;
  }
  
  sub inline_check
  {
  	my $self = shift;
  	
  	if (Type::Tiny::_USE_XS and !exists $self->{xs_sub})
  	{
  		$self->{xs_sub} = undef;
  		
  		my @constraints = @{$self->type_constraints};
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			$self->{xs_sub} = Type::Tiny::XS::get_subname_for(
  				sprintf "AnyOf[%s]", join(',', @known)
  			);
  		}
  	}
  	
  	if (Type::Tiny::_USE_XS and $self->{xs_sub}) {
  		return "$self->{xs_sub}\($_[0]\)";
  	}
  	
  	sprintf '(%s)', join " or ", map $_->inline_check($_[0]), @$self;
  }
  
  sub _instantiate_moose_type
  {
  	my $self = shift;
  	my %opts = @_;
  	delete $opts{parent};
  	delete $opts{constraint};
  	delete $opts{inlined};
  	
  	my @tc = map $_->moose_type, @{$self->type_constraints};
  	
  	require Moose::Meta::TypeConstraint::Union;
  	return "Moose::Meta::TypeConstraint::Union"->new(%opts, type_constraints => \@tc);
  }
  
  sub has_parent
  {
  	defined(shift->parent);
  }
  
  sub parent
  {
  	$_[0]{parent} ||= $_[0]->_build_parent;
  }
  
  sub _build_parent
  {
  	my $self = shift;
  	my ($first, @rest) = @$self;
  	
  	for my $parent ($first, $first->parents)
  	{
  		return $parent unless grep !$_->is_a_type_of($parent), @rest;
  	}
  	
  	return;
  }
  
  sub find_type_for
  {
  	my @types = @{+shift};
  	for my $type (@types)
  	{
  		return $type if $type->check(@_);
  	}
  	return;
  }
  
  sub validate_explain
  {
  	my $self = shift;
  	my ($value, $varname) = @_;
  	$varname = '$_' unless defined $varname;
  	
  	return undef if $self->check($value);
  	
  	require Type::Utils;
  	return [
  		sprintf(
  			'"%s" requires that the value pass %s',
  			$self,
  			Type::Utils::english_list(\"or", map qq["$_"], @$self),
  		),
  		map {
  			$_->get_message($value),
  			map("    $_", @{ $_->validate_explain($value) || []}),
  		} @$self
  	];
  }
  
  sub equals
  {
  	my ($self, $other) = Type::Tiny::_loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if $self->SUPER::equals($other);
  	return !!0 unless $other->isa(__PACKAGE__);
  	
  	my @self_constraints  = @{ $self->type_constraints };
  	my @other_constraints = @{ $other->type_constraints };
  	
  	return !!0 unless @self_constraints == @other_constraints;
  	
  	constraint: foreach my $constraint ( @self_constraints ) {
  		for ( my $i = 0; $i < @other_constraints; $i++ ) {
  			if ( $constraint->equals($other_constraints[$i]) ) {
  				splice @other_constraints, $i, 1;
  				next constraint;
  			}
  		}
  	}
  	
  	@other_constraints == 0;
  }
  
  sub is_a_type_of
  {
  	my ($self, $other) = Type::Tiny::_loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if $self->SUPER::is_a_type_of($other);
  	
  	for my $tc (@{ $self->type_constraints }) {
  		return !!0 unless $tc->is_a_type_of($other);
  	}
  	return !!1;
  }
  
  sub is_subtype_of
  {
  	my ($self, $other) = Type::Tiny::_loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if $self->SUPER::is_subtype_of($other);
  	
  	for my $tc (@{ $self->type_constraints }) {
  		return !!0 unless $tc->is_subtype_of($other);
  	}
  	return !!1;
  }
  
  sub is_supertype_of
  {
  	my ($self, $other) = Type::Tiny::_loose_to_TypeTiny(@_);
  	return unless blessed($self)  && $self->isa("Type::Tiny");
  	return unless blessed($other) && $other->isa("Type::Tiny");
  	
  	return !!1 if $self->SUPER::is_supertype_of($other);
  	
  	for my $tc (@{ $self->type_constraints }) {
  		return !!1 if $tc->equals($other);
  		return !!1 if $tc->is_supertype_of($other);
  	}
  	return !!0;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Type::Tiny::Union - union type constraints
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Union type constraints.
  
  This package inherits from L<Type::Tiny>; see that for most documentation.
  Major differences are listed below:
  
  =head2 Attributes
  
  =over
  
  =item C<type_constraints>
  
  Arrayref of type constraints.
  
  When passed to the constructor, if any of the type constraints in the union
  is itself a union type constraint, this is "exploded" into the new union.
  
  =item C<constraint>
  
  Unlike Type::Tiny, you I<cannot> pass a constraint coderef to the constructor.
  Instead rely on the default.
  
  =item C<inlined>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  Instead rely on the default.
  
  =item C<parent>
  
  Unlike Type::Tiny, you I<cannot> pass an inlining coderef to the constructor.
  A parent will instead be automatically calculated.
  
  =item C<coercion>
  
  You probably do not pass this to the constructor. (It's not currently
  disallowed, as there may be a use for it that I haven't thought of.)
  
  The auto-generated default will be a L<Type::Coercion::Union> object.
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<< find_type_for($value) >>
  
  Returns the first individual type constraint in the union which
  C<< $value >> passes.
  
  =back
  
  =head2 Overloading
  
  =over
  
  =item *
  
  Arrayrefification calls C<type_constraints>.
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY_UNION

$fatpacked{"Type/Tiny/_HalfOp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_TINY__HALFOP';
  package Type::Tiny::_HalfOp;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Tiny::_HalfOp::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Tiny::_HalfOp::VERSION   = '1.002001';
  }
  
  use overload ();
  
  sub new {
  	my ($class, $op, $param, $type) = @_;
  	bless {
  		op    => $op,
  		param => $param,
  		type  => $type,
  	}, $class;
  }
  
  sub complete {
  	my ($self, $type) = @_;
  	my $complete_type = $type->parameterize(@{$self->{param}});
  	my $method = overload::Method($complete_type, $self->{op});
  	$complete_type->$method($self->{type});
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords pragmas
  
  =head1 NAME
  
  Type::Tiny::_HalfOp - half-completed overloaded operation
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This is not considered part of Type::Tiny's public API.
  
  It is a class representing a half-completed overloaded operation.
  
  =head2 Constructor
  
  =over
  
  =item C<< new($operation, $param, $type) >>
  
  =back
  
  =head2 Method
  
  =over
  
  =item C<< complete($type) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 AUTHOR
  
  Graham Knop E<lt>haarg@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2014, 2017 by Graham Knop.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_TINY__HALFOP

$fatpacked{"Type/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPE_UTILS';
  package Type::Utils;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Type::Utils::AUTHORITY = 'cpan:TOBYINK';
  	$Type::Utils::VERSION   = '1.002001';
  }
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  use Scalar::Util qw< blessed >;
  use Type::Library;
  use Type::Tiny;
  use Types::TypeTiny qw< TypeTiny to_TypeTiny HashLike StringLike CodeLike >;
  
  our @EXPORT = qw<
  	declare as where message inline_as
  	class_type role_type duck_type union intersection enum
  	coerce from via
  	declare_coercion to_type
  >;
  our @EXPORT_OK = (
  	@EXPORT,
  	qw<
  		extends type subtype
  		match_on_type compile_match_on_type
  		dwim_type english_list
  		classifier
  	>,
  );
  
  require Exporter::Tiny;
  our @ISA = 'Exporter::Tiny';
  
  sub extends
  {
  	_croak "Not a type library" unless caller->isa("Type::Library");
  	my $caller = caller->meta;
  	
  	foreach my $lib (@_)
  	{
  		eval "use $lib; 1" or _croak "Could not load library '$lib': $@";
  		
  		if ($lib->isa("Type::Library") or $lib eq 'Types::TypeTiny')
  		{
  			$caller->add_type( $lib->get_type($_) )
  				for sort $lib->meta->type_names;
  			$caller->add_coercion( $lib->get_coercion($_) )
  				for sort $lib->meta->coercion_names;
  		}
  		elsif ($lib->isa('MooseX::Types::Base'))
  		{
  			require Moose::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $moose = Moose::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($moose);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $moose->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		elsif ($lib->isa('MouseX::Types::Base'))
  		{
  			require Mouse::Util::TypeConstraints;
  			my $types = $lib->type_storage;
  			for my $name (sort keys %$types)
  			{
  				my $mouse = Mouse::Util::TypeConstraints::find_type_constraint($types->{$name});
  				my $tt    = Types::TypeTiny::to_TypeTiny($mouse);
  				$caller->add_type(
  					$tt->create_child_type(library => $caller, name => $name, coercion => $mouse->has_coercion ? 1 : 0)
  				);
  			}
  		}
  		else
  		{
  			_croak("'$lib' is not a type constraint library");
  		}
  	}
  }
  
  sub declare
  {
  	my %opts;
  	if (@_ % 2 == 0)
  	{
  		%opts = @_;
  		if (@_==2 and $_[0]=~ /^_*[A-Z]/ and $_[1] =~ /^[0-9]+$/)
  		{
  			require Carp;
  			Carp::carp("Possible missing comma after 'declare $_[0]'");
  		}
  	}
  	else
  	{
  		(my($name), %opts) = @_;
  		_croak "Cannot provide two names for type" if exists $opts{name};
  		$opts{name} = $name;
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	if (defined $opts{parent})
  	{
  		$opts{parent} = to_TypeTiny($opts{parent});
  		
  		unless (TypeTiny->check($opts{parent}))
  		{
  			$caller->isa("Type::Library")
  				or _croak("Parent type cannot be a %s", ref($opts{parent})||'non-reference scalar');
  			$opts{parent} = $caller->meta->get_type($opts{parent})
  				or _croak("Could not find parent type");
  		}
  	}
  	
  	my $type;
  	if (defined $opts{parent})
  	{
  		$type = delete($opts{parent})->create_child_type(%opts);
  	}
  	else
  	{
  		my $bless = delete($opts{bless}) || "Type::Tiny";
  		eval "require $bless";
  		$type = $bless->new(%opts);
  	}
  	
  	if ($caller->isa("Type::Library"))
  	{
  		$caller->meta->add_type($type) unless $type->is_anon;
  	}
  	
  	return $type;
  }
  
  *subtype = \&declare;
  *type = \&declare;
  
  sub as (@)
  {
  	parent => @_;
  }
  
  sub where (&;@)
  {
  	constraint => @_;
  }
  
  sub message (&;@)
  {
  	message => @_;
  }
  
  sub inline_as (&;@)
  {
  	inlined => @_;
  }
  
  sub class_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ shift or {} };
  	
  	if (defined $name)
  	{
  		$opts{name}  = $name unless exists $opts{name};
  		$opts{class} = $name unless exists $opts{class};
  		
  		$opts{name} =~ s/:://g;
  	}
  	
  	$opts{bless} = "Type::Tiny::Class";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub role_type
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my %opts = %{ shift or {} };
  	
  	if (defined $name)
  	{
  		$opts{name} = $name unless exists $opts{name};
  		$opts{role} = $name unless exists $opts{role};
  		
  		$opts{name} =~ s/:://g;
  	}
  	
  	$opts{bless} = "Type::Tiny::Role";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub duck_type
  {
  	my $name    = ref($_[0]) ? undef : shift;
  	my @methods = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{methods} = \@methods;
  	
  	$opts{bless} = "Type::Tiny::Duck";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub enum
  {
  	my $name   = ref($_[0]) ? undef : shift;
  	my @values = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{values} = \@values;
  	
  	$opts{bless} = "Type::Tiny::Enum";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub union
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Union";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub intersection
  {
  	my $name = ref($_[0]) ? undef : shift;
  	my @tcs  = @{ shift or [] };
  	
  	my %opts;
  	$opts{name} = $name if defined $name;
  	$opts{type_constraints} = \@tcs;
  	
  	$opts{bless} = "Type::Tiny::Intersection";
  	
  	{ no warnings "numeric"; $opts{_caller_level}++ }
  	declare(%opts);
  }
  
  sub declare_coercion
  {
  	my %opts;
  	$opts{name} = shift if !ref($_[0]);
  	
  	while (HashLike->check($_[0]) and not TypeTiny->check($_[0]))
  	{
  		%opts = (%opts, %{+shift});
  	}
  	
  	my $caller = caller($opts{_caller_level} || 0);
  	$opts{library} = $caller;
  	
  	my $bless = delete($opts{bless}) || "Type::Coercion";
  	eval "require $bless";
  	my $c = $bless->new(%opts);
  	
  	my @C;
  	
  	if ($caller->isa("Type::Library"))
  	{
  		my $meta = $caller->meta;
  		$meta->add_coercion($c) unless $c->is_anon;
  		while (@_)
  		{
  			push @C, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @C, shift;
  		}
  	}
  	else
  	{
  		@C = @_;
  	}
  	
  	$c->add_type_coercions(@C);
  	
  	return $c->freeze;
  }
  
  sub coerce
  {
  	if ((scalar caller)->isa("Type::Library"))
  	{
  		my $meta = (scalar caller)->meta;
  		my ($type) = map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  		my @opts;
  		while (@_)
  		{
  			push @opts, map { ref($_) ? to_TypeTiny($_) : $meta->get_type($_)||$_ } shift;
  			push @opts, shift;
  		}
  		return $type->coercion->add_type_coercions(@opts);
  	}
  	
  	my ($type, @opts) = @_;
  	$type = to_TypeTiny($type);
  	return $type->coercion->add_type_coercions(@opts);
  }
  
  sub from (@)
  {
  	return @_;
  }
  
  sub to_type (@)
  {
  	my $type = shift;
  	unless (TypeTiny->check($type))
  	{
  		caller->isa("Type::Library")
  			or _croak "Target type cannot be a string";
  		$type = caller->meta->get_type($type)
  			or _croak "Could not find target type";
  	}
  	return +{ type_constraint => $type }, @_;
  }
  
  sub via (&;@)
  {
  	return @_;
  }
  
  sub match_on_type
  {
  	my $value = shift;
  	
  	while (@_)
  	{
  		my $code;
  		if (@_ == 1)
  		{
  			$code = shift;
  		}
  		else
  		{
  			(my($type), $code) = splice(@_, 0, 2);
  			TypeTiny->($type)->check($value) or next;
  		}
  		
  		if (StringLike->check($code))
  		{
  			local $_ = $value;
  			if (wantarray) {
  				my @r = eval "$code";
  				die $@ if $@;
  				return @r;
  			}
  			if (defined wantarray) {
  				my $r = eval "$code";
  				die $@ if $@;
  				return $r;
  			}
  			eval "$code";
  			die $@ if $@;
  			return;
  		}
  		else
  		{
  			CodeLike->($code);
  			local $_ = $value;
  			return $code->($value);
  		}
  	}
  	
  	_croak("No cases matched for %s", Type::Tiny::_dd($value));
  }
  
  sub compile_match_on_type
  {
  	my @code = 'sub { local $_ = $_[0]; ';
  	my @checks;
  	my @actions;
  	
  	my $els = '';
  	
  	while (@_)
  	{
  		my ($type, $code);
  		if (@_ == 1)
  		{
  			require Types::Standard;
  			($type, $code) = (Types::Standard::Any(), shift);
  		}
  		else
  		{
  			($type, $code) = splice(@_, 0, 2);
  			TypeTiny->($type);
  		}
  		
  		if ($type->can_be_inlined)
  		{
  			push @code, sprintf('%sif (%s)', $els, $type->inline_check('$_'));
  		}
  		else
  		{
  			push @checks, $type;
  			push @code, sprintf('%sif ($checks[%d]->check($_))', $els, $#checks);
  		}
  		
  		$els = 'els';
  		
  		if (StringLike->check($code))
  		{
  			push @code, sprintf('  { %s }', $code);
  		}
  		else
  		{
  			CodeLike->($code);
  			push @actions, $code;
  			push @code, sprintf('  { $actions[%d]->(@_) }', $#actions);
  		}
  	}
  	
  	push @code, 'else', '  { Type::Utils::_croak("No cases matched for %s", Type::Tiny::_dd($_[0])) }';
  	
  	push @code, '}';  # /sub
  	
  	require Eval::TypeTiny;
  	return Eval::TypeTiny::eval_closure(
  		source      => \@code,
  		environment => {
  			'@actions' => \@actions,
  			'@checks'  => \@checks,
  		},
  	);
  }
  
  sub classifier
  {
  	my $i;
  	compile_match_on_type(
  		+(
  			map {
  				my $type = $_->[0];
  				$type => sub { $type };
  			}
  			sort { $b->[1] <=> $a->[1] or $a->[2] <=> $b->[2] }
  			map [$_, scalar(my @parents = $_->parents), ++$i],
  			@_
  		),
  		q[ undef ],
  	);
  }
  
  {
  	package #hide
  	Type::Registry::DWIM;
  	
  	our @ISA = qw(Type::Registry);
  	
  	sub foreign_lookup
  	{
  		my $self = shift;
  		my $r = $self->SUPER::foreign_lookup(@_);
  		return $r if $r;
  		
  		if (my $assume = $self->{"~~assume"}
  		and $_[0] =~ /[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/)
  		{
  			my @methods = ref($assume) ? @$assume : $assume;
  			
  			for my $method (@methods)
  			{
  				$r = $self->$method(@_);
  				return $r if $r;
  			}
  		}
  		
  		return;
  	}
  	
  	sub lookup_via_moose
  	{
  		my $self = shift;
  		
  		if ($INC{'Moose.pm'})
  		{
  			require Moose::Util::TypeConstraints;
  			require Types::TypeTiny;
  			my $r = Moose::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		return;
  	}
  	
  	sub lookup_via_mouse
  	{
  		my $self = shift;
  		
  		if ($INC{'Mouse.pm'})
  		{
  			require Mouse::Util::TypeConstraints;
  			require Types::TypeTiny;
  			my $r = Mouse::Util::TypeConstraints::find_type_constraint($_[0]);
  			return Types::TypeTiny::to_TypeTiny($r) if defined $r;
  		}
  		
  		return;
  	}
  	
  	sub simple_lookup
  	{
  		my $self = shift;
  		my $r;
  		
  		# If the lookup is chained to a class, then the class' own
  		# type registry gets first refusal.
  		#
  		if (defined $self->{"~~chained"})
  		{
  			my $chained = "Type::Registry"->for_class($self->{"~~chained"});
  			$r = eval { $chained->simple_lookup(@_) } unless $self == $chained;
  			return $r if defined $r;
  		}
  		
  		# Fall back to types in Types::Standard.
  		require Types::Standard;
  		return 'Types::Standard'->get_type($_[0]) if 'Types::Standard'->has_type($_[0]);
  		
  		# Only continue any further if we've been called from Type::Parser.
  		return unless $_[1];
  		
  		my $meta;
  		if (defined $self->{"~~chained"})
  		{
  			$meta ||= Moose::Util::find_meta($self->{"~~chained"}) if $INC{'Moose.pm'};
  			$meta ||= Mouse::Util::find_meta($self->{"~~chained"}) if $INC{'Mouse.pm'};
  		}
  		
  		if ($meta and $meta->isa('Class::MOP::Module'))
  		{
  			$r = $self->lookup_via_moose(@_);
  			return $r if $r;
  		}
  		
  		elsif ($meta and $meta->isa('Mouse::Meta::Module'))
  		{
  			$r = $self->lookup_via_mouse(@_);
  			return $r if $r;
  		}
  		
  		return $self->foreign_lookup(@_);
  	}
  }
  
  our $dwimmer;
  sub dwim_type
  {
  	my ($string, %opts) = @_;
  	$opts{for} = caller unless defined $opts{for};
  	
  	$dwimmer ||= do {
  		require Type::Registry;
  		'Type::Registry::DWIM'->new;
  	};
  	
  	local $dwimmer->{'~~chained'} = $opts{for};
  	local $dwimmer->{'~~assume'}  = $opts{fallback} || [
  		qw/ lookup_via_moose lookup_via_mouse /,
  		$opts{does} ? 'make_role_type' : 'make_class_type',
  	];
  	
  	local $@ = undef;
  	my $type;
  	unless (eval { $type = $dwimmer->lookup($string); 1 })
  	{
  		my $e = $@;
  		die($e) unless $e =~ /not a known type constraint/;
  	}
  	
  	$type;
  }
  
  sub english_list
  {
  	my $conjunction = ref($_[0]) eq 'SCALAR' ? ${+shift} : 'and';
  	my @items = sort @_;
  	
  	return $items[0] if @items == 1;
  	return "$items[0] $conjunction $items[1]" if @items == 2;
  	
  	my $tail = pop @items;
  	join(', ', @items, "$conjunction $tail");
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords smush smushed
  
  =head1 NAME
  
  Type::Utils - utility functions to make defining and using type constraints a little easier
  
  =head1 SYNOPSIS
  
     package Types::Mine;
     
     use Type::Library -base;
     use Type::Utils -all;
     
     BEGIN { extends "Types::Standard" };
     
     declare "AllCaps",
        as "Str",
        where { uc($_) eq $_ },
        inline_as { my $varname = $_[1]; "uc($varname) eq $varname" };
     
     coerce "AllCaps",
        from "Str", via { uc($_) };
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This module provides utility functions to make defining and using type
  constraints a little easier. 
  
  =head2 Type declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< declare $name, %options >>
  
  =item C<< declare %options >>
  
  Declare a named or anonymous type constraint. Use C<as> and C<where> to
  specify the parent type (if any) and (possibly) refine its definition.
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
     my $EvenInt = declare as Int, where { $_ % 2 == 0 };
  
  B<< NOTE: >>
  If the caller package inherits from L<Type::Library> then any non-anonymous
  types declared in the package will be automatically installed into the
  library.
  
  Hidden gem: if you're inheriting from a type constraint that includes some
  coercions, you can include C<< coercion => 1 >> in the C<< %options >> hash
  to inherit the coercions.
  
  =item C<< subtype $name, %options >>
  
  =item C<< subtype %options >>
  
  Declare a named or anonymous type constraint which is descended from an
  existing type constraint. Use C<as> and C<where> to specify the parent
  type and refine its definition.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< type $name, %options >>
  
  =item C<< type %options >>
  
  Declare a named or anonymous type constraint which is not descended from
  an existing type constraint. Use C<where> to provide a coderef that
  constrains values.
  
  Actually, you should use C<declare> instead; this is just an alias.
  
  This function is not exported by default.
  
  =item C<< as $parent >>
  
  Used with C<declare> to specify a parent type constraint:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  =item C<< where { BLOCK } >>
  
  Used with C<declare> to provide the constraint coderef:
  
     declare EvenInt, as Int, where { $_ % 2 == 0 };
  
  The coderef operates on C<< $_ >>, which is the value being tested.
  
  =item C<< message { BLOCK } >>
  
  Generate a custom error message when a value fails validation.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        message {
           Int->validate($_) or "$_ is not divisible by two";
        };
  
  Without a custom message, the messages generated by Type::Tiny are along
  the lines of I<< Value "33" did not pass type constraint "EvenInt" >>,
  which is usually reasonable.
  
  =item C<< inline_as { BLOCK } >>
  
  Generate a string of Perl code that can be used to inline the type check into
  other functions. If your type check is being used within a L<Moose> or L<Moo>
  constructor or accessor methods, or used by L<Type::Params>, this can lead to
  significant performance improvements.
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           my ($constraint, $varname) = @_;
           my $perlcode = 
              $constraint->parent->inline_check($varname)
              . "&& ($varname % 2 == 0)";
           return $perlcode;
        };
     
     warn EvenInt->inline_check('$xxx');  # demonstration
  
  B<Experimental:> your C<inline_as> block can return a list, in which case
  these will be smushed together with "&&". The first item on the list may
  be undef, in which case the undef will be replaced by the inlined parent
  type constraint. (And will throw an exception if there is no parent.)
  
     declare EvenInt,
        as Int,
        where { $_ % 2 == 0 },
        inline_as {
           return (undef, "($_ % 2 == 0)");
        };
  
  Returning a list like this is considered experimental, is not tested very
  much, and I offer no guarantees that it will necessarily work with
  Moose/Mouse/Moo.
  
  =item C<< class_type $name, { class => $package, %options } >>
  
  =item C<< class_type { class => $package, %options } >>
  
  =item C<< class_type $name >>
  
  Shortcut for declaring a L<Type::Tiny::Class> type constraint.
  
  If C<< $package >> is omitted, is assumed to be the same as C<< $name >>.
  If C<< $name >> contains "::" (which would be an invalid name as far as
  L<Type::Tiny> is concerned), this will be removed.
  
  So for example, C<< class_type("Foo::Bar") >> declares a L<Type::Tiny::Class>
  type constraint named "FooBar" which constrains values to objects blessed
  into the "Foo::Bar" package.
  
  =item C<< role_type $name, { role => $package, %options } >>
  
  =item C<< role_type { role => $package, %options } >>
  
  =item C<< role_type $name >>
  
  Shortcut for declaring a L<Type::Tiny::Role> type constraint.
  
  If C<< $package >> is omitted, is assumed to be the same as C<< $name >>.
  If C<< $name >> contains "::" (which would be an invalid name as far as
  L<Type::Tiny> is concerned), this will be removed.
  
  =item C<< duck_type $name, \@methods >>
  
  =item C<< duck_type \@methods >>
  
  Shortcut for declaring a L<Type::Tiny::Duck> type constraint.
  
  =item C<< union $name, \@constraints >>
  
  =item C<< union \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Union> type constraint.
  
  =item C<< enum $name, \@values >>
  
  =item C<< enum \@values >>
  
  Shortcut for declaring a L<Type::Tiny::Enum> type constraint.
  
  =item C<< intersection $name, \@constraints >>
  
  =item C<< intersection \@constraints >>
  
  Shortcut for declaring a L<Type::Tiny::Intersection> type constraint.
  
  =back
  
  =head2 Coercion declaration functions
  
  Many of the following are similar to the similarly named functions described
  in L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< coerce $target, @coercions >>
  
  Add coercions to the target type constraint. The list of coercions is a
  list of type constraint, conversion code pairs. Conversion code can be
  either a string of Perl code or a coderef; in either case the value to
  be converted is C<< $_ >>.
  
  =item C<< from $source >>
  
  Sugar to specify a type constraint in a list of coercions:
  
     coerce EvenInt, from Int, via { $_ * 2 };  # As a coderef...
     coerce EvenInt, from Int, q { $_ * 2 };    # or as a string!
  
  =item C<< via { BLOCK } >>
  
  Sugar to specify a coderef in a list of coercions.
  
  =item C<< declare_coercion $name, \%opts, $type1, $code1, ... >>
  
  =item C<< declare_coercion \%opts, $type1, $code1, ... >>
  
  Declares a coercion that is not explicitly attached to any type in the
  library. For example:
  
     declare_coercion "ArrayRefFromAny", from "Any", via { [$_] };
  
  This coercion will be exportable from the library as a L<Type::Coercion>
  object, but the ArrayRef type exported by the library won't automatically
  use it.
  
  Coercions declared this way are immutable (frozen).
  
  =item C<< to_type $type >>
  
  Used with C<declare_coercion> to declare the target type constraint for
  a coercion, but still without explicitly attaching the coercion to the
  type constraint:
  
     declare_coercion "ArrayRefFromAny",
        to_type "ArrayRef",
        from "Any", via { [$_] };
  
  You should pretty much always use this when declaring an unattached
  coercion because it's exceedingly useful for a type coercion to know what
  it will coerce to - this allows it to skip coercion when no coercion is
  needed (e.g. avoiding coercing C<< [] >> to C<< [ [] ] >>) and allows
  C<assert_coerce> to work properly.
  
  =back
  
  =head2 Type library management
  
  =over
  
  =item C<< extends @libraries >>
  
  Indicates that this type library extends other type libraries, importing
  their type constraints.
  
  Should usually be executed in a C<< BEGIN >> block.
  
  This is not exported by default because it's not fun to export it to Moo,
  Moose or Mouse classes! C<< use Type::Utils -all >> can be used to import
  it into your type library.
  
  =back
  
  =head2 Other
  
  =over
  
  =item C<< match_on_type $value => ($type => \&action, ..., \&default?) >>
  
  Something like a C<switch>/C<case> or C<given>/C<when> construct. Dispatches
  along different code paths depending on the type of the incoming value.
  Example blatantly stolen from the Moose documentation:
  
     sub to_json
     {
        my $value = shift;
        
        return match_on_type $value => (
           HashRef() => sub {
              my $hash = shift;
              '{ '
                 . (
                 join ", " =>
                 map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
                 sort keys %$hash
              ) . ' }';
           },
           ArrayRef() => sub {
              my $array = shift;
              '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
           },
           Num()   => q {$_},
           Str()   => q { '"' . $_ . '"' },
           Undef() => q {'null'},
           => sub { die "$_ is not acceptable json type" },
        );
     }
  
  Note that unlike Moose, code can be specified as a string instead of a
  coderef. (e.g. for C<Num>, C<Str> and C<Undef> above.)
  
  For improved performance, try C<compile_match_on_type>.
  
  This function is not exported by default.
  
  =item C<< my $coderef = compile_match_on_type($type => \&action, ..., \&default?) >>
  
  Compile a C<match_on_type> block into a coderef. The following JSON
  converter is about two orders of magnitude faster than the previous
  example:
  
     sub to_json;
     *to_json = compile_match_on_type(
        HashRef() => sub {
           my $hash = shift;
           '{ '
              . (
              join ", " =>
              map { '"' . $_ . '" : ' . to_json( $hash->{$_} ) }
              sort keys %$hash
           ) . ' }';
        },
        ArrayRef() => sub {
           my $array = shift;
           '[ '.( join ", " => map { to_json($_) } @$array ).' ]';
        },
        Num()   => q {$_},
        Str()   => q { '"' . $_ . '"' },
        Undef() => q {'null'},
        => sub { die "$_ is not acceptable json type" },
     );
  
  Remember to store the coderef somewhere fairly permanent so that you
  don't compile it over and over. C<state> variables (in Perl >= 5.10)
  are good for this. (Same sort of idea as L<Type::Params>.)
  
  This function is not exported by default.
  
  =item C<< my $coderef = classifier(@types) >>
  
  Returns a coderef that can be used to classify values according to their
  type constraint. The coderef, when passed a value, returns a type
  constraint which the value satisfies.
  
     use feature qw( say );
     use Type::Utils qw( classifier );
     use Types::Standard qw( Int Num Str Any );
     
     my $classifier = classifier(Str, Int, Num, Any);
     
     say $classifier->( "42"  )->name;   # Int
     say $classifier->( "4.2" )->name;   # Num
     say $classifier->( []    )->name;   # Any
  
  Note that, for example, "42" satisfies Int, but it would satisfy the
  type constraints Num, Str, and Any as well. In this case, the
  classifier has picked the most specific type constraint that "42"
  satisfies.
  
  If no type constraint is satisfied by the value, then the classifier
  will return undef.
  
  =item C<< dwim_type($string, %options) >>
  
  Given a string like "ArrayRef[Int|CodeRef]", turns it into a type constraint
  object, hopefully doing what you mean.
  
  It uses the syntax of L<Type::Parser>. Firstly the L<Type::Registry>
  for the caller package is consulted; if that doesn't have a match,
  L<Types::Standard> is consulted for standard type constraint names.
  
  If none of the above yields a type constraint, and the caller class
  is a Moose-based class, then C<dwim_type> attempts to look the type
  constraint up in the Moose type registry. If it's a Mouse-based class,
  then the Mouse type registry is used instead.
  
  If no type constraint can be found via these normal methods, several
  fallbacks are available:
  
  =over
  
  =item C<lookup_via_moose>
  
  Lookup in Moose registry even if caller is non-Moose class.
  
  =item C<lookup_via_mouse>
  
  Lookup in Mouse registry even if caller is non-Mouse class.
  
  =item C<make_class_type>
  
  Create a new Type::Tiny::Class constraint.
  
  =item C<make_role_type>
  
  Create a new Type::Tiny::Role constraint.
  
  =back
  
  You can alter which should be attempted, and in which order, by passing
  an option to C<dwim_type>:
  
     my $type = Type::Utils::dwim_type(
        "ArrayRef[Int]",
        fallback      => [ "lookup_via_mouse" , "make_role_type" ],
     );
  
  For historical reasons, by default the fallbacks attempted are:
  
     lookup_via_moose, lookup_via_mouse, make_class_type
  
  You may set C<fallback> to an empty arrayref to avoid using any of
  these fallbacks.
  
  You can specify an alternative for the caller using the C<for> option.
  
     my $type = dwim_type("ArrayRef", for => "Moose::Object");
  
  While it's probably better overall to use the proper L<Type::Registry>
  interface for resolving type constraint strings, this function often does
  what you want.
  
  It should never die if it fails to find a type constraint (but may die
  if the type constraint string is syntactically malformed), preferring to
  return undef.
  
  This function is not exported by default.
  
  =item C<< english_list(\$conjunction, @items) >>
  
  Joins the items with commas, placing a conjunction before the final item.
  The conjunction is optional, defaulting to "and".
  
     english_list(qw/foo bar baz/);       # "foo, bar, and baz"
     english_list(\"or", qw/quux quuux/); # "quux or quuux"
  
  This function is not exported by default.
  
  =back
  
  =head1 EXPORT
  
  By default, all of the functions documented above are exported, except
  C<subtype> and C<type> (prefer C<declare> instead), C<extends>, C<dwim_type>,
  C<match_on_type>/C<compile_match_on_type>, C<classifier>, and
  C<english_list>.
  
  This module uses L<Exporter::Tiny>; see the documentation of that module
  for tips and tricks importing from Type::Utils.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Types::Standard>, L<Type::Coercion>.
  
  L<Type::Tiny::Class>, L<Type::Tiny::Role>, L<Type::Tiny::Duck>,
  L<Type::Tiny::Enum>, L<Type::Tiny::Union>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPE_UTILS

$fatpacked{"Types/Common/Numeric.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_NUMERIC';
  package Types::Common::Numeric;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::Numeric::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::Numeric::VERSION   = '1.002001';
  }
  
  use Type::Library -base, -declare => qw(
  	PositiveNum PositiveOrZeroNum
  	PositiveInt PositiveOrZeroInt
  	NegativeNum NegativeOrZeroNum
  	NegativeInt NegativeOrZeroInt
  	SingleDigit
  );
  
  use Type::Tiny ();
  use Types::Standard qw( Num Int );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => 'PositiveNum',
  	parent     => Num,
  	constraint => sub { $_ > 0 },
  	inlined    => sub { undef, qq($_ > 0) },
  	message    => sub { "Must be a positive number" },
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub { undef, qq($_ >= 0) },
  	message    => sub { "Must be a number greater than or equal to zero" },
  );
  
  my ($pos_int, $posz_int);
  if (Type::Tiny::_USE_XS) {
  	$pos_int  = Type::Tiny::XS::get_coderef_for('PositiveInt');
  	$posz_int = Type::Tiny::XS::get_coderef_for('PositiveOrZeroInt');
  }
  
  $meta->add_type(
  	name       => 'PositiveInt',
  	parent     => Int,
  	constraint => sub { $_ > 0 },
  	inlined    => sub {
  		if ($pos_int) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq($_ > 0);
  	},
  	message    => sub { "Must be a positive integer" },
  	$pos_int ? ( compiled_type_constraint => $pos_int ) : (),
  );
  
  $meta->add_type(
  	name       => 'PositiveOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ >= 0 },
  	inlined    => sub {
  		if ($posz_int) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq($_ >= 0);
  	},
  	message    => sub { "Must be an integer greater than or equal to zero" },
  	$posz_int ? ( compiled_type_constraint => $posz_int ) : (),
  );
  
  $meta->add_type(
  	name       => 'NegativeNum',
  	parent     => Num,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative number" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroNum',
  	parent     => Num,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be a number less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'NegativeInt',
  	parent     => Int,
  	constraint => sub { $_ < 0 },
  	inlined    => sub { undef, qq($_ < 0) },
  	message    => sub { "Must be a negative integer" },
  );
  
  $meta->add_type(
  	name       => 'NegativeOrZeroInt',
  	parent     => Int,
  	constraint => sub { $_ <= 0 },
  	inlined    => sub { undef, qq($_ <= 0) },
  	message    => sub { "Must be an integer less than or equal to zero" },
  );
  
  $meta->add_type(
  	name       => 'SingleDigit',
  	parent     => Int,
  	constraint => sub { $_ >= -9 and $_ <= 9 },
  	inlined    => sub { undef, qq($_ >= -9), qq($_ <= 9) },
  	message    => sub { "Must be a single digit" },
  );
  
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::Numeric - drop-in replacement for MooseX::Types::Common::Numeric
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::Numeric>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::Numeric>.
  
  =over
  
  =item C<PositiveNum>
  
  =item C<PositiveOrZeroNum>
  
  =item C<PositiveInt>
  
  =item C<PositiveOrZeroInt>
  
  =item C<NegativeNum>
  
  =item C<NegativeOrZeroNum>
  
  =item C<NegativeInt>
  
  =item C<NegativeOrZeroInt>
  
  =item C<SingleDigit>
  
  =back
  
  C<SingleDigit> interestingly accepts the numbers -9 to -1; not
  just 0 to 9. 
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::String>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_NUMERIC

$fatpacked{"Types/Common/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_COMMON_STRING';
  package Types::Common::String;
  
  use 5.006001;
  use strict;
  use warnings;
  use utf8;
  
  BEGIN {
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  }
  
  BEGIN {
  	$Types::Common::String::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Common::String::VERSION   = '1.002001';
  }
  
  use Type::Library -base, -declare => qw(
  	SimpleStr
  	NonEmptySimpleStr
  	NumericCode
  	LowerCaseSimpleStr
  	UpperCaseSimpleStr
  	Password
  	StrongPassword
  	NonEmptyStr
  	LowerCaseStr
  	UpperCaseStr
  );
  
  use Type::Tiny ();
  use Types::Standard qw( Str );
  
  my $meta = __PACKAGE__->meta;
  
  $meta->add_type(
  	name       => SimpleStr,
  	parent     => Str,
  	constraint => sub { length($_) <= 255 and not /\n/ },
  	inlined    => sub { undef, qq(length($_) <= 255), qq($_ !~ /\\n/) },
  	message    => sub { "Must be a single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NonEmptySimpleStr,
  	parent     => SimpleStr,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub { undef, qq(length($_) > 0) },
  	message    => sub { "Must be a non-empty single line of no more than 255 chars" },
  );
  
  $meta->add_type(
  	name       => NumericCode,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { /^[0-9]+$/ },
  	inlined    => sub { SimpleStr->inline_check($_), qq($_ =~ m/^[0-9]+\$/) },
  	message    => sub {
  		'Must be a non-empty single line of no more than 255 chars that consists '
  			. 'of numeric characters only'
  	},
  );
  
  NumericCode->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ do { (my $code = $_) =~ s/[[:punct:][:space:]]//g; $code } ],
  );
  
  $meta->add_type(
  	name       => Password,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { length($_) > 3 },
  	inlined    => sub { SimpleStr->inline_check($_), qq(length($_) > 3) },
  	message    => sub { "Must be between 4 and 255 chars" },
  );
  
  $meta->add_type(
  	name       => StrongPassword,
  	parent     => Password,
  	constraint => sub { length($_) > 7 and /[^a-zA-Z]/ },
  	inlined    => sub { SimpleStr()->inline_check($_), qq(length($_) > 7), qq($_ =~ /[^a-zA-Z]/) },
  	message    => sub { "Must be between 8 and 255 chars, and contain a non-alpha char" },
  );
  
  my ($nestr);
  if (Type::Tiny::_USE_XS) {
  	$nestr = Type::Tiny::XS::get_coderef_for('NonEmptyStr');
  }
  
  $meta->add_type(
  	name       => NonEmptyStr,
  	parent     => Str,
  	constraint => sub { length($_) > 0 },
  	inlined    => sub {
  		if ($nestr) {
  			my $xsub = Type::Tiny::XS::get_subname_for($_[0]->name);
  			return "$xsub($_[1])" if $xsub;
  		}
  		undef, qq(length($_) > 0);
  	},
  	message    => sub { "Must not be empty" },
  	$nestr ? ( compiled_type_constraint => $nestr ) : (),
  );
  
  $meta->add_type(
  	name       => LowerCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain upper case letters" },
  );
  
  LowerCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseStr,
  	parent     => NonEmptyStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseStr->coercion->add_type_coercions(
  	NonEmptyStr, q[ uc($_) ],
  );
  
  $meta->add_type(
  	name       => LowerCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Upper}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Upper}/ms) },
  	message    => sub { "Must not contain pper case letters" },
  );
  
  LowerCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ lc($_) ],
  );
  
  $meta->add_type(
  	name       => UpperCaseSimpleStr,
  	parent     => NonEmptySimpleStr,
  	constraint => sub { !/\p{Lower}/ms },
  	inlined    => sub { undef, qq($_ !~ /\\p{Lower}/ms) },
  	message    => sub { "Must not contain lower case letters" },
  );
  
  UpperCaseSimpleStr->coercion->add_type_coercions(
  	NonEmptySimpleStr, q[ uc($_) ],
  );
  
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Common::String - drop-in replacement for MooseX::Types::Common::String
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  A drop-in replacement for L<MooseX::Types::Common::String>.
  
  =head2 Types
  
  The following types are similar to those described in
  L<MooseX::Types::Common::String>.
  
  =over
  
  =item C<SimpleStr>
  
  =item C<NonEmptySimpleStr>
  
  =item C<NumericCode>
  
  =item C<LowerCaseSimpleStr>
  
  =item C<UpperCaseSimpleStr>
  
  =item C<Password>
  
  =item C<StrongPassword>
  
  =item C<NonEmptyStr>
  
  =item C<LowerCaseStr>
  
  =item C<UpperCaseStr>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>, L<Types::Common::Numeric>.
  
  L<MooseX::Types::Common>,
  L<MooseX::Types::Common::Numeric>,
  L<MooseX::Types::Common::String>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_COMMON_STRING

$fatpacked{"Types/Serialiser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER';
  =head1 NAME
  
  Types::Serialiser - simple data types for common serialisation formats
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  This module provides some extra datatypes that are used by common
  serialisation formats such as JSON or CBOR. The idea is to have a
  repository of simple/small constants and containers that can be shared by
  different implementations so they become interoperable between each other.
  
  =cut
  
  package Types::Serialiser;
  
  use common::sense; # required to suppress annoying warnings
  
  our $VERSION = '1.0';
  
  =head1 SIMPLE SCALAR CONSTANTS
  
  Simple scalar constants are values that are overloaded to act like simple
  Perl values, but have (class) type to differentiate them from normal Perl
  scalars. This is necessary because these have different representations in
  the serialisation formats.
  
  =head2 BOOLEANS (Types::Serialiser::Boolean class)
  
  This type has only two instances, true and false. A natural representation
  for these in Perl is C<1> and C<0>, but serialisation formats need to be
  able to differentiate between them and mere numbers.
  
  =over 4
  
  =item $Types::Serialiser::true, Types::Serialiser::true
  
  This value represents the "true" value. In most contexts is acts like
  the number C<1>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::true>) or the constant form (C<Types::Serialiser::true>).
  
  The constant is represented as a reference to a scalar containing C<1> -
  implementations are allowed to directly test for this.
  
  =item $Types::Serialiser::false, Types::Serialiser::false
  
  This value represents the "false" value. In most contexts is acts like
  the number C<0>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::false>) or the constant form (C<Types::Serialiser::false>).
  
  The constant is represented as a reference to a scalar containing C<0> -
  implementations are allowed to directly test for this.
  
  =item $is_bool = Types::Serialiser::is_bool $value
  
  Returns true iff the C<$value> is either C<$Types::Serialiser::true> or
  C<$Types::Serialiser::false>.
  
  For example, you could differentiate between a perl true value and a
  C<Types::Serialiser::true> by using this:
  
     $value && Types::Serialiser::is_bool $value
  
  =item $is_true = Types::Serialiser::is_true $value
  
  Returns true iff C<$value> is C<$Types::Serialiser::true>.
  
  =item $is_false = Types::Serialiser::is_false $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::false>.
  
  =back
  
  =head2 ERROR (Types::Serialiser::Error class)
  
  This class has only a single instance, C<error>. It is used to signal
  an encoding or decoding error. In CBOR for example, and object that
  couldn't be encoded will be represented by a CBOR undefined value, which
  is represented by the error value in Perl.
  
  =over 4
  
  =item $Types::Serialiser::error, Types::Serialiser::error
  
  This value represents the "error" value. Accessing values of this type
  will throw an exception.
  
  The constant is represented as a reference to a scalar containing C<undef>
  - implementations are allowed to directly test for this.
  
  =item $is_error = Types::Serialiser::is_error $value
  
  Returns false iff C<$value> is C<$Types::Serialiser::error>.
  
  =back
  
  =cut
  
  BEGIN {
     # for historical reasons, and to avoid extra dependencies in JSON::PP,
     # we alias *Types::Serialiser::Boolean with JSON::PP::Boolean.
     package JSON::PP::Boolean;
  
     *Types::Serialiser::Boolean:: = *JSON::PP::Boolean::;
  }
  
  {
     # this must done before blessing to work around bugs
     # in perl < 5.18 (it seems to be fixed in 5.18).
     package Types::Serialiser::BooleanBase;
  
     use overload
        "0+"     => sub { ${$_[0]} },
        "++"     => sub { $_[0] = ${$_[0]} + 1 },
        "--"     => sub { $_[0] = ${$_[0]} - 1 },
        fallback => 1;
  
     @Types::Serialiser::Boolean::ISA = Types::Serialiser::BooleanBase::;
  }
  
  our $true  = do { bless \(my $dummy = 1), Types::Serialiser::Boolean:: };
  our $false = do { bless \(my $dummy = 0), Types::Serialiser::Boolean:: };
  our $error = do { bless \(my $dummy    ), Types::Serialiser::Error::   };
  
  sub true  () { $true  }
  sub false () { $false }
  sub error () { $error }
  
  sub is_bool  ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_true  ($) {  $_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_false ($) { !$_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_error ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Error::   }
  
  package Types::Serialiser::Error;
  
  sub error {
     require Carp;
     Carp::croak ("caught attempt to use the Types::Serialiser::error value");
  };
  
  use overload
     "0+"     => \&error,
     "++"     => \&error,
     "--"     => \&error,
     fallback => 1;
  
  =head1 NOTES FOR XS USERS
  
  The recommended way to detect whether a scalar is one of these objects
  is to check whether the stash is the C<Types::Serialiser::Boolean> or
  C<Types::Serialiser::Error> stash, and then follow the scalar reference to
  see if it's C<1> (true), C<0> (false) or C<undef> (error).
  
  While it is possible to use an isa test, directly comparing stash pointers
  is faster and guaranteed to work.
  
  For historical reasons, the C<Types::Serialiser::Boolean> stash is
  just an alias for C<JSON::PP::Boolean>. When printed, the classname
  with usually be C<JSON::PP::Boolean>, but isa tests and stash pointer
  comparison will normally work correctly (i.e. Types::Serialiser::true ISA
  JSON::PP::Boolean, but also ISA Types::Serialiser::Boolean).
  
  =head1 A GENERIC OBJECT SERIALIATION PROTOCOL
  
  This section explains the object serialisation protocol used by
  L<CBOR::XS>. It is meant to be generic enough to support any kind of
  generic object serialiser.
  
  This protocol is called "the Types::Serialiser object serialisation
  protocol".
  
  =head2 ENCODING
  
  When the encoder encounters an object that it cannot otherwise encode (for
  example, L<CBOR::XS> can encode a few special types itself, and will first
  attempt to use the special C<TO_CBOR> serialisation protocol), it will
  look up the C<FREEZE> method on the object.
  
  Note that the C<FREEZE> method will normally be called I<during> encoding,
  and I<MUST NOT> change the data structure that is being encoded in any
  way, or it might cause memory corruption or worse.
  
  If it exists, it will call it with two arguments: the object to serialise,
  and a constant string that indicates the name of the data model. For
  example L<CBOR::XS> uses C<CBOR>, and the L<JSON> and L<JSON::XS> modules
  (or any other JSON serialiser), would use C<JSON> as second argument.
  
  The C<FREEZE> method can then return zero or more values to identify the
  object instance. The serialiser is then supposed to encode the class name
  and all of these return values (which must be encodable in the format)
  using the relevant form for Perl objects. In CBOR for example, there is a
  registered tag number for encoded perl objects.
  
  The values that C<FREEZE> returns must be serialisable with the serialiser
  that calls it. Therefore, it is recommended to use simple types such as
  strings and numbers, and maybe array references and hashes (basically, the
  JSON data model). You can always use a more complex format for a specific
  data model by checking the second argument, the data model.
  
  The "data model" is not the same as the "data format" - the data model
  indicates what types and kinds of return values can be returned from
  C<FREEZE>. For example, in C<CBOR> it is permissible to return tagged CBOR
  values, while JSON does not support these at all, so C<JSON> would be a
  valid (but too limited) data model name for C<CBOR::XS>. similarly, a
  serialising format that supports more or less the same data model as JSON
  could use C<JSON> as data model without losing anything.
  
  =head2 DECODING
  
  When the decoder then encounters such an encoded perl object, it should
  look up the C<THAW> method on the stored classname, and invoke it with the
  classname, the constant string to identify the data model/data format, and
  all the return values returned by C<FREEZE>.
  
  =head2 EXAMPLES
  
  See the C<OBJECT SERIALISATION> section in the L<CBOR::XS> manpage for
  more details, an example implementation, and code examples.
  
  Here is an example C<FREEZE>/C<THAW> method pair:
  
     sub My::Object::FREEZE {
        my ($self, $model) = @_;
  
        ($self->{type}, $self->{id}, $self->{variant})
     }
  
     sub My::Object::THAW {
        my ($class, $model, $type, $id, $variant) = @_;
  
        $class->new (type => $type, id => $id, variant => $variant)
     }
  
  =head1 BUGS
  
  The use of L<overload> makes this module much heavier than it should be
  (on my system, this module: 4kB RSS, overload: 260kB RSS).
  
  =head1 SEE ALSO
  
  Currently, L<JSON::XS> and L<CBOR::XS> use these types.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER

$fatpacked{"Types/Serialiser/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER_ERROR';
  =head1 NAME
  
  Types::Serialiser::Error - dummy module for Types::Serialiser
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and
  similar modules that assume that class name equals module name. See
  L<Types::Serialiser> for more info about this class.
  
  =cut
  
  use Types::Serialiser ();
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/
  
  =cut
  
  1
  
TYPES_SERIALISER_ERROR

$fatpacked{"Types/Standard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD';
  package Types::Standard;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	eval { require re };
  	if ($] < 5.008) { require Devel::TypeTiny::Perl56Compat };
  	if ($] < 5.010) { require Devel::TypeTiny::Perl58Compat };
  }
  
  BEGIN {
  	$Types::Standard::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::VERSION   = '1.002001';
  }
  
  use Type::Library -base;
  
  our @EXPORT_OK = qw( slurpy );
  
  use Scalar::Util qw( blessed looks_like_number );
  use Type::Tiny ();
  use Types::TypeTiny ();
  
  BEGIN {
  	*_is_class_loaded = Type::Tiny::_USE_XS
  		? \&Type::Tiny::XS::Util::is_class_loaded
  		: sub {
  			return !!0 if ref $_[0];
  			return !!0 if not $_[0];
  			my $stash = do { no strict 'refs'; \%{"$_[0]\::"} };
  			return !!1 if exists $stash->{'ISA'};
  			return !!1 if exists $stash->{'VERSION'};
  			foreach my $globref (values %$stash) {
  				return !!1 if *{$globref}{CODE};
  			}
  			return !!0;
  		};
  };
  
  my $HAS_RUXS = eval {
  	require Ref::Util::XS;
  	Ref::Util::XS::->VERSION(0.100);
  	1;
  };
  
  my $add_core_type = sub {
  	my $meta = shift;
  	my ($typedef) = @_;
  	
  	my $name = $typedef->{name};
  	my ($xsub, $xsubname);
  	
  	# We want Map and Tuple to be XSified, even if they're not
  	# really core.
  	$typedef->{_is_core} = 1
  		unless $name eq 'Map' || $name eq 'Tuple';
  
  	if ( Type::Tiny::_USE_XS
  	and not ($name eq 'RegexpRef') ) {
  		$xsub     = Type::Tiny::XS::get_coderef_for($name);
  		$xsubname = Type::Tiny::XS::get_subname_for($name);
  	}
  		
  	elsif ( Type::Tiny::_USE_MOUSE
  	and not ($name eq 'RegexpRef' or $name eq 'Int' or $name eq 'Object') ) {
  		require Mouse::Util::TypeConstraints;
  		$xsub     = "Mouse::Util::TypeConstraints"->can($name);
  		$xsubname = "Mouse::Util::TypeConstraints::$name" if $xsub;
  	}
  	
  	$typedef->{compiled_type_constraint} = $xsub if $xsub;
  	
  	$typedef->{inlined} = sub { "$xsubname\($_[1])" }
  		if defined($xsubname) and (
  			# These should be faster than their normal inlined
  			# equivalents
  			$name eq 'Str' or
  			$name eq 'Bool' or
  			$name eq 'ClassName' or
  			$name eq 'RegexpRef' or
  			$name eq 'FileHandle'
  		);
  	
  	$meta->add_type($typedef);
  };
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = __PACKAGE__->meta;
  
  # Stringable and LazyLoad are optimizations that complicate
  # this module somewhat, but they have led to performance
  # improvements. If Types::Standard wasn't such a key type
  # library, I wouldn't use them. I strongly discourage anybody
  # from using them in their own code. If you're looking for
  # examples of how to write a type library sanely, you're
  # better off looking at the code for Types::Common::Numeric
  # and Types::Common::String.
  
  sub Stringable (&)
  {
  	package #private
  	Types::Standard::_Stringable;
  	use overload q[""] => sub { $_[0]{text} ||= $_[0]{code}->() }, fallback => 1;
  	bless +{ code => $_[0] };
  }
  
  sub LazyLoad ($$)
  {
  	package #private
  	Types::Standard::LazyLoad;
  	use overload fallback => 1, q[&{}] => sub {
  		my ($typename, $function) = @{$_[0]};
  		my $type  = $meta->get_type($typename);
  		my $class = "Types::Standard::$typename";
  		eval "require $class; 1" or die($@);
  		# Majorly break encapsulation for Type::Tiny :-O
  		for my $key (keys %$type)
  		{
  			next unless ref($type->{$key}) eq __PACKAGE__;
  			my $f = $type->{$key}[1];
  			$type->{$key} = $class->can("__$f");
  		}
  		return $class->can("__$function");
  	};
  	bless \@_;
  }
  
  no warnings;
  
  BEGIN { *STRICTNUM = $ENV{PERL_TYPES_STANDARD_STRICTNUM} ? sub(){!!1} : sub(){!!0} };
  
  my $_any = $meta->$add_core_type({
  	name       => "Any",
  	inlined    => sub { "!!1" },
  });
  
  my $_item = $meta->$add_core_type({
  	name       => "Item",
  	inlined    => sub { "!!1" },
  	parent     => $_any,
  });
  
  $meta->$add_core_type({
  	name       => "Bool",
  	parent     => $_item,
  	constraint => sub { !defined $_ or $_ eq q() or $_ eq '0' or $_ eq '1' },
  	inlined    => sub { "!defined $_[1] or $_[1] eq q() or $_[1] eq '0' or $_[1] eq '1'" },
  });
  
  my $_undef = $meta->$add_core_type({
  	name       => "Undef",
  	parent     => $_item,
  	constraint => sub { !defined $_ },
  	inlined    => sub { "!defined($_[1])" },
  });
  
  my $_def = $meta->$add_core_type({
  	name       => "Defined",
  	parent     => $_item,
  	constraint => sub { defined $_ },
  	inlined    => sub { "defined($_[1])" },
  });
  
  my $_val = $meta->$add_core_type({
  	name       => "Value",
  	parent     => $_def,
  	constraint => sub { not ref $_ },
  	inlined    => sub { "defined($_[1]) and not ref($_[1])" },
  });
  
  my $_str = $meta->$add_core_type({
  	name       => "Str",
  	parent     => $_val,
  	constraint => sub { ref(\$_) eq 'SCALAR' or ref(\(my $val = $_)) eq 'SCALAR' },
  	inlined    => sub {
  		"defined($_[1]) and do { ref(\\$_[1]) eq 'SCALAR' or ref(\\(my \$val = $_[1])) eq 'SCALAR' }"
  	},
  });
  
  my $_laxnum = $meta->add_type({
  	name       => "LaxNum",
  	parent     => $_str,
  	constraint => sub { looks_like_number $_ },
  	inlined    => sub { "defined($_[1]) && !ref($_[1]) && Scalar::Util::looks_like_number($_[1])" },
  });
  
  my $_strictnum = $meta->add_type({
  	name       => "StrictNum",
  	parent     => $_str,
  	constraint => sub {
  		my $val = $_;
  		($val =~ /\A[+-]?[0-9]+\z/) ||
  		( $val =~ /\A(?:[+-]?)                #matches optional +- in the beginning
  		(?=[0-9]|\.[0-9])                     #matches previous +- only if there is something like 3 or .3
  		[0-9]*                                #matches 0-9 zero or more times
  		(?:\.[0-9]+)?                         #matches optional .89 or nothing
  		(?:[Ee](?:[+-]?[0-9]+))?              #matches E1 or e1 or e-1 or e+1 etc
  		\z/x );
  	},
  	inlined    => sub {
  		'my $val = '.$_[1].';'.
  		Value()->inline_check('$val')
  		.' && ( $val =~ /\A[+-]?[0-9]+\z/ || '
  		. '$val =~ /\A(?:[+-]?)              # matches optional +- in the beginning
  			(?=[0-9]|\.[0-9])                 # matches previous +- only if there is something like 3 or .3
  			[0-9]*                            # matches 0-9 zero or more times
  			(?:\.[0-9]+)?                     # matches optional .89 or nothing
  			(?:[Ee](?:[+-]?[0-9]+))?          # matches E1 or e1 or e-1 or e+1 etc
  		\z/x ); '
  	},
  });
  
  my $_num = $meta->add_type({
  	name       => "Num",
  	parent     => (STRICTNUM ? $_strictnum : $_laxnum),
  });
  
  $meta->$add_core_type({
  	name       => "Int",
  	parent     => $_num,
  	constraint => sub { /\A-?[0-9]+\z/ },
  	inlined    => sub { "defined($_[1]) and !ref($_[1]) and $_[1] =~ /\\A-?[0-9]+\\z/" },
  });
  
  my $_classn = $meta->add_type({
  	name       => "ClassName",
  	parent     => $_str,
  	constraint => \&_is_class_loaded,
  	inlined    => sub { "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] })" },
  });
  
  $meta->add_type({
  	name       => "RoleName",
  	parent     => $_classn,
  	constraint => sub { not $_->can("new") },
  	inlined    => sub { "Types::Standard::_is_class_loaded(do { my \$tmp = $_[1] }) and not $_[1]\->can('new')" },
  });
  
  my $_ref = $meta->$add_core_type({
  	name       => "Ref",
  	parent     => $_def,
  	constraint => sub { ref $_ },
  	inlined    => sub { "!!ref($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Ref') unless @_;
  		
  		my $reftype = shift;
  		Types::TypeTiny::StringLike->check($reftype)
  			or _croak("Parameter to Ref[`a] expected to be string; got $reftype");
  		
  		$reftype = "$reftype";
  		return sub {
  			ref($_[0]) and Scalar::Util::reftype($_[0]) eq $reftype;
  		}
  	},
  	inline_generator => sub
  	{
  		my $reftype = shift;
  		return sub {
  			my $v = $_[1];
  			"ref($v) and Scalar::Util::reftype($v) eq q($reftype)";
  		};
  	},
  	deep_explanation => sub {
  		require B;
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		return if $type->check($value);
  		my $reftype = Scalar::Util::reftype($value);
  		return [
  			sprintf('"%s" constrains reftype(%s) to be equal to %s', $type, $varname, B::perlstring($param)),
  			sprintf('reftype(%s) is %s', $varname, defined($reftype) ? B::perlstring($reftype) : "undef"),
  		];
  	},
  });
  
  $meta->$add_core_type({
  	name       => "CodeRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "CODE" },
  	inlined    => $HAS_RUXS
  		? sub { "Ref::Util::XS::is_plain_coderef($_[1])" }
  		: sub { "ref($_[1]) eq 'CODE'" },
  });
  
  my $_regexp = $meta->$add_core_type({
  	name       => "RegexpRef",
  	parent     => $_ref,
  	constraint => sub { ref($_) && !!re::is_regexp($_) or blessed($_) && $_->isa('Regexp') },
  	inlined    => sub { my $v = $_[1]; "ref($v) && !!re::is_regexp($v) or Scalar::Util::blessed($v) && $v\->isa('Regexp')" },
  });
  
  $meta->$add_core_type({
  	name       => "GlobRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "GLOB" },
  	inlined    => $HAS_RUXS
  		? sub { "Ref::Util::XS::is_plain_globref($_[1])" }
  		: sub { "ref($_[1]) eq 'GLOB'" },
  });
  
  $meta->$add_core_type({
  	name       => "FileHandle",
  	parent     => $_ref,
  	constraint => sub {
  		(ref($_) eq "GLOB" && Scalar::Util::openhandle($_))
  		or (blessed($_) && $_->isa("IO::Handle"))
  	},
  	inlined    => sub {
  		"(ref($_[1]) eq \"GLOB\" && Scalar::Util::openhandle($_[1])) ".
  		"or (Scalar::Util::blessed($_[1]) && $_[1]\->isa(\"IO::Handle\"))"
  	},
  });
  
  my $_arr = $meta->$add_core_type({
  	name       => "ArrayRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "ARRAY" },
  	inlined    => $HAS_RUXS
  		? sub { "Ref::Util::XS::is_plain_arrayref($_[1])" }
  		: sub { "ref($_[1]) eq 'ARRAY'" },
  	constraint_generator => LazyLoad(ArrayRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ArrayRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ArrayRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ArrayRef => 'coercion_generator'),
  });
  
  my $_hash = $meta->$add_core_type({
  	name       => "HashRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "HASH" },
  	inlined    => $HAS_RUXS
  		? sub { "Ref::Util::XS::is_plain_hashref($_[1])" }
  		: sub { "ref($_[1]) eq 'HASH'" },
  	constraint_generator => LazyLoad(HashRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(HashRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(HashRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(HashRef => 'coercion_generator'),
  	my_methods => {
  		hashref_allows_key => sub {
  			my $self = shift;
  			Str()->check($_[0]);
  		},
  		hashref_allows_value => sub {
  			my $self = shift;
  			my ($key, $value) = @_;
  			
  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==HashRef();
  			
  			my $href  = $self->find_parent(sub { $_->has_parent && $_->parent==HashRef() });
  			my $param = $href->type_parameter;
  			
  			Str()->check($key) and $param->check($value);
  		},
  	},
  });
  
  $meta->$add_core_type({
  	name       => "ScalarRef",
  	parent     => $_ref,
  	constraint => sub { ref $_ eq "SCALAR" or ref $_ eq "REF" },
  	inlined    => sub { "ref($_[1]) eq 'SCALAR' or ref($_[1]) eq 'REF'" },
  	constraint_generator => LazyLoad(ScalarRef => 'constraint_generator'),
  	inline_generator     => LazyLoad(ScalarRef => 'inline_generator'),
  	deep_explanation     => LazyLoad(ScalarRef => 'deep_explanation'),
  	coercion_generator   => LazyLoad(ScalarRef => 'coercion_generator'),
  });
  
  my $_obj = $meta->$add_core_type({
  	name       => "Object",
  	parent     => $_ref,
  	constraint => sub { blessed $_ },
  	inlined    => $HAS_RUXS
  		? sub { "Ref::Util::XS::is_blessed_ref($_[1])" }
  		: sub { "Scalar::Util::blessed($_[1])" },
  });
  
  $meta->$add_core_type({
  	name       => "Maybe",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Maybe') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Maybe[`a] expected to be a type constraint; got $param");
  		
  		my $param_compiled_check = $param->compiled_check;
  		my @xsub;
  		if (Type::Tiny::_USE_XS)
  		{
  			my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  			push @xsub, Type::Tiny::XS::get_coderef_for("Maybe[$paramname]")
  				if $paramname;
  		}
  		elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  		{
  			require Mouse::Util::TypeConstraints;
  			my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_Maybe_for");
  			push @xsub, $maker->($param) if $maker;
  		}
  		
  		return(
  			sub
  			{
  				my $value = shift;
  				return !!1 unless defined $value;
  				return $param->check($value);
  			},
  			@xsub,
  		);
  	},
  	inline_generator => sub {
  		my $param = shift;
  		
  		my $param_compiled_check = $param->compiled_check;
  		if (Type::Tiny::_USE_XS)
  		{
  			my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  			my $xsubname  = Type::Tiny::XS::get_subname_for("Maybe[$paramname]");
  			return sub { "$xsubname\($_[1]\)" } if $xsubname;
  		}
  		
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			my $param_check = $param->inline_check($v);
  			"!defined($v) or $param_check";
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s is defined', Type::Tiny::_dd($value)),
  			sprintf('"%s" constrains the value with "%s" if it is defined', $type, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  my $_map = $meta->$add_core_type({
  	name       => "Map",
  	parent     => $_hash,
  	constraint_generator => LazyLoad(Map => 'constraint_generator'),
  	inline_generator     => LazyLoad(Map => 'inline_generator'),
  	deep_explanation     => LazyLoad(Map => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Map => 'coercion_generator'),
  	my_methods => {
  		hashref_allows_key => sub {
  			my $self = shift;
  			my ($key) = @_;
  			
  			return Str()->check($key) if $self==Map();
  			
  			my $map = $self->find_parent(sub { $_->has_parent && $_->parent==Map() });
  			my ($kcheck, $vcheck) = @{ $map->parameters };
  			
  			($kcheck or Any())->check($key);
  		},
  		hashref_allows_value => sub {
  			my $self = shift;
  			my ($key, $value) = @_;
  			
  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==Map();
  			
  			my $map = $self->find_parent(sub { $_->has_parent && $_->parent==Map() });
  			my ($kcheck, $vcheck) = @{ $map->parameters };
  			
  			($kcheck or Any())->check($key)
  				and ($vcheck or Any())->check($value);
  		},
  	},
  });
  
  my $_Optional = $meta->add_type({
  	name       => "Optional",
  	parent     => $_item,
  	constraint_generator => sub
  	{
  		return $meta->get_type('Optional') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to Optional[`a] expected to be a type constraint; got $param");
  		
  		sub { $param->check($_[0]) }
  	},
  	inline_generator => sub {
  		my $param = shift;
  		return unless $param->can_be_inlined;
  		return sub {
  			my $v = $_[1];
  			$param->inline_check($v);
  		};
  	},
  	deep_explanation => sub {
  		my ($type, $value, $varname) = @_;
  		my $param = $type->parameters->[0];
  		
  		return [
  			sprintf('%s exists', $varname),
  			sprintf('"%s" constrains %s with "%s" if it exists', $type, $varname, $param),
  			@{ $param->validate_explain($value, $varname) },
  		];
  	},
  	coercion_generator => sub
  	{
  		my ($parent, $child, $param) = @_;
  		return unless $param->has_coercion;
  		return $param->coercion;
  	},
  });
  
  sub slurpy {
  	my $t = shift;
  	wantarray ? (+{ slurpy => $t }, @_) : +{ slurpy => $t };
  }
  
  $meta->$add_core_type({
  	name       => "Tuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], map { ref($_) eq "HASH" ? sprintf("slurpy %s", $_->{slurpy}) : $_ } @a);
  	},
  	constraint_generator => LazyLoad(Tuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(Tuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(Tuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Tuple => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "CycleTuple",
  	parent     => $_arr,
  	name_generator => sub
  	{
  		my ($s, @a) = @_;
  		sprintf('%s[%s]', $s, join q[,], @a);
  	},
  	constraint_generator => LazyLoad(CycleTuple => 'constraint_generator'),
  	inline_generator     => LazyLoad(CycleTuple => 'inline_generator'),
  	deep_explanation     => LazyLoad(CycleTuple => 'deep_explanation'),
  	coercion_generator   => LazyLoad(CycleTuple => 'coercion_generator'),
  });
  
  $meta->add_type({
  	name       => "Dict",
  	parent     => $_hash,
  	name_generator => sub
  	{
  		my ($s, @p) = @_;
  		my $l = ref($p[-1]) eq q(HASH) ? pop(@p)->{slurpy} : undef;
  		my %a = @p;
  		sprintf('%s[%s%s]', $s, join(q[,], map sprintf("%s=>%s", $_, $a{$_}), sort keys %a), $l ? ",slurpy $l" : '');
  	},
  	constraint_generator => LazyLoad(Dict => 'constraint_generator'),
  	inline_generator     => LazyLoad(Dict => 'inline_generator'),
  	deep_explanation     => LazyLoad(Dict => 'deep_explanation'),
  	coercion_generator   => LazyLoad(Dict => 'coercion_generator'),
  	my_methods => {
  		dict_is_slurpy => sub
  		{
  			my $self = shift;
  			
  			return !!0 if $self==Dict();
  			
  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			ref($dict->parameters->[-1]) eq q(HASH)
  				? $dict->parameters->[-1]{slurpy}
  				: !!0
  		},
  		hashref_allows_key => sub
  		{
  			my $self = shift;
  			my ($key) = @_;
  			
  			return Str()->check($key) if $self==Dict();
  			
  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			my %params;
  			my $slurpy = $dict->my_dict_is_slurpy;
  			if ($slurpy)
  			{
  				my @args = @{$dict->parameters};
  				pop @args;
  				%params = @args;
  			}
  			else
  			{
  				%params = @{ $dict->parameters }
  			}
  			
  			return !!1
  				if exists($params{$key});
  			return !!0
  				if !$slurpy;
  			return Str()->check($key)
  				if $slurpy==Any() || $slurpy==Item() || $slurpy==Defined() || $slurpy==Ref();
  			return $slurpy->my_hashref_allows_key($key)
  				if $slurpy->is_a_type_of(HashRef());
  			return !!0;
  		},
  		hashref_allows_value => sub
  		{
  			my $self = shift;
  			my ($key, $value) = @_;
  			
  			return !!0 unless $self->my_hashref_allows_key($key);
  			return !!1 if $self==Dict();
  			
  			my $dict = $self->find_parent(sub { $_->has_parent && $_->parent==Dict() });
  			my %params;
  			my $slurpy = $dict->my_dict_is_slurpy;
  			if ($slurpy)
  			{
  				my @args = @{$dict->parameters};
  				pop @args;
  				%params = @args;
  			}
  			else
  			{
  				%params = @{ $dict->parameters }
  			}
  			
  			return !!1
  				if exists($params{$key}) && $params{$key}->check($value);
  			return !!0
  				if !$slurpy;
  			return !!1
  				if $slurpy==Any() || $slurpy==Item() || $slurpy==Defined() || $slurpy==Ref();
  			return $slurpy->my_hashref_allows_value($key, $value)
  				if $slurpy->is_a_type_of(HashRef());
  			return !!0;
  		},
  	},
  });
  
  use overload ();
  $meta->add_type({
  	name       => "Overload",
  	parent     => $_obj,
  	constraint => sub { overload::Overloaded($_) },
  	inlined    => sub { "Scalar::Util::blessed($_[1]) and overload::Overloaded($_[1])" },
  	constraint_generator => sub
  	{
  		return $meta->get_type('Overload') unless @_;
  		
  		my @operations = map {
  			Types::TypeTiny::StringLike->check($_)
  				? "$_"
  				: _croak("Parameters to Overload[`a] expected to be a strings; got $_");
  		} @_;
  		
  		return sub {
  			my $value = shift;
  			for my $op (@operations) {
  				return unless overload::Method($value, $op);
  			}
  			return !!1;
  		}
  	},
  	inline_generator => sub {
  		my @operations = @_;
  		return sub {
  			my $v = $_[1];
  			join " and ",
  				"Scalar::Util::blessed($v)",
  				map "overload::Method($v, q[$_])", @operations;
  		};
  	},
  });
  
  our %_StrMatch;
  my $has_regexp_util;
  my $serialize_regexp = sub {
  	$has_regexp_util = eval {
  		require Regexp::Util;
  		Regexp::Util->VERSION('0.003');
  		1;
  	} || 0 unless defined $has_regexp_util;
  	
  	my $re = shift;
  	my $serialized;
  	if ($has_regexp_util) {
  		$serialized = eval { Regexp::Util::serialize_regexp($re) };
  	}
  	
  	if (!$serialized) {
  		my $key = sprintf('%s|%s', ref($re), $re);
  		$_StrMatch{$key} = $re;
  		$serialized = sprintf('$Types::Standard::_StrMatch{%s}', B::perlstring($key));
  	}
  	
  	return $serialized;
  };
  $meta->add_type({
  	name       => "StrMatch",
  	parent     => $_str,
  	constraint_generator => sub
  	{
  		return $meta->get_type('StrMatch') unless @_;
  		
  		my ($regexp, $checker) = @_;
  		
  		$_regexp->check($regexp)
  			or _croak("First parameter to StrMatch[`a] expected to be a Regexp; got $regexp");
  		
  		if (@_ > 1)
  		{
  			$checker = Types::TypeTiny::to_TypeTiny($checker);
  			Types::TypeTiny::TypeTiny->check($checker)
  				or _croak("Second parameter to StrMatch[`a] expected to be a type constraint; got $checker")
  		}
  		
  		$checker
  			? sub {
  				my $value = shift;
  				return if ref($value);
  				my @m = ($value =~ $regexp);
  				$checker->check(\@m);
  			}
  			: sub {
  				my $value = shift;
  				!ref($value) and $value =~ $regexp;
  			}
  		;
  	},
  	inline_generator => sub
  	{
  		require B;
  		my ($regexp, $checker) = @_;
  		if ($checker)
  		{
  			return unless $checker->can_be_inlined;
  			
  			my $serialized_re = $regexp->$serialize_regexp;
  			return sub
  			{
  				my $v = $_[1];
  				sprintf
  					"!ref($v) and do { my \$m = [$v =~ %s]; %s }",
  					$serialized_re,
  					$checker->inline_check('$m'),
  				;
  			};
  		}
  		else
  		{
  			my $regexp_string = "$regexp";
  			if ($regexp_string =~ /\A\(\?\^u?:(\.+)\)\z/) {
  				my $length = length $1;
  				return sub { "!ref($_) and length($_)>=$length" };
  			}
  			
  			if ($regexp_string =~ /\A\(\?\^u?:\\A(\.+)\\z\)\z/) {
  				my $length = length $1;
  				return sub { "!ref($_) and length($_)==$length" };
  			}
  			
  			my $serialized_re = $regexp->$serialize_regexp;
  			return sub
  			{
  				my $v = $_[1];
  				"!ref($v) and $v =~ $serialized_re";
  			};
  		}
  	},
  });
  
  $meta->add_type({
  	name       => "OptList",
  	parent     => $_arr,
  	constraint => sub {
  		for my $inner (@$_) {
  			return unless ref($inner) eq q(ARRAY);
  			return unless @$inner == 2;
  			return unless is_Str($inner->[0]);
  		}
  		return !!1;
  	},
  	inlined     => sub {
  		my ($self, $var) = @_;
  		my $Str_check = Str()->inline_check('$inner->[0]');
  		my @code = 'do { my $ok = 1; ';
  		push @code,   sprintf('for my $inner (@{%s}) { no warnings; ', $var);
  		push @code,   sprintf('($ok=0) && last unless ref($inner) eq q(ARRAY) && @$inner == 2 && (%s); ', $Str_check);
  		push @code,   '} ';
  		push @code, '$ok }';
  		return (undef, join(q( ), @code));
  	},
  });
  
  $meta->add_type({
  	name       => "Tied",
  	parent     => $_ref,
  	constraint => sub {
  		!!tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_})
  	},
  	inlined    => sub {
  		my ($self, $var) = @_;
  		$self->parent->inline_check($var)
  		. " and !!tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var})"
  	},
  	name_generator => sub
  	{
  		my $self  = shift;
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require B;
  			return sprintf("%s[%s]", $self, B::perlstring($param));
  		}
  		return sprintf("%s[%s]", $self, $param);
  	},
  	constraint_generator => sub
  	{
  		return $meta->get_type('Tied') unless @_;
  		
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		
  		my $check = $param->compiled_check;
  		return sub {
  			$check->(tied(Scalar::Util::reftype($_) eq 'HASH' ?  %{$_} : Scalar::Util::reftype($_) eq 'ARRAY' ?  @{$_} :  ${$_}));
  		};
  	},
  	inline_generator => sub {
  		my $param = Types::TypeTiny::to_TypeTiny(shift);
  		unless (Types::TypeTiny::TypeTiny->check($param))
  		{
  			Types::TypeTiny::StringLike->check($param)
  				or _croak("Parameter to Tied[`a] expected to be a class name; got $param");
  			require Type::Tiny::Class;
  			$param = "Type::Tiny::Class"->new(class => "$param");
  		}
  		return unless $param->can_be_inlined;
  		
  		return sub {
  			require B;
  			my $var = $_[1];
  			sprintf(
  				"%s and do { my \$TIED = tied(Scalar::Util::reftype($var) eq 'HASH' ? \%{$var} : Scalar::Util::reftype($var) eq 'ARRAY' ? \@{$var} : \${$var}); %s }",
  				Ref()->inline_check($var),
  				$param->inline_check('$TIED')
  			);
  		};
  	},
  });
  
  $meta->add_type({
  	name       => "InstanceOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('InstanceOf') unless @_;
  		require Type::Tiny::Class;
  		my @classes = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Class"->new(class => $_, display_name => sprintf('InstanceOf[%s]', B::perlstring($_)))
  		} @_;
  		return $classes[0] if @classes == 1;
  		
  		require B;
  		require Type::Tiny::Union;
  		return "Type::Tiny::Union"->new(
  			type_constraints => \@classes,
  			display_name     => sprintf('InstanceOf[%s]', join q[,], map B::perlstring($_->class), @classes),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "ConsumerOf",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('ConsumerOf') unless @_;
  		require B;
  		require Type::Tiny::Role;
  		my @roles = map {
  			Types::TypeTiny::TypeTiny->check($_)
  				? $_
  				: "Type::Tiny::Role"->new(role => $_, display_name => sprintf('ConsumerOf[%s]', B::perlstring($_)))
  		} @_;
  		return $roles[0] if @roles == 1;
  		
  		require Type::Tiny::Intersection;
  		return "Type::Tiny::Intersection"->new(
  			type_constraints => \@roles,
  			display_name     => sprintf('ConsumerOf[%s]', join q[,], map B::perlstring($_->role), @roles),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "HasMethods",
  	parent     => $_obj,
  	constraint_generator => sub {
  		return $meta->get_type('HasMethods') unless @_;
  		require B;
  		require Type::Tiny::Duck;
  		return "Type::Tiny::Duck"->new(
  			methods      => \@_,
  			display_name => sprintf('HasMethods[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_type({
  	name       => "Enum",
  	parent     => $_str,
  	constraint_generator => sub {
  		return $meta->get_type('Enum') unless @_;
  		require B;
  		require Type::Tiny::Enum;
  		return "Type::Tiny::Enum"->new(
  			values       => \@_,
  			display_name => sprintf('Enum[%s]', join q[,], map B::perlstring($_), @_),
  		);
  	},
  });
  
  $meta->add_coercion({
  	name               => "MkOpt",
  	type_constraint    => $meta->get_type("OptList"),
  	type_coercion_map  => [
  		$_arr,    q{ Exporter::Tiny::mkopt($_) },
  		$_hash,   q{ Exporter::Tiny::mkopt($_) },
  		$_undef,  q{ [] },
  	],
  });
  
  $meta->add_coercion({
  	name               => "Join",
  	type_constraint    => $_str,
  	coercion_generator => sub {
  		my ($self, $target, $sep) = @_;
  		Types::TypeTiny::StringLike->check($sep)
  			or _croak("Parameter to Join[`a] expected to be a string; got $sep");
  		require B;
  		$sep = B::perlstring($sep);
  		return (ArrayRef(), qq{ join($sep, \@\$_) });
  	},
  });
  
  $meta->add_coercion({
  	name               => "Split",
  	type_constraint    => $_arr,
  	coercion_generator => sub {
  		my ($self, $target, $re) = @_;
  		ref($re) eq q(Regexp)
  			or _croak("Parameter to Split[`a] expected to be a regular expresssion; got $re");
  		my $regexp_string = "$re";
  		$regexp_string =~ s/\\\//\\\\\//g; # toothpicks
  		return (Str(), qq{ [split /$regexp_string/, \$_] });
  	},
  });
  
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
  
  =for stopwords booleans vstrings typeglobs
  
  =encoding utf-8
  
  =for stopwords datetimes
  
  =head1 NAME
  
  Types::Standard - bundled set of built-in types for Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  L<Type::Tiny> bundles a few types which seem to be useful.
  
  =head2 Moose-like
  
  The following types are similar to those described in
  L<Moose::Util::TypeConstraints>.
  
  =over
  
  =item C<< Any >>
  
  Absolutely any value passes this type constraint (even undef).
  
  =item C<< Item >>
  
  Essentially the same as C<Any>. All other type constraints in this library
  inherit directly or indirectly from C<Item>.
  
  =item C<< Bool >>
  
  Values that are reasonable booleans. Accepts 1, 0, the empty string and
  undef.
  
  =item C<< Maybe[`a] >>
  
  Given another type constraint, also accepts undef. For example,
  C<< Maybe[Int] >> accepts all integers plus undef.
  
  =item C<< Undef >>
  
  Only undef passes this type constraint.
  
  =item C<< Defined >>
  
  Only undef fails this type constraint.
  
  =item C<< Value >>
  
  Any defined, non-reference value.
  
  =item C<< Str >>
  
  Any string.
  
  (The only difference between C<Value> and C<Str> is that the former accepts
  typeglobs and vstrings.)
  
  Other customers also bought: C<< StringLike >> from L<Types::TypeTiny>.
  
  =item C<< Num >>
  
  See C<LaxNum> and C<StrictNum> below.
  
  =item C<< Int >>
  
  An integer; that is a string of digits 0 to 9, optionally prefixed with a
  hyphen-minus character.
  
  =item C<< ClassName >>
  
  The name of a loaded package. The package must have C<< @ISA >> or
  C<< $VERSION >> defined, or must define at least one sub to be considered
  a loaded package.
  
  =item C<< RoleName >>
  
  Like C<< ClassName >>, but the package must I<not> define a method called
  C<new>. This is subtly different from Moose's type constraint of the same
  name; let me know if this causes you any problems. (I can't promise I'll
  change anything though.)
  
  =item C<< Ref[`a] >>
  
  Any defined reference value, including blessed objects.
  
  Unlike Moose, C<Ref> is a parameterized type, allowing Scalar::Util::reftype
  checks, a la
  
     Ref["HASH"]  # hashrefs, including blessed hashrefs
  
  =item C<< ScalarRef[`a] >>
  
  A value where C<< ref($value) eq "SCALAR" or ref($value) eq "REF" >>.
  
  If parameterized, the referred value must pass the additional constraint.
  For example, C<< ScalarRef[Int] >> must be a reference to a scalar which
  holds an integer value.
  
  =item C<< ArrayRef[`a] >>
  
  A value where C<< ref($value) eq "ARRAY" >>.
  
  If parameterized, the elements of the array must pass the additional
  constraint. For example, C<< ArrayRef[Num] >> must be a reference to an
  array of numbers.
  
  Other customers also bought: C<< ArrayLike >> from L<Types::TypeTiny>.
  
  =item C<< HashRef[`a] >>
  
  A value where C<< ref($value) eq "HASH" >>.
  
  If parameterized, the values of the hash must pass the additional
  constraint. For example, C<< HashRef[Num] >> must be a reference to an
  hash where the values are numbers. The hash keys are not constrained,
  but Perl limits them to strings; see C<Map> below if you need to further
  constrain the hash values.
  
  Other customers also bought: C<< HashLike >> from L<Types::TypeTiny>.
  
  =item C<< CodeRef >>
  
  A value where C<< ref($value) eq "CODE" >>.
  
  Other customers also bought: C<< CodeLike >> from L<Types::TypeTiny>.
  
  =item C<< RegexpRef >>
  
  A reference where C<< re::is_regexp($value) >> is true, or
  a blessed reference where C<< $value->isa("Regexp") >> is true.
  
  =item C<< GlobRef >>
  
  A value where C<< ref($value) eq "GLOB" >>.
  
  =item C<< FileHandle >>
  
  A file handle.
  
  =item C<< Object >>
  
  A blessed object.
  
  (This also accepts regexp refs.)
  
  =back
  
  =head2 Structured
  
  OK, so I stole some ideas from L<MooseX::Types::Structured>.
  
  =over
  
  =item C<< Map[`k, `v] >>
  
  Similar to C<HashRef> but parameterized with type constraints for both the
  key and value. The constraint for keys would typically be a subtype of
  C<Str>.
  
  =item C<< Tuple[...] >>
  
  Subtype of C<ArrayRef>, accepting a list of type constraints for
  each slot in the array.
  
  C<< Tuple[Int, HashRef] >> would match C<< [1, {}] >> but not C<< [{}, 1] >>.
  
  =item C<< Dict[...] >>
  
  Subtype of C<HashRef>, accepting a list of type constraints for
  each slot in the hash.
  
  For example C<< Dict[name => Str, id => Int] >> allows
  C<< { name => "Bob", id => 42 } >>.
  
  =item C<< Optional[`a] >>
  
  Used in conjunction with C<Dict> and C<Tuple> to specify slots that are
  optional and may be omitted (but not necessarily set to an explicit undef).
  
  C<< Dict[name => Str, id => Optional[Int]] >> allows C<< { name => "Bob" } >>
  but not C<< { name => "Bob", id => "BOB" } >>.
  
  Note that any use of C<< Optional[`a] >> outside the context of
  parameterized C<Dict> and C<Tuple> type constraints makes little sense,
  and its behaviour is undefined. (An exception: it is used by
  L<Type::Params> for a similar purpose to how it's used in C<Tuple>.)
  
  =back
  
  This module also exports a C<slurpy> function, which can be used as
  follows.
  
  It can cause additional trailing values in a C<Tuple> to be slurped
  into a structure and validated. For example, slurping into an ArrayRef:
  
     my $type = Tuple[Str, slurpy ArrayRef[Int]];
     
     $type->( ["Hello"] );                # ok
     $type->( ["Hello", 1, 2, 3] );       # ok
     $type->( ["Hello", [1, 2, 3]] );     # not ok
  
  Or into a hashref:
  
     my $type2 = Tuple[Str, slurpy Map[Int, RegexpRef]];
     
     $type2->( ["Hello"] );                               # ok
     $type2->( ["Hello", 1, qr/one/i, 2, qr/two/] );      # ok
  
  It can cause additional values in a C<Dict> to be slurped into a
  hashref and validated:
  
     my $type3 = Dict[ values => ArrayRef, slurpy HashRef[Str] ];
     
     $type3->( { values => [] } );                        # ok
     $type3->( { values => [], name => "Foo" } );         # ok
     $type3->( { values => [], name => [] } );            # not ok
  
  In either C<Tuple> or C<Dict>, C<< slurpy Any >> can be used to indicate
  that additional values are acceptable, but should not be constrained in
  any way. 
  
  C<< slurpy Any >> is an optimized code path. Although the following are
  essentially equivalent checks, the former should run a lot faster:
  
     Tuple[Int, slurpy Any]
     Tuple[Int, slurpy ArrayRef]
  
  =begin trustme
  
  =item slurpy
  
  =end trustme
  
  =head2 Objects
  
  OK, so I stole some ideas from L<MooX::Types::MooseLike::Base>.
  
  =over
  
  =item C<< InstanceOf[`a] >>
  
  Shortcut for a union of L<Type::Tiny::Class> constraints.
  
  C<< InstanceOf["Foo", "Bar"] >> allows objects blessed into the C<Foo>
  or C<Bar> classes, or subclasses of those.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< ConsumerOf[`a] >>
  
  Shortcut for an intersection of L<Type::Tiny::Role> constraints.
  
  C<< ConsumerOf["Foo", "Bar"] >> allows objects where C<< $o->DOES("Foo") >>
  and C<< $o->DOES("Bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =item C<< HasMethods[`a] >>
  
  Shortcut for a L<Type::Tiny::Duck> constraint.
  
  C<< HasMethods["foo", "bar"] >> allows objects where C<< $o->can("foo") >>
  and C<< $o->can("bar") >> both return true.
  
  Given no parameters, just equivalent to C<Object>.
  
  =back
  
  =head2 More
  
  There are a few other types exported by this function:
  
  =over
  
  =item C<< Overload[`a] >>
  
  With no parameters, checks that the value is an overloaded object. Can
  be given one or more string parameters, which are specific operations
  to check are overloaded. For example, the following checks for objects
  which overload addition and subtraction.
  
     Overload["+", "-"]
  
  =item C<< Tied[`a] >>
  
  A reference to a tied scalar, array or hash.
  
  Can be parameterized with a type constraint which will be applied to
  the object returned by the C<< tied() >> function. As a convenience,
  can also be parameterized with a string, which will be inflated to a
  L<Type::Tiny::Class>.
  
     use Types::Standard qw(Tied);
     use Type::Utils qw(class_type);
     
     my $My_Package = class_type { class => "My::Package" };
     
     tie my %h, "My::Package";
     \%h ~~ Tied;                   # true
     \%h ~~ Tied[ $My_Package ];    # true
     \%h ~~ Tied["My::Package"];    # true
     
     tie my $s, "Other::Package";
     \$s ~~ Tied;                   # true
     $s  ~~ Tied;                   # false !!
  
  If you need to check that something is specifically a reference to
  a tied hash, use an intersection:
  
     use Types::Standard qw( Tied HashRef );
     
     my $TiedHash = (Tied) & (HashRef);
     
     tie my %h, "My::Package";
     tie my $s, "Other::Package";
     
     \%h ~~ $TiedHash;     # true
     \$s ~~ $TiedHash;     # false
  
  =item C<< StrMatch[`a] >>
  
  A string that matches a regular expression:
  
     declare "Distance",
        as StrMatch[ qr{^([0-9]+)\s*(mm|cm|m|km)$} ];
  
  You can optionally provide a type constraint for the array of subexpressions:
  
     declare "Distance",
        as StrMatch[
           qr{^([0-9]+)\s*(.+)$},
           Tuple[
              Int,
              enum(DistanceUnit => [qw/ mm cm m km /]),
           ],
        ];
  
  On certain versions of Perl, type constraints of the forms
  C<< StrMatch[qr/../ >> and C<< StrMatch[qr/\A..\z/ >> with any number
  of intervening dots can be optimized to simple length checks.
  
  =item C<< Enum[`a] >>
  
  As per MooX::Types::MooseLike::Base:
  
     has size => (is => "ro", isa => Enum[qw( S M L XL XXL )]);
  
  =item C<< OptList >>
  
  An arrayref of arrayrefs in the style of L<Data::OptList> output.
  
  =item C<< LaxNum >>, C<< StrictNum >>
  
  In Moose 2.09, the C<Num> type constraint implementation was changed from
  being a wrapper around L<Scalar::Util>'s C<looks_like_number> function to
  a stricter regexp (which disallows things like "-Inf" and "Nan").
  
  Types::Standard provides I<both> implementations. C<LaxNum> is measurably
  faster.
  
  The C<Num> type constraint is currently an alias for C<LaxNum> unless you
  set the C<PERL_TYPES_STANDARD_STRICTNUM> environment variable to true before
  loading Types::Standard, in which case it becomes an alias for C<StrictNum>.
  The constant C<< Types::Standard::STRICTNUM >> can be used to check if
  C<Num> is being strict.
  
  Most people should probably use C<Num> or C<StrictNum>. Don't explicitly
  use C<LaxNum> unless you specifically need an attribute which will accept
  things like "Inf".
  
  =item C<< CycleTuple[`a] >>
  
  Similar to Tuple, but cyclical.
  
     CycleTuple[Int, HashRef]
  
  will allow C<< [1,{}] >> and C<< [1,{},2,{}] >> but disallow
  C<< [1,{},2] >> and C<< [1,{},2,[]] >>.
  
  I think you understand CycleTuples already.
  
  Currently C<Optional> and C<slurpy> parameters are forbidden. There are
  fairly limited use cases for them, and it's not exactly clear what they
  should mean.
  
  The following is an efficient way of checking for an even-sized arrayref:
  
     CycleTuple[Any, Any]
  
  The following is an arrayref which would be suitable for coercing to a
  hashref:
  
     CycleTuple[Str, Any]
  
  All the examples so far have used two parameters, but the following is
  also a possible CycleTuple:
  
     CycleTuple[Str, Int, HashRef]
  
  This will be an arrayref where the 0th, 3rd, 6th, etc values are
  strings, the 1st, 4th, 7th, etc values are integers, and the 2nd,
  5th, 8th, etc values are hashrefs.
  
  =back
  
  =head2 Coercions
  
  None of the types in this type library have any coercions by default.
  However some standalone coercions may be exported. These can be combined
  with type constraints using the C<< plus_coercions >> method.
  
  =over
  
  =item C<< MkOpt >>
  
  A coercion from C<ArrayRef>, C<HashRef> or C<Undef> to C<OptList>. Example
  usage in a Moose attribute:
  
     use Types::Standard qw( OptList MkOpt );
     
     has options => (
        is     => "ro",
        isa    => OptList->plus_coercions( MkOpt ),
        coerce => 1,
     );
  
  =item C<< Split[`a] >>
  
  Split a string on a regexp.
  
     use Types::Standard qw( ArrayRef Str Split );
     
     has name => (
        is     => "ro",
        isa    => (ArrayRef[Str])->plus_coercions(Split[qr/\s/]),
        coerce => 1,
     );
  
  =item C<< Join[`a] >>
  
  Join an array of strings with a delimiter.
  
     use Types::Standard qw( Str Join );
     
     my $FileLines = Str->plus_coercions(Join["\n"]);
     
     has file_contents => (
        is     => "ro",
        isa    => $FileLines,
        coerce => 1,
     );
  
  =back
  
  =head2 Constants
  
  =over
  
  =item C<< Types::Standard::STRICTNUM >>
  
  Indicates whether C<Num> is an alias for C<StrictNum>. (It is usually an
  alias for C<LaxNum>.)
  
  =back
  
  =begin private
  
  =item Stringable
  
  =item LazyLoad
  
  =end private
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny::Manual>.
  
  L<Type::Tiny>, L<Type::Library>, L<Type::Utils>, L<Type::Coercion>.
  
  L<Moose::Util::TypeConstraints>,
  L<Mouse::Util::TypeConstraints>,
  L<MooseX::Types::Structured>.
  
  L<Types::XSD> provides some type constraints based on XML Schema's data
  types; this includes constraints for ISO8601-formatted datetimes, integer
  ranges (e.g. C<< PositiveInteger[maxInclusive=>10] >> and so on.
  
  L<Types::Encodings> provides C<Bytes> and C<Chars> type constraints that
  were formerly found in Types::Standard.
  
  L<Types::Common::Numeric> and L<Types::Common::String> provide replacements
  for L<MooseX::Types::Common>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD

$fatpacked{"Types/Standard/ArrayRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_ARRAYREF';
  package Types::Standard::ArrayRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ArrayRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ArrayRef::VERSION   = '1.002001';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ArrayRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ArrayRef[`a] expected to be a type constraint; got $param");
  	
  	_croak("Only one parameter to ArrayRef[`a] expected; got @{[ 1 + @_ ]}. Did you mean to use Tuple[`a]?")
  		if @_;
  	
  	my $param_compiled_check = $param->compiled_check;
  	my $xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		$xsub = Type::Tiny::XS::get_coderef_for("ArrayRef[$paramname]")
  			if $paramname;
  	}
  	elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_ArrayRef_for");
  		$xsub = $maker->($param) if $maker;
  	}
  	
  	return (
  		sub
  		{
  			my $array = shift;
  			$param->check($_) || return for @$array;
  			return !!1;
  		},
  		$xsub,
  	);
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	
  	my $param_compiled_check = $param->compiled_check;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		my $xsubname  = Type::Tiny::XS::get_subname_for("ArrayRef[$paramname]");
  		return sub { "$xsubname\($_[1]\)" } if $xsubname;
  	}
  	
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		my $p = Types::Standard::ArrayRef->inline_check($v);
  		"$p and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (\@{$v}) { "
  		.    "(\$ok = 0, last) unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $i (0 .. $#$value)
  	{
  		my $item = $value->[$i];
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the array with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->[%d]', $varname, $i)) },
  		]
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, @new) = ($_, 0);';
  			push @code,    'for (@$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('push @new, (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my @new;
  				for my $item (@$value)
  				{
  					return $value unless $coercable_item->check($item);
  					push @new, $param->coerce($item);
  				}
  				return \@new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ArrayRef - internals for the Types::Standard ArrayRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_ARRAYREF

$fatpacked{"Types/Standard/CycleTuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_CYCLETUPLE';
  package Types::Standard::CycleTuple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::CycleTuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::CycleTuple::VERSION   = '1.002001';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_Optional = Types::Standard::Optional;
  my $_arr      = Types::Standard::ArrayRef;
  
  no warnings;
  
  my $cycleuniq = 0;
  
  sub __constraint_generator
  {
  	my @params = map {
  		ref($_) eq 'HASH' and exists($_->{slurpy})
  			and _croak("Parameters to CycleTuple[`a] cannot be slurpy");
  		my $param = Types::TypeTiny::to_TypeTiny($_);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to CycleTuple[`a] expected to be a type constraint; got $param");
  		$param;
  	} @_;
  	my $count  = @params;
  	my $tuple  = Types::Standard::Tuple()->of(@params);
  	
  	_croak("Parameters to CycleTuple[`a] cannot be optional")
  		if grep !!$_->is_strictly_a_type_of($_Optional), @params;
  	
  	sub {
  		my $value = shift;
  		return unless $_arr->check($value);
  		return if @$value % $count;
  		my $i = 0;
  		while ($i < $#$value) {
  			my $tmp = [@$value[ $i .. $i+$count-1 ]];
  			return unless $tuple->check($tmp);
  			$i += $count;
  		}
  		!!1;
  	}
  }
  
  sub __inline_generator
  {
  	my @params = map {
  		my $param = Types::TypeTiny::to_TypeTiny($_);
  		Types::TypeTiny::TypeTiny->check($param)
  			or _croak("Parameter to CycleTuple[`a] expected to be a type constraint; got $param");
  		$param;
  	} @_;
  	my $count  = @params;
  	my $tuple  = Types::Standard::Tuple()->of(@params);
  	
  	return unless $tuple->can_be_inlined;
  	
  	sub {
  		$cycleuniq++;
  		
  		my $v = $_[1];
  		my @checks = $_arr->inline_check($v);
  		push @checks, sprintf(
  			'not(@%s %% %d)',
  			($v=~/\A\$[a-z0-9_]+\z/i ? $v : "{$v}"),
  			$count,
  		);
  		push @checks, sprintf(
  			'do { my $cyclecount%d = 0; my $cycleok%d = 1; while ($cyclecount%d < $#{%s}) { my $cycletmp%d = [@{%s}[$cyclecount%d .. $cyclecount%d+%d]]; unless (%s) { $cycleok%d = 0; last; }; $cyclecount%d += %d; }; $cycleok%d; }',
  			$cycleuniq,
  			$cycleuniq,
  			$cycleuniq,
  			$v,
  			$cycleuniq,
  			$v,
  			$cycleuniq,
  			$cycleuniq,
  			$count - 1,
  			$tuple->inline_check("\$cycletmp$cycleuniq"),
  			$cycleuniq,
  			$cycleuniq,
  			$count,
  			$cycleuniq,
  		) if grep { $_->inline_check('$xyz') ne '(!!1)' } @params;
  		join(' && ', @checks);
  	}
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	
  	my @constraints =
  		map Types::TypeTiny::to_TypeTiny($_), @{ $type->parameters };
  	
  	if (@$value % @constraints)
  	{
  		return [
  			sprintf('"%s" expects a multiple of %d values in the array', $type, scalar(@constraints)),
  			sprintf('%d values found', scalar(@$value)),
  		];
  	}
  	
  	for my $i (0 .. $#$value)
  	{
  		my $constraint = $constraints[$i % @constraints];
  		next if $constraint->check($value->[$i]);
  		
  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraint),
  			@{ $constraint->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	
  	my $child_coercions_exist = 0;
  	my $all_inlinable = 1;
  	for my $tc (@tuple)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		$child_coercions_exist++ if $tc->has_coercion;
  	}
  
  	return unless $child_coercions_exist;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label  = sprintf("CTUPLELABEL%d", ++$label_counter);
  			my $label2 = sprintf("CTUPLEINNER%d", $label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if scalar(@$orig) %% %d != 0;', $label, scalar @tuple);
  			push @code,         sprintf('my $%s = 0; while ($%s < @$orig) {', $label2, $label2);
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				
  				push @code, sprintf(
  					'do { $tmp = %s; (%s) ? ($new[$%s + %d]=$tmp) : (($return_orig=1), last %s) };',
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->[\$$label2 + $i]")
  						: "\$orig->[\$$label2 + $i]",
  					$ct->inline_check('$tmp'),
  					$label2,
  					$i,
  					$label,
  				);
  			}
  			push @code, sprintf('$%s += %d;', $label2, scalar(@tuple));
  			push @code,         '}';
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				
  				if (scalar(@$value) % scalar(@tuple) != 0)
  				{
  					return $value;
  				}
  				
  				my @new;
  				for my $i (0 .. $#$value)
  				{
  					my $ct = $tuple[$i % @tuple];
  					my $x  = $ct->has_coercion ? $ct->coerce($value->[$i]) : $value->[$i];
  					
  					return $value unless $ct->check($x);
  					
  					$new[$i] = $x;
  				}
  				
  				return \@new;
  			},
  		);
  	};
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::CycleTuple - internals for the Types::Standard CycleTuple type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_CYCLETUPLE

$fatpacked{"Types/Standard/Dict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_DICT';
  package Types::Standard::Dict;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Dict::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Dict::VERSION   = '1.002001';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_optional = Types::Standard::Optional;
  my $_hash     = Types::Standard::HashRef;
  my $_map      = Types::Standard::Map;
  my $_any      = Types::Standard::Any;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my %constraints = @_;
  	my %is_optional;
  	
  	while (my ($k, $v) = each %constraints)
  	{
  		$constraints{$k} = Types::TypeTiny::to_TypeTiny($v);
  		$is_optional{$k} = !!$constraints{$k}->is_strictly_a_type_of($_optional);
  		Types::TypeTiny::TypeTiny->check($v)
  			or _croak("Parameter to Dict[`a] for key '$k' expected to be a type constraint; got $v");
  	}
  	
  	return sub
  	{
  		my $value = $_[0];
  		if ($slurpy)
  		{
  			my %tmp = map {
  				exists($constraints{$_}) ? () : ($_ => $value->{$_})
  			} keys %$value;
  			return unless $slurpy->check(\%tmp);
  		}
  		else
  		{
  			exists($constraints{$_}) || return for sort keys %$value;
  		}
  		for my $k (sort keys %constraints) {
  			exists($value->{$k}) or ($is_optional{$k} ? next : return);
  			$constraints{$k}->check($value->{$k}) or return;
  		}
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	# We can only inline a parameterized Dict if all the
  	# constraints inside can be inlined.
  	
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	return if $slurpy && !$slurpy->can_be_inlined;
  	
  	# Is slurpy a very loose type constraint?
  	# i.e. Any, Item, Defined, Ref, or HashRef
  	my $slurpy_is_any = $slurpy && $_hash->is_a_type_of( $slurpy );
  	
  	# Is slurpy a parameterized Map, or expressable as a parameterized Map?
  	my $slurpy_is_map = $slurpy
  		&& $slurpy->is_parameterized
  		&& ((
  			$slurpy->parent->strictly_equals($_map)
  			&& $slurpy->parameters
  		)||(
  			$slurpy->parent->strictly_equals($_hash)
  			&& [ $_any, $slurpy->parameters->[0] ]
  		));
  	
  	my %constraints = @_;
  	for my $c (values %constraints)
  	{
  		next if $c->can_be_inlined;
  		return;
  	}
  	
  	my $regexp = join "|", map quotemeta, sort keys %constraints;
  	return sub
  	{
  		require B;
  		my $h = $_[1];
  		join " and ",
  			Types::Standard::HashRef->inline_check($h),
  			( $slurpy_is_any ? ()
  			: $slurpy_is_map ? do {
  				'(not grep {'
  				."my \$v = ($h)->{\$_};"
  				.sprintf(
  					'not((/\\A(?:%s)\\z/) or ((%s) and (%s)))',
  					$regexp,
  					$slurpy_is_map->[0]->inline_check('$_'),
  					$slurpy_is_map->[1]->inline_check('$v'),
  				) ."} keys \%{$h})"
  			}
  			: $slurpy ? do {
  				'do {'
  				. "my \$slurpy_tmp = +{ map /\\A(?:$regexp)\\z/ ? () : (\$_ => ($h)->{\$_}), keys \%{$h} };"
  				. $slurpy->inline_check('$slurpy_tmp')
  				. '}'
  			}
  			: "not(grep !/\\A(?:$regexp)\\z/, keys \%{$h})" ),
  			( map {
  				my $k = B::perlstring($_);
  				$constraints{$_}->is_strictly_a_type_of( $_optional )
  					? sprintf('(!exists %s->{%s} or %s)', $h, $k, $constraints{$_}->inline_check("$h\->{$k}"))
  					: ( "exists($h\->{$k})", $constraints{$_}->inline_check("$h\->{$k}") )
  			} sort keys %constraints ),
  	}
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my @params = @{ $type->parameters };
  	
  	my $slurpy = ref($params[-1]) eq q(HASH) ? pop(@params)->{slurpy} : undef;
  	my %constraints = @params;
  			
  	for my $k (sort keys %constraints)
  	{
  		next if $constraints{$k}->parent == Types::Standard::Optional && !exists $value->{$k};
  		next if $constraints{$k}->check($value->{$k});
  		
  		return [
  			sprintf('"%s" requires key %s to appear in hash', $type, B::perlstring($k))
  		] unless exists $value->{$k};
  		
  		return [
  			sprintf('"%s" constrains value at key %s of hash with "%s"', $type, B::perlstring($k), $constraints{$k}),
  			@{ $constraints{$k}->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	if ($slurpy)
  	{
  		my %tmp = map {
  			exists($constraints{$_}) ? () : ($_ => $value->{$_})
  		} keys %$value;
  		
  		my $explain = $slurpy->validate_explain(\%tmp, '$slurpy');
  		return [
  			sprintf('"%s" requires the hashref of additional key/value pairs to conform to "%s"', $type, $slurpy),
  			@$explain,
  		] if $explain;
  	}
  	else
  	{
  		for my $k (sort keys %$value)
  		{
  			return [
  				sprintf('"%s" does not allow key %s to appear in hash', $type, B::perlstring($k))
  			] unless exists $constraints{$k};
  		}
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  my $label_counter = 0;
  our ($keycheck_counter, @KEYCHECK) = -1;
  sub __coercion_generator
  {
  	my $slurpy = ref($_[-1]) eq q(HASH) ? pop(@_)->{slurpy} : undef;
  	my ($parent, $child, %dict) = @_;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	my $all_inlinable = 1;
  	my $child_coercions_exist = 0;
  	for my $tc (values %dict)
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		$child_coercions_exist++ if $tc->has_coercion;
  	}
  	$all_inlinable = 0 if $slurpy && !$slurpy->can_be_inlined;
  	$all_inlinable = 0 if $slurpy && $slurpy->has_coercion && !$slurpy->coercion->can_be_inlined;
  
  	$child_coercions_exist++ if $slurpy && $slurpy->has_coercion;
  	return unless $child_coercions_exist;
  
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			require B;
  			
  			my $keycheck = join "|", map quotemeta, sort { length($b) <=> length($a) or $a cmp $b } keys %dict;
  			$keycheck = $KEYCHECK[++$keycheck_counter] = qr{^($keycheck)$}ms; # regexp for legal keys
  			
  			my $label = sprintf("DICTLABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, %new) = ($_, 0);';
  			push @code,       "$label: {";
  			if ($slurpy)
  			{
  				push @code, sprintf('my $slurped = +{ map +($_=~$%s::KEYCHECK[%d])?():($_=>$orig->{$_}), keys %%$orig };', __PACKAGE__, $keycheck_counter);
  				if ($slurpy->has_coercion)
  				{
  					push @code, sprintf('my $coerced = %s;', $slurpy->coercion->inline_coercion('$slurped'));
  					push @code, sprintf('((%s)&&(%s))?(%%new=%%$coerced):(($return_orig = 1), last %s);', $_hash->inline_check('$coerced'), $slurpy->inline_check('$coerced'), $label);
  				}
  				else
  				{
  					push @code, sprintf('(%s)?(%%new=%%$slurped):(($return_orig = 1), last %s);', $slurpy->inline_check('$slurped'), $label);
  				}
  			}
  			else
  			{
  				push @code, sprintf('($_ =~ $%s::KEYCHECK[%d])||(($return_orig = 1), last %s) for sort keys %%$orig;', __PACKAGE__, $keycheck_counter, $label);
  			}
  			for my $k (keys %dict)
  			{
  				my $ct = $dict{$k};
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of($_optional);
  				my $K = B::perlstring($k);
  				
  				push @code, sprintf(
  					'if (exists $orig->{%s}) { $tmp = %s; (%s) ? ($new{%s}=$tmp) : (($return_orig=1), last %s) }',
  					$K,
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->{$K}")
  						: "\$orig->{$K}",
  					$ct->inline_check('$tmp'),
  					$K,
  					$label,
  				);
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			#warn "CODE:: @code";
  			"@code";
  		});
  	}
  	
  	else
  	{
  		my %is_optional = map {
  			; $_ => !!$dict{$_}->is_strictly_a_type_of($_optional)
  		} sort keys %dict;
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				
  				if ($slurpy)
  				{
  					my %slurped = map exists($dict{$_}) ? () : ($_ => $value->{$_}), keys %$value;
  					
  					if ($slurpy->check(\%slurped))
  					{
  						%new = %slurped;
  					}
  					elsif ($slurpy->has_coercion)
  					{
  						my $coerced = $slurpy->coerce(\%slurped);
  						$slurpy->check($coerced) ? (%new = %$coerced) : (return $value);
  					}
  					else
  					{
  						return $value;
  					}
  				}
  				else
  				{
  					for my $k (keys %$value)
  					{
  						return $value unless exists $dict{$k};
  					}
  				}
  
  				for my $k (keys %dict)
  				{
  					next if $is_optional{$k} and not exists $value->{$k};
  					
  					my $ct = $dict{$k};
  					my $x  = $ct->has_coercion ? $ct->coerce($value->{$k}) : $value->{$k};
  					
  					return $value unless $ct->check($x);
  					
  					$new{$k} = $x;
  				}
  				
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Dict - internals for the Types::Standard Dict type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_DICT

$fatpacked{"Types/Standard/HashRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_HASHREF';
  package Types::Standard::HashRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::HashRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::HashRef::VERSION   = '1.002001';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::HashRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to HashRef[`a] expected to be a type constraint; got $param");
  	
  	my $param_compiled_check = $param->compiled_check;
  	my $xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($param_compiled_check);
  		$xsub = Type::Tiny::XS::get_coderef_for("HashRef[$paramname]")
  			if $paramname;
  	}
  	elsif (Type::Tiny::_USE_MOUSE and $param->_has_xsub)
  	{
  		require Mouse::Util::TypeConstraints;
  		my $maker = "Mouse::Util::TypeConstraints"->can("_parameterize_HashRef_for");
  		$xsub = $maker->($param) if $maker;
  	}
  	
  	return (
  		sub
  		{
  			my $hash = shift;
  			$param->check($_) || return for values %$hash;
  			return !!1;
  		},
  		$xsub,
  	);
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	
  	my $compiled = $param->compiled_check;
  	if (Type::Tiny::_USE_XS)
  	{
  		my $paramname = Type::Tiny::XS::is_known($compiled);
  		my $xsubname  = Type::Tiny::XS::get_subname_for("HashRef[$paramname]");
  		return sub { "$xsubname\($_[1]\)" } if $xsubname;
  	}
  	
  	return unless $param->can_be_inlined;
  	my $param_check = $param->inline_check('$i');
  	return sub {
  		my $v = $_[1];
  		my $p = Types::Standard::HashRef->inline_check($v);
  		"$p and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$i (values \%{$v}) { "
  		.    "(\$ok = 0, last) unless $param_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $k (sort keys %$value)
  	{
  		my $item = $value->{$k};
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains each value in the hash with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('$return_orig++ && last unless (%s);', $coercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{$_} = (%s);', $param->coercion->inline_coercion('$orig->{$_}'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $coercable_item->check($value->{$k});
  					$new{$k} = $param->coerce($value->{$k});
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::HashRef - internals for the Types::Standard HashRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_HASHREF

$fatpacked{"Types/Standard/Map.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_MAP';
  package Types::Standard::Map;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Map::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Map::VERSION   = '1.002001';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $meta = Types::Standard->meta;
  
  no warnings;
  
  sub __constraint_generator
  {
  	return $meta->get_type('Map') unless @_;
  	
  	my ($keys, $values) = map Types::TypeTiny::to_TypeTiny($_), @_;
  	Types::TypeTiny::TypeTiny->check($keys)
  		or _croak("First parameter to Map[`k,`v] expected to be a type constraint; got $keys");
  	Types::TypeTiny::TypeTiny->check($values)
  		or _croak("Second parameter to Map[`k,`v] expected to be a type constraint; got $values");
  	
  	my @xsub;
  	if (Type::Tiny::_USE_XS)
  	{
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} ($keys, $values);
  		
  		if (@known == 2)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "Map[%s,%s]", @known
  			);
  			push @xsub, $xsub if $xsub;
  		}
  	}
  	
  	sub
  	{
  		my $hash = shift;
  		$keys->check($_)   || return for keys %$hash;
  		$values->check($_) || return for values %$hash;
  		return !!1;
  	}, @xsub;
  }
  
  sub __inline_generator
  {
  	my ($k, $v) = @_;
  	return unless $k->can_be_inlined && $v->can_be_inlined;
  	
  	if (Type::Tiny::_USE_XS)
  	{
  		my @known = map {
  			my $known = Type::Tiny::XS::is_known($_->compiled_check);
  			defined($known) ? $known : ();
  		} ($k, $v);
  		
  		if (@known == 2)
  		{
  			my $xsub = Type::Tiny::XS::get_subname_for(
  				sprintf "Map[%s,%s]", @known
  			);
  			return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  		}
  	}
  	
  	my $k_check = $k->inline_check('$k');
  	my $v_check = $v->inline_check('$v');
  	return sub {
  		my $h = $_[1];
  		my $p = Types::Standard::HashRef->inline_check($h);
  		"$p and do { "
  		.  "my \$ok = 1; "
  		.  "for my \$v (values \%{$h}) { "
  		.    "(\$ok = 0, last) unless $v_check "
  		.  "}; "
  		.  "for my \$k (keys \%{$h}) { "
  		.    "(\$ok = 0, last) unless $k_check "
  		.  "}; "
  		.  "\$ok "
  		."}"
  	};
  }
  
  sub __deep_explanation
  {
  	require B;
  	my ($type, $value, $varname) = @_;
  	my ($kparam, $vparam) = @{ $type->parameters };
  	
  	for my $k (sort keys %$value)
  	{
  		unless ($kparam->check($k))
  		{
  			return [
  				sprintf('"%s" constrains each key in the hash with "%s"', $type, $kparam),
  				@{ $kparam->validate_explain($k, sprintf('key %s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  		
  		unless ($vparam->check($value->{$k}))
  		{
  			return [
  				sprintf('"%s" constrains each value in the hash with "%s"', $type, $vparam),
  				@{ $vparam->validate_explain($value->{$k}, sprintf('%s->{%s}', $varname, B::perlstring($k))) },
  			];
  		}
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $kparam, $vparam) = @_;
  	return unless $kparam->has_coercion || $vparam->has_coercion;
  	
  	my $kcoercable_item = $kparam->has_coercion ? $kparam->coercion->_source_type_union : $kparam;
  	my $vcoercable_item = $vparam->has_coercion ? $vparam->coercion->_source_type_union : $vparam;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ((!$kparam->has_coercion or $kparam->coercion->can_be_inlined)
  	and (!$vparam->has_coercion or $vparam->coercion->can_be_inlined)
  	and $kcoercable_item->can_be_inlined
  	and $vcoercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, %new) = ($_, 0);';
  			push @code,    'for (keys %$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $kcoercable_item->inline_check('$_'));
  			push @code, sprintf('++$return_orig && last unless (%s);', $vcoercable_item->inline_check('$orig->{$_}'));
  			push @code, sprintf('$new{(%s)} = (%s);',
  				$kparam->has_coercion ? $kparam->coercion->inline_coercion('$_') : '$_',
  				$vparam->has_coercion ? $vparam->coercion->inline_coercion('$orig->{$_}') : '$orig->{$_}',
  			);
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\%new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my %new;
  				for my $k (keys %$value)
  				{
  					return $value unless $kcoercable_item->check($k) && $vcoercable_item->check($value->{$k});
  					$new{$kparam->has_coercion ? $kparam->coerce($k) : $k} =
  						$vparam->has_coercion ? $vparam->coerce($value->{$k}) : $value->{$k};
  				}
  				return \%new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Map - internals for the Types::Standard Map type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_MAP

$fatpacked{"Types/Standard/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_SCALARREF';
  package Types::Standard::ScalarRef;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::ScalarRef::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::ScalarRef::VERSION   = '1.002001';
  }
  
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  no warnings;
  
  sub __constraint_generator
  {
  	return Types::Standard::ScalarRef unless @_;
  	
  	my $param = Types::TypeTiny::to_TypeTiny(shift);
  	Types::TypeTiny::TypeTiny->check($param)
  		or _croak("Parameter to ScalarRef[`a] expected to be a type constraint; got $param");
  	
  	return sub
  	{
  		my $ref = shift;
  		$param->check($$ref) || return;
  		return !!1;
  	};
  }
  
  sub __inline_generator
  {
  	my $param = shift;
  	return unless $param->can_be_inlined;
  	return sub {
  		my $v = $_[1];
  		my $param_check = $param->inline_check("\${$v}");
  		"(ref($v) eq 'SCALAR' or ref($v) eq 'REF') and $param_check";
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	my $param = $type->parameters->[0];
  	
  	for my $item ($$value)
  	{
  		next if $param->check($item);
  		return [
  			sprintf('"%s" constrains the referenced scalar value with "%s"', $type, $param),
  			@{ $param->validate_explain($item, sprintf('${%s}', $varname)) },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  sub __coercion_generator
  {
  	my ($parent, $child, $param) = @_;
  	return unless $param->has_coercion;
  	
  	my $coercable_item = $param->coercion->_source_type_union;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  	
  	if ($param->coercion->can_be_inlined and $coercable_item->can_be_inlined)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $new) = ($_, 0);';
  			push @code,    'for ($$orig) {';
  			push @code, sprintf('++$return_orig && last unless (%s);', $coercable_item->inline_check('$_'));
  			push @code, sprintf('$new = (%s);', $param->coercion->inline_coercion('$_'));
  			push @code,    '}';
  			push @code,    '$return_orig ? $orig : \\$new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	else
  	{
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				my $new;
  				for my $item ($$value)
  				{
  					return $value unless $coercable_item->check($item);
  					$new = $param->coerce($item);
  				}
  				return \$new;
  			},
  		);
  	}
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::ScalarRef - internals for the Types::Standard ScalarRef type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_SCALARREF

$fatpacked{"Types/Standard/Tuple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_STANDARD_TUPLE';
  package Types::Standard::Tuple;
  
  use 5.006001;
  use strict;
  use warnings;
  
  BEGIN {
  	$Types::Standard::Tuple::AUTHORITY = 'cpan:TOBYINK';
  	$Types::Standard::Tuple::VERSION   = '1.002001';
  }
  
  use Type::Tiny ();
  use Types::Standard ();
  use Types::TypeTiny ();
  
  sub _croak ($;@) { require Error::TypeTiny; goto \&Error::TypeTiny::croak }
  
  my $_Optional = Types::Standard::Optional;
  
  no warnings;
  
  sub __constraint_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  		Types::TypeTiny::TypeTiny->check($slurpy)
  			or _croak("Slurpy parameter to Tuple[...] expected to be a type constraint; got $slurpy");
  	}
  	
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	for (@constraints)
  	{
  		Types::TypeTiny::TypeTiny->check($_)
  			or _croak("Parameters to Tuple[...] expected to be type constraints; got $_");
  	}
  	
  	# By god, the Type::Tiny::XS API is currently horrible
  	my @xsub;
  	if (Type::Tiny::_USE_XS and !$slurpy)
  	{
  		my @known = map {
  			my $known;
  			$known = Type::Tiny::XS::is_known($_->compiled_check)
  				unless $_->is_strictly_a_type_of($_Optional);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_coderef_for(
  				sprintf "Tuple[%s]", join(',', @known)
  			);
  			push @xsub, $xsub if $xsub;
  		}
  	}
  	
  	my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @constraints;
  	my $slurp_hash  = $slurpy && $slurpy->is_a_type_of(Types::Standard::HashRef);
  	my $slurp_any   = $slurpy && $slurpy->equals(Types::Standard::Any);
  	
  	sub
  	{
  		my $value = $_[0];
  		if ($#constraints < $#$value)
  		{
  			return !!0 unless $slurpy;
  			my $tmp;
  			if ($slurp_hash)
  			{
  				($#$value - $#constraints+1) % 2 or return;
  				$tmp = +{@$value[$#constraints+1 .. $#$value]};
  				$slurpy->check($tmp) or return;
  			}
  			elsif (not $slurp_any)
  			{
  				$tmp = +[@$value[$#constraints+1 .. $#$value]];
  				$slurpy->check($tmp) or return;
  			}
  		}
  		for my $i (0 .. $#constraints)
  		{
  			($i > $#$value)
  				and return !!$is_optional[$i];
  			
  			$constraints[$i]->check($value->[$i])
  				or return !!0;
  		}
  		return !!1;
  	}, @xsub;
  }
  
  sub __inline_generator
  {
  	my @constraints = @_;
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = pop(@constraints)->{slurpy};
  	}
  	
  	return if grep { not $_->can_be_inlined } @constraints;
  	return if defined $slurpy && !$slurpy->can_be_inlined;
  	
  	if (Type::Tiny::_USE_XS and !$slurpy)
  	{
  		my @known = map {
  			my $known;
  			$known = Type::Tiny::XS::is_known($_->compiled_check)
  				unless $_->is_strictly_a_type_of($_Optional);
  			defined($known) ? $known : ();
  		} @constraints;
  		
  		if (@known == @constraints)
  		{
  			my $xsub = Type::Tiny::XS::get_subname_for(
  				sprintf "Tuple[%s]", join(',', @known)
  			);
  			return sub { my $var = $_[1]; "$xsub\($var\)" } if $xsub;
  		}
  	}
  	
  	my $tmpl = "do { my \$tmp = +[\@{%s}[%d..\$#{%s}]]; %s }";
  	my $slurpy_any;
  	if (defined $slurpy)
  	{
  		$tmpl = 'do { my ($orig, $from, $to) = (%s, %d, $#{%s});'
  			.    '($to-$from % 2) and do { my $tmp = +{@{$orig}[$from..$to]}; %s }'
  			.    '}'
  			if $slurpy->is_a_type_of(Types::Standard::HashRef);
  		$slurpy_any = 1
  			if $slurpy->equals(Types::Standard::Any);
  	}
  	
  	my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @constraints;
  	my $min         = 0 + grep !$_, @is_optional;
  	
  	return sub
  	{
  		my $v = $_[1];
  		join " and ",
  			Types::Standard::ArrayRef->inline_check($v),
  			(
  				(scalar @constraints == $min and not $slurpy)
  					? "\@{$v} == $min"
  					: (
  						"\@{$v} >= $min",
  						(
  							$slurpy_any
  								? ()
  								: (
  									$slurpy
  										? sprintf($tmpl, $v, $#constraints+1, $v, $slurpy->inline_check('$tmp'))
  										: sprintf("\@{$v} <= %d", scalar @constraints)
  								)
  						),
  					)
  			),
  			map {
  				my $inline = $constraints[$_]->inline_check("$v\->[$_]");
  				$inline eq '(!!1)'
  					? ()
  					: (
  						$is_optional[$_]
  							? sprintf('(@{%s} <= %d or %s)', $v, $_, $inline)
  							: $inline
  					);
  			} 0 .. $#constraints;
  	};
  }
  
  sub __deep_explanation
  {
  	my ($type, $value, $varname) = @_;
  	
  	my @constraints = @{ $type->parameters };
  	my $slurpy;
  	if (exists $constraints[-1] and ref $constraints[-1] eq "HASH")
  	{
  		$slurpy = Types::TypeTiny::to_TypeTiny(pop(@constraints)->{slurpy});
  	}
  	@constraints = map Types::TypeTiny::to_TypeTiny($_), @constraints;
  	
  	if (@constraints < @$value and not $slurpy)
  	{
  		return [
  			sprintf('"%s" expects at most %d values in the array', $type, scalar(@constraints)),
  			sprintf('%d values found; too many', scalar(@$value)),
  		];
  	}
  	
  	for my $i (0 .. $#constraints)
  	{
  		next if $constraints[$i]->is_strictly_a_type_of( Types::Standard::Optional ) && $i > $#$value;
  		next if $constraints[$i]->check($value->[$i]);
  		
  		return [
  			sprintf('"%s" constrains value at index %d of array with "%s"', $type, $i, $constraints[$i]),
  			@{ $constraints[$i]->validate_explain($value->[$i], sprintf('%s->[%s]', $varname, $i)) },
  		];
  	}
  	
  	if (defined($slurpy))
  	{
  		my $tmp = $slurpy->is_a_type_of(Types::Standard::HashRef)
  			? +{@$value[$#constraints+1 .. $#$value]}
  			: +[@$value[$#constraints+1 .. $#$value]];
  		$slurpy->check($tmp) or return [
  			sprintf(
  				'Array elements from index %d are slurped into a %s which is constrained with "%s"',
  				$#constraints+1,
  				$slurpy->is_a_type_of(Types::Standard::HashRef) ? 'hashref' : 'arrayref',
  				$slurpy,
  			),
  			@{ $slurpy->validate_explain($tmp, '$SLURPY') },
  		];
  	}
  	
  	# This should never happen...
  	return;  # uncoverable statement
  }
  
  my $label_counter = 0;
  sub __coercion_generator
  {
  	my ($parent, $child, @tuple) = @_;
  	
  	my $slurpy;
  	if (exists $tuple[-1] and ref $tuple[-1] eq "HASH")
  	{
  		$slurpy = pop(@tuple)->{slurpy};
  	}
  	
  	my $child_coercions_exist = 0;
  	my $all_inlinable = 1;
  	for my $tc (@tuple, ($slurpy ? $slurpy : ()))
  	{
  		$all_inlinable = 0 if !$tc->can_be_inlined;
  		$all_inlinable = 0 if $tc->has_coercion && !$tc->coercion->can_be_inlined;
  		$child_coercions_exist++ if $tc->has_coercion;
  	}
  
  	return unless $child_coercions_exist;
  	my $C = "Type::Coercion"->new(type_constraint => $child);
  
  	if ($all_inlinable)
  	{
  		$C->add_type_coercions($parent => Types::Standard::Stringable {
  			my $label = sprintf("TUPLELABEL%d", ++$label_counter);
  			my @code;
  			push @code, 'do { my ($orig, $return_orig, $tmp, @new) = ($_, 0);';
  			push @code,       "$label: {";
  			push @code,       sprintf('(($return_orig = 1), last %s) if @$orig > %d;', $label, scalar @tuple) unless $slurpy;
  			for my $i (0 .. $#tuple)
  			{
  				my $ct = $tuple[$i];
  				my $ct_coerce   = $ct->has_coercion;
  				my $ct_optional = $ct->is_a_type_of(Types::Standard::Optional);
  				
  				push @code, sprintf(
  					'if (@$orig > %d) { $tmp = %s; (%s) ? ($new[%d]=$tmp) : (($return_orig=1), last %s) }',
  					$i,
  					$ct_coerce
  						? $ct->coercion->inline_coercion("\$orig->[$i]")
  						: "\$orig->[$i]",
  					$ct->inline_check('$tmp'),
  					$i,
  					$label,
  				);
  			}
  			if ($slurpy)
  			{
  				my $size = @tuple;
  				push @code, sprintf('if (@$orig > %d) {', $size);
  				push @code, sprintf('my $tail = [ @{$orig}[%d .. $#$orig] ];', $size);
  				push @code, $slurpy->has_coercion
  					? sprintf('$tail = %s;', $slurpy->coercion->inline_coercion('$tail'))
  					: q();
  				push @code, sprintf(
  					'(%s) ? push(@new, @$tail) : ($return_orig++);',
  					$slurpy->inline_check('$tail'),
  				);
  				push @code, '}';
  			}
  			push @code,       '}';
  			push @code,    '$return_orig ? $orig : \\@new';
  			push @code, '}';
  			"@code";
  		});
  	}
  	
  	else
  	{
  		my @is_optional = map !!$_->is_strictly_a_type_of($_Optional), @tuple;
  		
  		$C->add_type_coercions(
  			$parent => sub {
  				my $value = @_ ? $_[0] : $_;
  				
  				if (!$slurpy and @$value > @tuple)
  				{
  					return $value;
  				}
  				
  				my @new;
  				for my $i (0 .. $#tuple)
  				{
  					return \@new if $i > $#$value and $is_optional[$i];
  					
  					my $ct = $tuple[$i];
  					my $x  = $ct->has_coercion ? $ct->coerce($value->[$i]) : $value->[$i];
  					
  					return $value unless $ct->check($x);
  					
  					$new[$i] = $x;
  				}
  				
  				if ($slurpy and @$value > @tuple)
  				{
  					my $tmp = $slurpy->has_coercion
  						? $slurpy->coerce([ @{$value}[@tuple .. $#$value] ])
  						: [ @{$value}[@tuple .. $#$value] ];
  					$slurpy->check($tmp) ? push(@new, @$tmp) : return($value);
  				}
  				
  				return \@new;
  			},
  		);
  	};
  	
  	return $C;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Types::Standard::Tuple - internals for the Types::Standard Tuple type constraint
  
  =head1 STATUS
  
  This module is considered part of Type-Tiny's internals. It is not
  covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  This file contains some of the guts for L<Types::Standard>.
  It will be loaded on demand. You may ignore its presence.
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Types::Standard>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_STANDARD_TUPLE

$fatpacked{"Types/TypeTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_TYPETINY';
  package Types::TypeTiny;
  
  use strict;
  use warnings;
  
  our $AUTHORITY = 'cpan:TOBYINK';
  our $VERSION   = '1.002001';
  
  use Scalar::Util qw< blessed refaddr weaken >;
  
  our @EXPORT_OK = ( __PACKAGE__->type_names, qw/to_TypeTiny/ );
  
  my %cache;
  
  sub import
  {
  	# do the shuffle!
  	no warnings "redefine";
  	our @ISA = qw( Exporter::Tiny );
  	require Exporter::Tiny;
  	my $next = \&Exporter::Tiny::import;
  	*import = $next;
  	my $class = shift;
  	my $opts  = { ref($_[0]) ? %{+shift} : () };
  	$opts->{into} ||= scalar(caller);
  	return $class->$next($opts, @_);
  }
  
  sub meta
  {
  	return $_[0];
  }
  
  sub type_names
  {
  	qw( CodeLike StringLike TypeTiny HashLike ArrayLike );
  }
  
  sub has_type
  {
  	my %has = map +($_ => 1), shift->type_names;
  	!!$has{ $_[0] };
  }
  
  sub get_type
  {
  	my $self = shift;
  	return unless $self->has_type(@_);
  	no strict qw(refs);
  	&{$_[0]}();
  }
  
  sub coercion_names
  {
  	qw();
  }
  
  sub has_coercion
  {
  	my %has = map +($_ => 1), shift->coercion_names;
  	!!$has{ $_[0] };
  }
  
  sub get_coercion
  {
  	my $self = shift;
  	return unless $self->has_coercion(@_);
  	no strict qw(refs);
  	&{$_[0]}();  # uncoverable statement
  }
  
  sub StringLike ()
  {
  	require Type::Tiny;
  	$cache{StringLike} ||= "Type::Tiny"->new(
  		name       => "StringLike",
  		constraint => sub {    defined($_   ) && !ref($_   ) or Scalar::Util::blessed($_   ) && overload::Method($_   , q[""])  },
  		inlined    => sub { qq/defined($_[1]) && !ref($_[1]) or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[""])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub HashLike ()
  {
  	require Type::Tiny;
  	$cache{HashLike} ||= "Type::Tiny"->new(
  		name       => "HashLike",
  		constraint => sub {    ref($_   ) eq q[HASH] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[%{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[HASH] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\%{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub ArrayLike ()
  {
  	require Type::Tiny;
  	$cache{ArrayLike} ||= "Type::Tiny"->new(
  		name       => "ArrayLike",
  		constraint => sub {    ref($_   ) eq q[ARRAY] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[@{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[ARRAY] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\@{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub CodeLike ()
  {
  	require Type::Tiny;
  	$cache{CodeLike} ||= "Type::Tiny"->new(
  		name       => "CodeLike",
  		constraint => sub {    ref($_   ) eq q[CODE] or Scalar::Util::blessed($_   ) && overload::Method($_   , q[&{}])  },
  		inlined    => sub { qq/ref($_[1]) eq q[CODE] or Scalar::Util::blessed($_[1]) && overload::Method($_[1], q[\&{}])/ },
  		library    => __PACKAGE__,
  	);
  }
  
  sub TypeTiny ()
  {
  	require Type::Tiny;
  	$cache{TypeTiny} ||= "Type::Tiny"->new(
  		name       => "TypeTiny",
  		constraint => sub {  Scalar::Util::blessed($_   ) && $_   ->isa(q[Type::Tiny])  },
  		inlined    => sub { my $var = $_[1]; "Scalar::Util::blessed($var) && $var\->isa(q[Type::Tiny])" },
  		library    => __PACKAGE__,
  	);
  }
  
  my %ttt_cache;
  
  sub to_TypeTiny
  {
  	my $t = $_[0];
  	
  	return $t unless (my $ref = ref $t);
  	return $t if $ref =~ /^Type::Tiny\b/;
  	
  	return $ttt_cache{ refaddr($t) } if $ttt_cache{ refaddr($t) };
  	
  	if (my $class = blessed $t)
  	{
  		return $t                               if $class->isa("Type::Tiny");
  		return _TypeTinyFromMoose($t)           if $class->isa("Moose::Meta::TypeConstraint");
  		return _TypeTinyFromMoose($t)           if $class->isa("MooseX::Types::TypeDecorator");
  		return _TypeTinyFromValidationClass($t) if $class->isa("Validation::Class::Simple");
  		return _TypeTinyFromValidationClass($t) if $class->isa("Validation::Class");
  		return _TypeTinyFromGeneric($t)         if $t->can("check") && $t->can("get_message"); # i.e. Type::API::Constraint
  	}
  	
  	return _TypeTinyFromCodeRef($t) if $ref eq q(CODE);
  	
  	$t;
  }
  
  sub _TypeTinyFromMoose
  {
  	my $t = $_[0];
  	
  	if (ref $t->{"Types::TypeTiny::to_TypeTiny"})
  	{
  		return $t->{"Types::TypeTiny::to_TypeTiny"};
  	}
  	
  	if ($t->name ne '__ANON__')
  	{
  		require Types::Standard;
  		my $ts = 'Types::Standard'->get_type($t->name);
  		return $ts if $ts->{_is_core};
  	}
  	
  	my %opts;
  	$opts{display_name} = $t->name;
  	$opts{constraint}   = $t->constraint;
  	$opts{parent}       = to_TypeTiny($t->parent)              if $t->has_parent;
  	$opts{inlined}      = sub { shift; $t->_inline_check(@_) } if $t->can("can_be_inlined") && $t->can_be_inlined;
  	$opts{message}      = sub { $t->get_message($_) }          if $t->has_message;
  	$opts{moose_type}   = $t;
  	
  	require Type::Tiny;
  	my $new = 'Type::Tiny'->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	
  	$new->{coercion} = do {
  		require Type::Coercion::FromMoose;
  		'Type::Coercion::FromMoose'->new(
  			type_constraint => $new,
  			moose_coercion  => $t->coercion,
  		);
  	} if $t->has_coercion;
  	
  	return $new;
  }
  
  sub _TypeTinyFromValidationClass
  {
  	my $t = $_[0];
  	
  	require Type::Tiny;
  	require Types::Standard;
  	
  	my %opts = (
  		parent            => Types::Standard::HashRef(),
  		_validation_class => $t,
  	);
  	
  	if ($t->VERSION >= "7.900048")
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = eval { $t->validate };
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			my $f = $t->filtering; $t->filtering('off');
  			my $r = (eval { $t->validate } ? "OK" : $t->errors_to_string);
  			$t->filtering($f || 'pre');
  			return $r;
  		};
  	}
  	else  # need to use hackish method
  	{
  		$opts{constraint} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate };
  		};
  		$opts{message} = sub {
  			$t->params->clear;
  			$t->params->add(%$_);
  			no warnings "redefine";
  			local *Validation::Class::Directive::Filters::execute_filtering = sub { $_[0] };
  			eval { $t->validate } ? "OK" : $t->errors_to_string;
  		};
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	
  	$new->coercion->add_type_coercions(
  		Types::Standard::HashRef() => sub {
  			my %params = %$_;
  			for my $k (keys %params)
  				{ delete $params{$_} unless $t->get_fields($k) };
  			$t->params->clear;
  			$t->params->add(%params);
  			eval { $t->validate };
  			$t->get_hash;
  		},
  	);
  	
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  sub _TypeTinyFromGeneric
  {
  	my $t = $_[0];
  	
  	# XXX - handle inlining??
  	
  	my %opts = (
  		constraint => sub { $t->check(@_ ? @_ : $_) },
  		message    => sub { $t->get_message(@_ ? @_ : $_) },
  	);
  	
  	$opts{display_name} = $t->name if $t->can("name");
  	
  	$opts{coercion} = sub { $t->coerce(@_ ? @_ : $_) }
  		if $t->can("has_coercion") && $t->has_coercion && $t->can("coerce");
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  my $QFS;
  sub _TypeTinyFromCodeRef
  {
  	my $t = $_[0];
  	
  	my %opts = (
  		constraint => sub {
  			return !!eval { $t->($_) };
  		},
  		message => sub {
  			local $@;
  			eval { $t->($_); 1 } or do { chomp $@; return $@ if $@ };
  			return sprintf('%s did not pass type constraint', Type::Tiny::_dd($_));
  		},
  	);
  	
  	if ($QFS ||= "Sub::Quote"->can("quoted_from_sub"))
  	{
  		my (undef, $perlstring, $captures) = @{ $QFS->($t) || [] };
  		if ($perlstring)
  		{
  			$perlstring = "!!eval{ $perlstring }";
  			$opts{inlined} = sub
  			{
  				my $var = $_[1];
  				Sub::Quote::inlinify(
  					$perlstring,
  					$var,
  					$var eq q($_) ? '' : "local \$_ = $var;",
  					1,
  				);
  			} if $perlstring && !$captures;
  		}
  	}
  	
  	require Type::Tiny;
  	my $new = "Type::Tiny"->new(%opts);
  	$ttt_cache{ refaddr($t) } = $new;
  	weaken($ttt_cache{ refaddr($t) });
  	return $new;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =for stopwords arrayfication hashification
  
  =head1 NAME
  
  Types::TypeTiny - type constraints used internally by Type::Tiny
  
  =head1 STATUS
  
  This module is covered by the
  L<Type-Tiny stability policy|Type::Tiny::Manual::Policies/"STABILITY">.
  
  =head1 DESCRIPTION
  
  Dogfooding.
  
  This isn't a real Type::Library-based type library; that would involve
  too much circularity. But it exports some type constraints which, while
  designed for use within Type::Tiny, may be more generally useful.
  
  =head2 Types
  
  =over
  
  =item C<< StringLike >>
  
  Accepts strings and objects overloading stringification.
  
  =item C<< HashLike >>
  
  Accepts hashrefs and objects overloading hashification.
  
  =item C<< ArrayLike >>
  
  Accepts arrayrefs and objects overloading arrayfication.
  
  =item C<< CodeLike >>
  
  Accepts coderefs and objects overloading codification.
  
  =item C<< TypeTiny >>
  
  Accepts blessed L<Type::Tiny> objects.
  
  =back
  
  =head2 Coercion Functions
  
  =over
  
  =item C<< to_TypeTiny($constraint) >>
  
  Promotes (or "demotes" if you prefer) a Moose::Meta::TypeConstraint object
  to a Type::Tiny object.
  
  Can also handle L<Validation::Class> objects. Type constraints built from 
  Validation::Class objects deliberately I<ignore> field filters when they
  do constraint checking (and go to great lengths to do so); using filters for
  coercion only. (The behaviour of C<coerce> if we don't do that is just too
  weird!)
  
  Can also handle any object providing C<check> and C<get_message> methods.
  (This includes L<Mouse::Meta::TypeConstraint> objects.) If the object also
  provides C<has_coercion> and C<coerce> methods, these will be used too.
  
  Can also handle coderefs (but not blessed coderefs or objects overloading
  C<< &{} >>). Coderefs are expected to return true iff C<< $_ >> passes the
  constraint. If C<< $_ >> fails the type constraint, they may either return
  false, or die with a helpful error message.
  
  =back
  
  =head2 Methods
  
  These are implemented so that C<< Types::TypeTiny->meta->get_type($foo) >>
  works, for rough compatibility with a real L<Type::Library> type library.
  
  =over
  
  =item C<< meta >>
  
  =item C<< type_names >>
  
  =item C<< get_type($name) >>
  
  =item C<< has_type($name) >>
  
  =item C<< coercion_names >>
  
  =item C<< get_coercion($name) >>
  
  =item C<< has_coercion($name) >>
  
  =back
  
  =head1 BUGS
  
  Please report any bugs to
  L<http://rt.cpan.org/Dist/Display.html?Queue=Type-Tiny>.
  
  =head1 SEE ALSO
  
  L<Type::Tiny>.
  
  =head1 AUTHOR
  
  Toby Inkster E<lt>tobyink@cpan.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENCE
  
  This software is copyright (c) 2013-2014, 2017 by Toby Inkster.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =head1 DISCLAIMER OF WARRANTIES
  
  THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
TYPES_TYPETINY

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.74;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\x0c\x00\x00";
     # use strict, use utf8; use feature;
     $^H |= 0x1c820fc0;
     @^H{qw(feature_switch feature___SUB__ feature_state feature_say feature_fc feature_evalbytes feature_unicode)} = (1) x 7;
  }
  
  1
X86_64-LINUX-THREAD-MULTI_COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# Igor - dotfile management for perl hackers
# Copyright (C) 2017, 2018  Simon Schuster
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use warnings;
use strict;

BEGIN { unshift @INC, './lib'; }

use Igor::CLI;

# Simply dispatch, wuhu
Igor::CLI::main(@ARGV);

__END__

=encoding utf8

=head1 NAME

igor - Because nothing makes you feel so as home like a good igor

I<A humble attempt at configuration management - dotfile management for perl hackers>

=head1 SYNOPSIS

igor [general options] <subcommand> [subcommand options]

  General Options:
    --help|-h|-?   Display help
    --config|-c    Configuration file to use
    --verbose|-v   Be Verbose

  Subcommands:
    apply          Apply the specifiec configuration
    diff           Show differences between applied and stored configuration
    gc             Show obsolete files

=head1 OPTIONS

=over 8

=item B<C<--help|-h|-?>>

Print a brief help message and exits. Can be passed multiple times. Passing
twice will show the full documentation.

=item B<C<--config|-c> conffile>

Set the config file to use, instead of F<config.toml> in the current directory

=item B<C<--verbose|-v>>

Be a bit more verbose when conduction business. Can be passed multiple times.
Passing once enables the C<debug> mode most useful to debug issues with the
current configuration. C<trace> is even more verbose and logs various internal
states.

=back

=head1 SUBCOMMANDS

=head2 apply

Apply a configuration to this computer.
The default is to use the configuration specified by this computers hostname.

=over 8

=item B<C<--dry-run>>

Only list what would be done, but do not actually perform the operations.

=item B<C<--task> T>

Apply configuration C<T> instead of the default one

=back

=head2 diff

Show changes between stored and effective configuration

=head3 gc

Show obsolete files

=head1 DOCUMENTATION

=head2 FUNDAMENTALS

Igors approach to dotfile management mirrors the concept of traditional package
management. Therefore, instead of delivering all dotfiles at once, files are
grouped into L<packages|/PACKAGES> which can be enabled for individual hosts
selectively.

L<Configurations|/CONFIGURATION> describe the set of packages that igor should
activate. By providing L<facts|/facts> for the current environment, they further
allow igor to customize the packages and their templates before deployment.

=head2 PACKAGES

Igor manages individual configuration files as packages. Each package comprises
a set of files relating to a specific task or aspect of the system.  Often,
this will coincide with a program (e.g.: the C<zsh> package might contain
F<.zprofile>, F<.zshrc> and F<.zshenv>), while the can also relate to
functionality (e.g.: C<mail> comprising a F<.muttrc>, F<.mbsyncrc> and
F<.msmtprc>).

=head3 Filesystem Layout

In the filesystem, each package is represented as a directory. In the simplest
case, a package consists of the mandatory package description file (either
F<package.toml> or F<package.pl>, see below L<[1]|/"TOML">
L<[2]|/"Perl-style package description">).

In the simplest case, all actual configuration files to install for the package
reside in a flat flat folder alongside the package description file:

	vim
	├── package.toml
	├── env.sh
	├── vimrc
	├── runinstall.sh
	└── neobundle.toml.tmpl

However, you are free to reorganize them into subfolders as you see fit:

	vim
	├── files
	│   ├── env.sh
	│   └── vimrc
	├── hooks
	│   └── runinstall.sh
	├── package.toml
	└── templates
		└── neobundle.toml.tmpl

The package description file then specifies what actions should be performed on
these files.

=head3 TOML

The operations to be performed by a package are described by the
F<package.toml> file, which describes the operations to be performed
in L<TOML syntax|https://github.com/toml-lang/toml>.

Each package consists of four components:

=over

=item Files

A list of files or directories that should be deployed into the filesystem.

The most basic operation a package can perform is symlinking a file (e.g.
F<./symlink> to F<~/test/symlink>):

	[[files]]
	source     = "./symlink"
	dest       = "~/test/symlink"
	operation  = "symlink"

Specifying the operation in this example is not strictly necessary, as
C<"symlink"> actually constitutes the default. Sometimes, however, it is
necessary to actually copy the package file, which can be forced by the
C<"copy"> operation. Optionally, you can also specify the filesystem
permissions of the copied file there:

	[[files]]
	source     = "./copy"
	dest       = "~/test/copy"
	operation  = "copy"
	perm       = "0644"

However, often it is not enough to simply copy complete files. For instance,
the shell's C<.*-profile> usually comprises environment variables from several
packages. To this end, igor provides I<collections>, whose contents are collected
from all files specified in the package configuration:

	[[files]]
	source     = "./env.sh"
	collection = "profile"

Here, C<profile> specifies the name of the collection. All content from all
configured packages for said collection is collected, merged and then deployed
on the host.
The merge and deployment of named collections is configured in the
L<top level configuration file|/CONFIGURATION>.

=item Templates

Sometimes, it is useful to adapt configuration files before deployment and
provide tailored variations.

Example: On work computers, I want to set my work email address as the default
git C<user.email>.

To this end, the user can configure facts for any active configuration inside
the L<top level configuration file|/CONFIGURATION> or derive them automatically
from the environments via L<factors|/Custom factors>.

This information can then be interpolated into template files. The templating
is based on L<Text::Template|https://metacpan.org/pod/Text::Template>, which
uses perl as its templating language. The default escape characters are curly
braces C<{}>:

	# In ./gitconfig.tmpl
	[user]
	name  = Nixus Minimax
	email = { $facts{dev}->{git}->{email} }

To deploy apply templating and deploy this file, specify the destination (see
Files above for the syntax for dest/collection) in the F<package.toml> file:

	[[templates]]
	source      = "./gitconfig.tmpl"
	dest        = "~/.config/git/config"
	perm        = "..."

However, configuration files often already use C<{}> as syntactical elements.
Therefore, it is possible to use custom delimiters:

	# In package.toml
	[[templates]]
	source      = "./files/config"
	dest        = "~/.config/git/config"
	delimiters  = { open = "#BEGIN_TEMPLATE", close = "#END_TEMPLATE"}

	# In ./gitconfig.tmpl
	[user]
		name  = Nixus Minimax
	#BEGIN_TEMPLATE
	<<"EOF"
		email = $facts{dev}->{git}->{email}
	EOF
	#END_TEMPLATE
	...

=item Dependencies

Furthermore, sometimes there is interdependence between configuration files.
For instance, my C<i3> configuration spawns C<rofi> for running programs.
Therefore, whenever the package C<i3> is deployed, C<rofi>'s configuration
should be installed as well. This can be enforced by declaring the dependency
in C<i3>'s F<package.toml> file:

	# in i3/package.toml
	dependencies = [ 'rofi' ]

=item Hooks

Hooks allow to run certain commands before and after package installation.  To
this end, igor provides two lists (C<precmds> and C<postcmds>) which make it
possible to specify commands to be run before and after installation
respectively.

	precmds = [
		"mkdir -p ~/.cache/vim/",
		"echo hallo welt"
	]

	postcmds = [
		["./hooks/runinstall.sh"],
		["echo", "hallo", "welt"]
	]

The arrays can either store the commands as string, which will be executed by
the default users shell. Alternatively, the hooks can be specified as an array
of strings. In that case, the systems shell is bypassed and the command will be
invoked directly using exec, bypassing the system shell.

=back

=head4 Perl-style package description

Please see the L<section TOML|/TOML> for a full description of the individual
fields.

The TOML-style package description is the preferred way of package description.
However, in some cases, a more programmatic way of specifiying package-contents
might be desired: For instance by omitting certain files or by automatically
generating a large number of file operations to cope with hundreds of
individual files inside a package.

In this case, the C<package.pl> package description format provides a mechanism
to create the relevant datastructure describing the package via perl code:

	sub {
	  my ($config) = @_; # effective configuration
	  # $config->{facts} comprises the configured facts
	  # $config->{pacakges} lists the packages being installed
	  my $package = ...; # perform calculations
	  return $package;
	}

The return type C<$package> is a perl hash with keys analogous to the
L<TOML|/TOML> components, for example:

	my $package = {
		files => [ { source => "./file", dest => "~/.myfile" }
		         , { source => "./file2", dest => "~/.myfile", operation => 'copy' }
		],
		dependencies => ['otherpackage1', 'otherpackage2'],
		template => [ { source => "...", dest => "..."}
		            , { source => "..."}, collection => "collectionname" }
		            ],
		postcmds => [ 'command arg1 arg2', [ 'cmd2', 'arg21', 'arg22'] ]
	}

=head2 CONFIGURATION

A configurations specifies which packages to install and defines parameters for
the current deployment.
The configuration is expressed in a L<TOML|https://github.com/toml-lang/toml>
configuration file.
By default, igor looks for a file named F<config.toml> in the pwd.
This default can be overwritten by passing an alternative filename to
C<-c|--config>.

The configuration file stores different configurations as TOML tables:

	[defaults]
	...

	[configurations.cfg1]
	...

	[configurations.cfg2]

=head3 Configuration format

Each configuration block describes the various attributes of the desired system
state.

=over 4

=item Repositories and Packages

Most importantly, the configuration defines which repositories to
consult when resolving package names and the list of packages to be installed:

	[configurations.config]
	repositories = {
		repository1 = { path = './repo1' }
		repository2 = { path = './repo2' }
	}
	packages = ['pkg1', 'repository1/pkg2', 'repository2/pkg2', 'repository2/pkg42']

The above snippet configures igor to search for packages in two repositories located
at F<./repo1> and F<./repo2> I<relative to the configuration file> and installs three
packages from those repositories.
Repositories are named (C<repository1> and C<repository2>).
The list of packages to be installed in specified in the C<packages> list.  By
default, igor tries to resolve packagenames in all configured repositories.
However, in case the package name is ambiguous, an error will be reported and
the execution is terminated. In that case, the packagename can be explicitly
namespaced by the repository name (e.g. C<repository1/pkg2> and C<repository2/pkg2>).

=item Facts

Templates as well as perl-style packages allow to tailor packages and package
contents to the host environment. C<facts> allow to describe attributes of the
current configuration. Examples include: the username of the current user, the
git commit email address that should be used, which development plugins for
which programming languages should be configured in the vimrc, ...

In the configuration, facts are represented as a (potentially nested) hash:

	[configurations.config.facts]
	git_email = mail@example.org
	dev = { languages = { viml = true, perl = true, haskell = false }}
	mailaccounts = [
		{ user = 'work@biz.example.org', server = 'mx.example.org' },
		{ user = 'private@example.org', server = 'hugo.example.org' },
	]
	hostname = 'luggage'

In addition to explicitly specified facts, some facts (e.g. C<hostname> above)
can be automatically gathered for all hosts using L<factors|/Custom factors>.
Inside templates, those automatic facts are stored in the hash C<%automatic>.

=item Collections

Often, certain files store configuration that relates to different system
components and as such to different packages (e.g. your shells environment
file, which might export environment variables for your editor (e.g. C<EDITOR>,
your own C<PATH>, ...)).
Collections allow to receive input from multiple packages and merge those into
a single file.

	[configurations.computer.collections]
	'env.sh' = {
		destination = '~/env.sh',  # Storage location of the merged file
		perm = "0644",             # Permissions for the generated file
	}

If no permissions (C<perm>) are specified, the default umask is used.
Inside the packages, collections can be used as a substitute to the C<dest> parameter:

	[[files]]
	source     = "./files/env.sh"
	collection = "env.sh"

By default, all entries are merged by sorting the components by packagename and
concatenating those together. As this simplistic strategy is not sufficient for
complex files (e.g.: we always need the C<env> package first, which declares
important variables like C<HOME>, C<XDG_*>, ... and are used by other
components within the generated collection file F<env.sh>). Therefore,
alternative merge strategies can be specified:

	[configurations.config]
	mergers = { envmerger = './mergers/envmerger.pl' }
	collections = {
		'env.sh' = {
			destination = '~/env.sh'
			merger = 'envmerger' # name in the mergers hash
		}
	}

For the contents of F<./mergers/envmerger.pl> see the section on
L<custom mergers|/Custom collection mergers>

=item Advanced features: C<dependencies>, C<factors>, C<mergers> and C<mergeconfigs>

For the advanced features like C<dependencies>, C<factors>, C<mergers> and
C<mergeconfigs>, see below.

=back

=head3 Cascade

However, igor does not confine itself to merely defining individual
configurations.  Instead, at the core of igor is a cascading configuration
system: The basic idea is that each system's configuration actually consits of
several aspects.

For instance, all configurations share a common set of default values and basic
packages (e.g. I use a z-Shell everywhere,...) and on top of that, I have
configurations for developing Haskell, reading Mail, running graphical
environments, etc. These actually (hopefully) form a directed acyclic graph,
as displayed in the image below:

    +---------------------------------------------------------------------------+
    |                       defaults                                            |
    |    repositories = { repo1 = ... }                                         |
    |    facts = {                                                              |
    |              opt1 = false, opt2 = 'def', opt3 = 1, opt4 = { rec = true }, |
    |              opt5 = [ 1, 2, 3 ]                                           |
    |            }                                                              |
    |    packages = [ 'pkg1', 'pkg2' ]                                          |
    |                                                                           |
    +---------------------------------------------------------------------------+
              ^                          ^                            ^
              |                          |                            |
    +-------------------+       +-------------------+       +-------------------+
    |       cfg1        |       |       cfg2        |       |       cfg3        |
    | facts =           |       | facts =           |       | facts =           |
    |   {opt1 = false}  |       |  {opt1 = false,   |       |  {opt4 =          |
    +-------------------+       |   optX = 'hallo'} |       |    {rec = false}  |
              ^                 | packages =        |       |   opt3 = 42}      |
              |                 |  ['pkg2', 'pkg3'] |       +-------------------+
              |                 +-------------------+                 ^
              |                            ^      ^                   |
              |                            |      |                   |
    +-------------------+                  |      +-------------------+
    |       cfg4        |                  |      |       cfg5        |
    | facts =           |                  |      | facts =           |
    |   {opt1 = false}  |                  |      |   {opt1 = true}   |
    +-------------------+                  |      +-------------------+
                                           |               ^
                                           |               |
                                         +-------------------+
                                         |       cfg6        |
                                         | packages =        |
                                         |   [ 'pkg42' ]     |
                                         +-------------------+
                                                  ^
                                                  |
                                         active configuration

Dependencies between configurations are declared by the C<dependencies> member
inside the configuration block in F<config.toml>.

	[configurations.cfg6]
		dependencies = ['cfg2', 'cfg5']

Igor merges the set of (transitively) active configurations from top to bottom:

	defaults -> cfg2 -> cfg3 -> cfg5 -> cfg5

Therefore, the above results in the following effective configuration:

	repositories = { repo1 = ...}
	facts = {
		opt1 = true,
		opt2 = 'def',
		opt3 = 42,
		opt4 = {rec = false },
		opt5 = [1, 2, 3],
		optX = 'hallo'
	}
	packages = ['pkg1', 'pkg2', 'pkg3', 'pkg42']

C<repositories> and C<facts> are merged by the NestedHash merge strategy.
Descend into the nested hash as far as possible. As soon as something is found
that is not a hash, its value is replaced by the value of the overlay. That
way, the key C<facts.opt4.rec> will be toggled from C<true> to C<false> when
C<cfg3> is merged into C<defaults>.

The list C<packages> on the other hand is merged by concatenation of the lists
(and eliminating duplicates).

To configure such context-preserving merge strategies for individual keys
within C<facts>, custom mergers can be defined (see L</Custom fact mergers>).

=head3 Custom fact mergers

Custom fact mergers allow to specify how multiple values inside the C<facts>
section of configurations should be merged inside the cascade described in the
preceding section. The declaration consists of three components.

=over 4

=item 1.

Description of the modified merge strategy as a file (e.g.
F<./mergers/althashmerger.pl>):

	sub {
		my ($l, $r, $breadcrumbs) = @_;
		# $l : left  (= less specific) fact value
		# $r : right (= more specific) fact value
		# $breadcrumbs: arrayref describing the position in the facts hash,
		#               e.g. ['dev', 'languages'] for key 'facts.dev.languages'

		# Here, we simply take the more specific value (default behaviour)
		return $r;
	}

Of course, you can call utility functions from igors codebase where useful:

	sub {
		# Cheating, actually we simply call the default hash merging strategy... :)
		Igor::Merge::uniq_list_merge(@_)
	}

=item 2.

The declaration of the merger inside the main configuration file. This is the
path to a file containing the code as a perl subroutine, which we symbolically
bind to the name C<altmerger>:

	[defaults]
	mergers = { altmerger = './mergers/althashmerger.pl' }

B<Note:> As fact-mergers are used to merge configurations, they can only be
specified within the C<[defaults]> section.

=item 3.

A description to what elements this merger should be applied. This configuration
is represented as a nested hash, where the leafs name the merger that should be
used to merge the specified values inside configurations. In the example, it
registers the C<altmerger> declared above for the facts in C<recursive.hell>.

	[defaults]
	mergeconfig = { facts = { recursive = {hell = 'altmerger' } } }

B<Note:> As fact-mergers are used to merge configurations, they can only be
specified within the C<[defaults]> section.

=back

=head3 Custom collection mergers

Custom collection mergers are declared analogous to custom fact mergers by
defining the merge routine as a perl sub inside a file and symbolically naming
it insed the main config file:

	[configurations.config]
	mergers = {
		envmerger = './mergers/envmerger.pl',
	}

Contents of F<./mergers/envmerger.pl>, which ensures that the contents of the
C<main/base> package will be at the head of the merged configuration file:

	sub {
		my $hash = shift;
		# Hash of packagename -> filecontens

		# Perform a copy as we will do destructive updates below
		my %copy = %$hash;

		# Extract the contents of the "base"-packages, as we want to prepend it
		my $base = $copy{'main/base'};
		delete $copy{'main/base'};

		# Order the other artifacts in alphabetic order by package name
		my @keys = sort { $a cmp $b } keys %copy;
		join('', $base, map {$copy{$_}} @keys)
	}

Those custom mergers can then be referenced by setting the C<merger> parameter
for specified collections:

	[configurations.config]
	collections = {
		'env.sh' = {
			destination = '~/env.sh',
			merger = 'envmerger',
		}
	}

=head3 Custom factors

Some facts can be automatically obtained from the execution environment by
executing so called C<factors>, which are declared in the C<defaults.factors>
array in the main configuration file:

	[defaults]
	factors = [
		{path = './factors/executables.sh', type = 'script'},
		{path = './factors/environment.pl', type = 'perl'},
	]

There are two types of factors:

=over 4

=item C<script> factors


	[defaults]
	factors = [
		{path = './factors/executables.sh', type = 'script'},
	}

Execute scripts using C<system> und parse the scripts stdout as
L<TOML|https://github.com/toml-lang/toml>, e.g.:

	# ./factors/executables.sh
	#!/usr/bin/env sh

	# Find all executable binaries in PATH and store them in the "automatic.executables"
	# fact as an array.
	echo "executables = ["

	IFS=':';
	for i in $PATH; do
		test -d "$i" && find "$i" -maxdepth 1 -executable -type f -exec basename {} \;;
	done | sort -u | sed 's/^/\t"/g;s/$/",/g'

	echo "]"

=item C<perl> factors

	[defaults]
	factors = [
		{path = './factors/environment.pl', type = 'perl'},
	]

Execute a perl sub and use the returned perl datastructure as automatically
generated facts, e.g.:

	# ./factors/environment.pl
	sub {
		# store the environment variables as an automatic fact in "automatic.env"
		{env => \%ENV}
	}

=back

=head3 Task selection

If no task/configuration is specified at the command line using the C<--task>
command line argument, igor tries to autodetect the configuration to apply.
The first step is guessing an identifier by determining the fully qualified
domain name (FQDN) and falling back to the plain hostname if the FQDN is
unavailable.

The C<configuration.pattern> options and configuration names are matched
against this guessed identifier. If the selection is unique, this
configuration will be automatically used and applied. If multiple patterns
match, an error will be signaled instead.

=head2 EXAMPLE

Here, a more complete example showing of the different features in TOML syntax.

	[defaults]
		repositories = {
			main = { path = './repo' }
		}
		facts = {
			haskell = true,
		}
		factors = [
			{path = './factors/executables.sh', type = 'script'},
			{path = './factors/environment.pl', type = 'perl'},
		]
		mergers = { altmerger = './mergers/althashmerger.pl' }
		mergeconfig = { facts = { recursive = {hell = 'altmerger' } } }

	[configurations.interactive]
		packages = ['tmux']
		facts = {
			haskell = true,
			perl = true,
			recursive = {
				hell  = ['hades'],
				truth = 42,
			}
		}

	[configurations.computer]
		dependencies = ['interactive']
		packages = ['vim', 'file-test', 'perlpackage-test']
		facts = {
			haskell = false,
			recursive = {hell = ['hades', 'hel']},
		}
		mergers = {
			envmerger = './mergers/envmerger.pl',
		}
		collections = {
			'env.sh' = {
				destination = '~/env.sh',
				merger = 'envmerger',
			},
			'test1.collection' = {
				destination = '~/test/test1.collection',
				perm = "0644",
			},
			'test2.collection' = {
				destination = '~/test/test2.collection',
			}
		}




=head2 INSTALLATION / DISTRIBUTION

Igor is designed to be portable and not require an actual installation on
the host system (even more: it is actually designed with public systems such
as university infrastructure in mind, where the user might not possess
administrator privileges).

Instead, igor is best distributed as a single script file (fatpacked, that is
containing all dependencies) alongside your dotfiles.

To obtain the fatpacked script, either download it from the official release
page or build it yourself:

	# Install all dependencies locally to ./local using carton
	# See DEVELOPMENT SETUP below for details
	carton install
	./bin/fatpack.sh

The fatpacked script can be found in F<./bin/igor.fatpacked.pl> and be executed
standalone.

=head2 HACKING

=head3 DESGIN/CODE STRUCTURE

C<Igor::CLI::main> in F<lib/Igor/CLI.pl> constitutes igor's entrypoint and
outlines the overall execution flow.

The main steps are:

=over 4

=item 1.
Command line parsing and setup

=item 2.
Parsing the config

=item 3.
Using the layering system to determine the config to apply

=item 4.
Building the package database and configuring the individual packages

=item 5.
Applying the relevant subcommand (eiter applying a configuration, diff, gc...)

=back

The last step (5.) borrows a lot of its internal structure from the layout of
compilers: Each package is deconstructed into a set of C<transactions>. These
transactions describe the operations to install the package. Available
operations include: Collecting facts (C<RunFactor>), executing commands
(C<RunCommand>), symlinking or copying files (C<FileTransfer>) and installing
templates (C<Template>) and finally merging and emitting collections
(C<EmitCollection>). Each transaction has an attribute (C<Operation::order>)
that defines the execution order of the individual transaction.

=head3 LIBRARIES

Igor uses a couple of external libraries that ease development and foster code
reuse. However, to maintain portability and the ability to fatpack igor for
distribution, B<all libraries used have to be pure perl libraries>.
All libraries used can be found in the F<cpanfile>.

The most ubiquitous libraries that you will notice when working with the code are:

=over 4

=item C<Class::Tiny>

Igor uses an object-oriented design. C<Class::Tiny> is used to ease class
construction in a lightweight fashion.

=item C<Log::ger>

Used internally for logging. Provides C<log_(trace|debug|info|warn|error)>
functions to log on different verbosity levels. C<Igor::Util::colored> can be
used to modify the text printed to the terminal (e.g. C<log_info colored(['bold
blue'] "Text")> will print C<Text> to stdout in bold blue).

=item C<Path::Tiny>

All variables describing filepaths are converted to C<Path::Tiny> at first
opportunity. The objects provide a wide variety of auxiliary functions for dealing
with files.

=item C<Types::Standard>

C<Types::Standard> is used to verify conformance of parsed, nested configuration
data structures with the expected format.

=back

=head3 DEVELOPMENT SETUP

=head4 Installing dependencies

Igor provides a F<cartonfile> to declare and manage its library dependencies.
Therefore L<carton|https://metacpan.org/release/carton> can be used to install
the required nonstandard libraries:

	carton install

Carton can then be used to execute C<igor> with those locally installed libs:

	carton exec -- ./igor.pl --help

=head4 Running tests

Several unittests are provided. They are written with C<Test::More> and reside
in the folder F<./t> and can be executed using C<prove> or, when using carton
by running C<carton exec prove>.

In addition, an example configuration is provided in F<./test/test_minimal> as
an integration test case.
B<WARNING:> Running the following command on your development machine might
overwrite configuration files on the host. Only execute them in a virtual
machine or container.
	igor.pl apply -vv --dry-run -c ./test/test_minimal/config.toml --task computer

To ease development, two scripts are provided to create and manage docker
containers for igor development.
F<bin/builddocker.pl> will generate a set of dockerfiles in the folder
F<./docker> for minimal configurations of various operating systems configured
in F<bin/builddocker.pl> and builds the corresponding images.
F<bin/devup.sh> will start the archlinux-image and mount the igor-folder into
the container in read-only mode. There, new changes of igor can be tested.
Instead of using carton, you can use the fatpacked script inside the container,
which emulates the behaviour on typical hosts. (Yet, igor will prefer local
modules from the F<lib/Igor> folder to those fatpacked: that way, changes
can be tested without rerunning F<bin/fatpack.sh>).

	# On host
	# Build/Prepare
	./bin/builddocker.pl # just once
	./bin/fatpack.sh     # just once
	# Start the container
	./bin/devup.sh

	# In the container
	./igor.packed.pl --help

=cut
